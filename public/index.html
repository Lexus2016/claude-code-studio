<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claude Code Studio</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #090d13; --s1: #111620; --s2: #181e2b; --s3: #1f2637;
  --border: #2a3347; --text: #dce6f5; --muted: #7a8baa;
  --accent: #7c6aef; --accent2: #a08df5; --abg: rgba(124,106,239,.13);
  --green: #3fb950; --orange: #e5a435; --red: #f85149; --blue: #58a6ff;
  --tool-bg: #131925; --r: 10px;
  --code-bg: #0d1219; --user-msg: #1a2460;
  --sidebar-w: 280px; --sidebar-r: 300px;
  --shadow: 0 4px 24px rgba(0,0,0,.4);
  --shadow-sm: 0 1px 4px rgba(0,0,0,.2);
  --shadow-md: 0 4px 16px rgba(0,0,0,.32);
  --shadow-lg: 0 12px 48px rgba(0,0,0,.5);
  --shadow-xl: 0 24px 64px rgba(0,0,0,.65);
  --r-sm: 6px; --r-md: 10px; --r-lg: 14px; --r-xl: 20px;
  --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
  --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
  --msg-font: 15.5px;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); height: 100vh; display: flex; overflow: hidden; font-size: 15px; line-height: 1.55; }

/* ─── Focus visible (keyboard nav) ─── */
:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; border-radius: 3px; }
button:focus-visible, a:focus-visible { border-radius: 5px; }

/* ─── Subtle background noise texture ─── */
body::after {
  content: '';
  position: fixed; inset: 0; z-index: 9998; pointer-events: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='300'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='300' height='300' filter='url(%23n)' opacity='1'/%3E%3C/svg%3E");
  opacity: 0.022;
}

/* ─── Staggered message entry ─── */
.mw:nth-child(1) { animation-delay: 0ms; }
.mw:nth-child(2) { animation-delay: 30ms; }
.mw:nth-child(3) { animation-delay: 60ms; }
.mw:nth-child(n+4) { animation-delay: 0ms; }

/* ─── Layout ─── */
.left {
  width: var(--sidebar-w); background: var(--s1);
  border-right: 1px solid var(--border);
  display: flex; flex-direction: column; flex-shrink: 0; overflow: hidden;
  transition: width .25s cubic-bezier(.4,0,.2,1), opacity .25s;
}
.left.collapsed { width: 0; opacity: 0; pointer-events: none; overflow: hidden; }
.left-inner { flex: 1; display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; min-height: 0; }
.left-inner::-webkit-scrollbar { width: 3px; }
.left-inner::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.center { flex: 1; display: flex; flex-direction: column; min-width: 0; position: relative; }
.right {
  width: var(--sidebar-r); background: var(--s1);
  border-left: 1px solid var(--border);
  display: flex; flex-direction: column; flex-shrink: 0;
  transition: width .25s cubic-bezier(.4,0,.2,1), opacity .25s;
}
.right.collapsed { width: 0; opacity: 0; pointer-events: none; overflow: hidden; }
.hidden { display: none !important; }

/* ─── Panel Toggle Tabs ─── */
.panel-tab {
  width: 14px; display: flex; align-items: center; justify-content: center;
  background: var(--s1); cursor: pointer; flex-shrink: 0;
  position: relative; transition: background .15s; user-select: none; z-index: 10;
}
.panel-tab:hover { background: var(--s2); }
.panel-tab-left { border-right: 1px solid var(--border); }
.panel-tab-right { border-right: 1px solid var(--border); }
.panel-tab-inner {
  width: 14px; height: 56px; display: flex; align-items: center; justify-content: center;
  background: var(--s2); border: 1px solid var(--border); border-radius: 0 5px 5px 0;
  transition: background .15s, border-color .15s;
}
.panel-tab-right .panel-tab-inner { border-radius: 0 5px 5px 0; }
.panel-tab:hover .panel-tab-inner { background: var(--s3); border-color: var(--accent); }
.panel-tab-inner svg {
  width: 10px; height: 10px; color: var(--muted); flex-shrink: 0;
  transition: transform .25s cubic-bezier(.4,0,.2,1), color .15s;
}
.panel-tab:hover .panel-tab-inner svg { color: var(--accent2); }
/* Left tab: default=collapsed → chevron right (→ to open) */
.panel-tab-left .panel-tab-inner svg { transform: rotate(0deg); }
/* Left tab: active=visible → chevron left (← to close) */
.panel-tab-left.active .panel-tab-inner svg { transform: rotate(180deg); }
/* Right tab (left of right panel): collapsed → chevron left (← click to open) */
.panel-tab-right .panel-tab-inner svg { transform: rotate(180deg); }
/* Right tab: active=visible → chevron right (→ click to close) */
.panel-tab-right.active .panel-tab-inner svg { transform: rotate(0deg); }
/* Tooltips handled by JS (#globalTip) */

/* ─── Sections ─── */
.sec { border-bottom: 1px solid var(--border); }
.sec-title { padding: 9px 12px; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: .8px; color: var(--muted); display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; transition: color .15s; }
.sec-title:hover { color: var(--text); }
.sec-title .badge { background: var(--accent); color: white; font-size: 10px; padding: 1px 7px; border-radius: 10px; font-weight: 700; min-width: 20px; text-align: center; }
.sec-title .badge:empty { display: none; }
.sec-body { padding: 4px 8px 10px; }
.sec-body.collapsed { display: none; }

/* ─── Version badge in header ─── */
#versionBadge { font-size: 11px; color: var(--muted); cursor: default; letter-spacing: .3px; }
#versionBadge.update { color: var(--orange); cursor: pointer; text-decoration: underline dotted; }

/* ─── Project dropdown in header ─── */
.proj-dd-wrap { position: relative; display: none; }
.proj-dd-wrap.visible { display: inline-block; }
.proj-dd-btn {
  display: inline-flex; align-items: center; gap: 8px;
  font-size: 13px; font-weight: 600; color: var(--accent2);
  background: linear-gradient(135deg, rgba(124,106,239,.15) 0%, rgba(124,106,239,.08) 100%);
  border: 1px solid rgba(124,106,239,.35);
  border-radius: 8px; padding: 6px 14px; cursor: pointer;
  max-width: 280px; transition: all .2s ease; font-family: inherit;
  box-shadow: 0 2px 8px rgba(124,106,239,.12);
}
.proj-dd-btn:hover {
  background: linear-gradient(135deg, rgba(124,106,239,.22) 0%, rgba(124,106,239,.12) 100%);
  border-color: var(--accent);
  box-shadow: 0 4px 12px rgba(124,106,239,.2);
  transform: translateY(-1px);
}
.proj-dd-btn.open {
  background: linear-gradient(135deg, rgba(124,106,239,.25) 0%, rgba(124,106,239,.15) 100%);
  border-color: var(--accent);
  box-shadow: 0 4px 16px rgba(124,106,239,.25);
}
.proj-dd-btn .proj-dd-icon { font-size: 14px; flex-shrink: 0; }
.proj-dd-btn .proj-dd-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.proj-dd-btn .proj-dd-arrow { font-size: 10px; opacity: .6; transition: transform .2s; flex-shrink: 0; }
.proj-dd-btn.open .proj-dd-arrow { transform: rotate(180deg); opacity: 1; }
.proj-dd-menu {
  position: absolute; top: 100%; left: 0; margin-top: 8px;
  min-width: 300px; max-width: 400px;
  background: var(--s2); border: 1px solid var(--border);
  border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,.35), 0 0 0 1px rgba(124,106,239,.1);
  z-index: 1000; opacity: 0; visibility: hidden;
  transform: translateY(-8px); transition: all .2s var(--ease-out);
  overflow: hidden;
}
.proj-dd-menu.open { opacity: 1; visibility: visible; transform: translateY(0); }
.proj-dd-search { padding: 12px; border-bottom: 1px solid var(--border); background: rgba(124,106,239,.05); }
.proj-dd-search input {
  width: 100%; background: var(--s3); border: 1px solid var(--border);
  border-radius: 8px; padding: 8px 12px; font-size: 13px; color: var(--text);
  outline: none; font-family: inherit; transition: border-color .15s, box-shadow .15s;
}
.proj-dd-search input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124,106,239,.15); }
.proj-dd-list { max-height: 320px; overflow-y: auto; padding: 6px 0; }
.proj-dd-list::-webkit-scrollbar { width: 6px; }
.proj-dd-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.proj-dd-list::-webkit-scrollbar-thumb:hover { background: var(--muted); }
.proj-dd-item {
  position: relative;
  display: flex; flex-direction: column; gap: 3px;
  padding: 10px 16px; cursor: pointer; transition: background .12s;
  border-left: 3px solid transparent;
}
.proj-dd-item:hover { background: var(--s3); }
.proj-dd-item.active {
  background: rgba(124,106,239,.1);
  border-left-color: var(--accent);
}
.proj-dd-item .proj-dd-item-name { font-size: 14px; font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; gap: 8px; }
.proj-dd-item .proj-dd-item-path { font-size: 11px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-left: 22px; }
.proj-dd-item.active .proj-dd-item-name { color: var(--accent2); }
.proj-dd-item.active .proj-dd-item-name::before { content: '●'; color: var(--accent); font-size: 8px; flex-shrink: 0; }
.proj-dd-empty { padding: 20px 16px; text-align: center; color: var(--muted); font-size: 13px; }

/* ─── Rate limit badge ─── */
#rlBadge { display:none; position:relative; align-items:center; gap:5px; padding:3px 9px; border-radius:6px; font-size:12px; font-weight:600; cursor:default; user-select:none; background:rgba(245,158,11,.15); border:1px solid rgba(245,158,11,.45); color:#f59e0b; transition:background .2s,border-color .2s; }
#rlBadge.rl-crit { background:rgba(239,68,68,.15); border-color:rgba(239,68,68,.45); color:#ef4444; }
#rlBadge .rl-dot { width:7px; height:7px; border-radius:50%; background:currentColor; flex-shrink:0; animation:rlPulse 1.8s ease-in-out infinite; }
@keyframes rlPulse { 0%,100%{opacity:1;transform:scale(1)} 50%{opacity:.45;transform:scale(.8)} }
#rlBadge .rl-label { white-space:nowrap; }
#rlTooltip { display:none; position:absolute; top:100%; right:0; margin-top:6px; width:275px; background:#1a1f2e; border:1px solid rgba(245,158,11,.35); border-radius:10px; padding:13px 15px; z-index:99999; box-shadow:0 8px 32px rgba(0,0,0,.55); font-size:12.5px; line-height:1.55; }
/* Bridge: transparent 6px area above tooltip keeps #rlBadge:hover true while mouse travels down */
#rlTooltip::after { content:''; position:absolute; top:-6px; left:0; right:0; height:6px; }
#rlBadge:hover #rlTooltip { display:block; }
#rlTooltip .rl-tt-title { font-weight:700; font-size:13px; color:var(--text); margin-bottom:9px; display:flex; align-items:center; gap:6px; }
#rlTooltip .rl-tt-row { display:flex; justify-content:space-between; align-items:center; padding:3px 0; border-bottom:1px solid rgba(255,255,255,.05); }
#rlTooltip .rl-tt-row:last-child { border-bottom:none; }
#rlTooltip .rl-tt-key { color:var(--muted); }
#rlTooltip .rl-tt-val { color:var(--text); font-weight:600; text-align:right; }
#rlTooltip .rl-bar { height:5px; border-radius:3px; background:rgba(255,255,255,.1); margin:8px 0 5px; overflow:hidden; }
#rlTooltip .rl-bar-fill { height:100%; border-radius:3px; background:#f59e0b; transition:width .4s; }
#rlTooltip .rl-bar-fill.rl-crit { background:#ef4444; }

/* ─── Rate limit rejected modal ─── */
#rlRejectedModal .confirm-dialog { width: 360px; }
#rlRejectedModal .cd-icon { font-size: 36px; }
#rlRejectedModal .rl-modal-countdown { display: inline-flex; align-items: center; gap: 6px; margin-top: 6px; padding: 8px 16px; border-radius: 8px; background: rgba(239,68,68,.12); border: 1px solid rgba(239,68,68,.25); color: #ef4444; font-size: 18px; font-weight: 700; font-variant-numeric: tabular-nums; letter-spacing: .5px; }
#rlRejectedModal .rl-modal-countdown .rl-cd-label { font-size: 12px; font-weight: 500; color: var(--muted); }
#rlRejectedModal .rl-modal-type { display: inline-block; padding: 2px 8px; border-radius: 4px; background: rgba(245,158,11,.15); color: #f59e0b; font-size: 11px; font-weight: 600; margin-bottom: 10px; }
.cd-btn-ok { background: var(--accent); color: #fff; box-shadow: 0 2px 8px rgba(99,102,241,.35); }
.cd-btn-ok:hover { filter: brightness(1.15); box-shadow: 0 3px 12px rgba(99,102,241,.5); }

/* ─── File browser action buttons ─── */
.fii .fdl, .fii .fpe { opacity: 0; background: none; border: none; color: var(--muted); cursor: pointer; font-size: 12px; padding: 1px 4px; border-radius: 3px; transition: opacity .1s, color .1s; flex-shrink: 0; line-height: 1; }
.fii:hover .fdl, .fii:hover .fpe { opacity: .7; }
.fii .fdl:hover { color: var(--accent2); opacity: 1 !important; }
.fii .fpe:hover { color: var(--green); opacity: 1 !important; }

/* ─── Skill categories ─── */
.sk-cat { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: .8px; color: var(--muted); padding: 10px 10px 4px; opacity: .7; }
.sk-cat:first-child { padding-top: 2px; }

/* ─── Toggle items ─── */
.ci { display: flex; align-items: center; gap: 10px; padding: 8px 10px; border-radius: var(--r); cursor: pointer; font-size: 13px; transition: background .12s; border: 1px solid transparent; }
.ci:hover { background: var(--s2); }
.ci.on { background: rgba(124,106,239,.08); border-color: rgba(124,106,239,.2); }
/* Toggle switch */
.sw { position: relative; width: 36px; height: 20px; flex-shrink: 0; }
.sw input { opacity: 0; width: 0; height: 0; position: absolute; }
.sw-track { position: absolute; inset: 0; background: var(--s3); border-radius: 20px; border: 1px solid var(--border); transition: background .2s, border-color .2s; }
.ci.on .sw-track { background: var(--accent); border-color: var(--accent); }
.sw-thumb { position: absolute; top: 3px; left: 3px; width: 12px; height: 12px; background: white; border-radius: 50%; transition: transform .2s; box-shadow: 0 1px 3px rgba(0,0,0,.3); }
.ci.on .sw-thumb { transform: translateX(16px); }
/* Info */
.ci .inf { flex: 1; min-width: 0; }
.ci .inf .nm { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text); }
.ci .inf .ds { font-size: 12px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 2px; }
.ci .inf .st { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: .4px; margin-top: 2px; color: var(--muted); }
.ci.on .inf .st { color: var(--accent2); }
/* Remove button */
.ci .rm { opacity: 0; background: none; border: none; color: var(--red); cursor: pointer; font-size: 14px; padding: 3px 6px; border-radius: 4px; transition: opacity .12s; flex-shrink: 0; }
.ci:hover .rm { opacity: .45; }
.ci .rm:hover { opacity: 1 !important; background: rgba(248,81,73,.1); }
.ci .cfg { opacity: 0; background: none; border: none; color: var(--muted); cursor: pointer; font-size: 13px; padding: 3px 6px; border-radius: 4px; transition: opacity .12s, color .12s; flex-shrink: 0; }
.ci:hover .cfg { opacity: .6; }
.ci .cfg:hover { opacity: 1 !important; color: var(--accent2); background: rgba(124,106,239,.1); }
.ci .ren { opacity: 0; background: none; border: none; color: var(--muted); cursor: pointer; font-size: 13px; padding: 3px 6px; border-radius: 4px; transition: opacity .12s, color .12s; flex-shrink: 0; }
.ci:hover .ren { opacity: .6; }
.ci .ren:hover { opacity: 1 !important; color: var(--accent2); background: rgba(124,106,239,.1); }
.proj-rename-input { font-size: 13px; font-weight: 600; font-family: inherit; color: var(--text); background: var(--s2); border: 1px solid var(--accent); border-radius: 5px; padding: 1px 6px; outline: none; width: 100%; min-width: 0; }
.ci .warn-dot { width: 7px; height: 7px; border-radius: 50%; background: var(--orange); flex-shrink: 0; margin-right: -4px; }
.af select { background: var(--s2); border: 1px solid var(--border); color: var(--text); padding: 6px 9px; border-radius: 6px; font-size: 12px; font-family: inherit; outline: none; cursor: pointer; transition: border .12s; }
.af select:focus { border-color: var(--accent); }
#mcpStdioFields, #mcpUrlFields { display: flex; flex-direction: column; gap: 6px; }

/* ─── Add buttons & forms ─── */
.add-btn { display: flex; align-items: center; gap: 6px; padding: 6px 9px; margin-top: 4px; border-radius: var(--r); cursor: pointer; font-size: 12px; color: var(--accent2); border: 1px dashed var(--border); background: none; width: 100%; transition: all .12s; }
.auto-skills-btn { font-size: 11px; font-weight: 700; color: var(--muted); background: none; border: 1px solid var(--border); border-radius: 4px; padding: 1px 6px; cursor: pointer; transition: all .15s; line-height: 1.6; letter-spacing: .3px; }
.auto-skills-btn:hover { color: var(--accent2); border-color: var(--accent); }
.auto-skills-btn.active { background: var(--accent); border-color: var(--accent); color: white; }
.auto-notif { font-size: 10px; color: var(--accent2); padding: 2px 10px 6px; }
.add-btn:hover { background: var(--abg); border-color: var(--accent); }
.af { margin-top: 7px; display: flex; flex-direction: column; gap: 6px; }
.af input, .af textarea { background: var(--s2); border: 1px solid var(--border); color: var(--text); padding: 6px 9px; border-radius: 6px; font-size: 12px; font-family: inherit; outline: none; transition: border .12s; }
.af input:focus, .af textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124,106,239,.15); }
.af textarea { resize: vertical; min-height: 44px; font-family: 'SF Mono', monospace; font-size: 11px; }
.fr { display: flex; gap: 6px; }
.fr button { padding: 5px 13px; border-radius: 6px; border: none; cursor: pointer; font-size: 12px; font-weight: 500; }
.bp { background: var(--accent); color: white; }
.bp:hover { background: var(--accent2); }
.bg { background: var(--s2); color: var(--muted); border: 1px solid var(--border) !important; }

/* ─── History ─── */
.hist-list { flex: 1; overflow-y: auto; padding: 4px 8px; max-height: 200px; }
.hist-item { padding: 7px 10px; border-radius: var(--r); cursor: pointer; font-size: 13px; display: flex; justify-content: space-between; align-items: center; gap: 7px; transition: background .1s; }
.hist-item:hover { background: var(--s2); }
.hist-item.active { background: var(--abg); border-left: 2px solid var(--accent); padding-left: 8px; }
.hist-item .ht { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.hist-item .hd { font-size: 11px; color: var(--muted); flex-shrink: 0; }
.hist-item .del { opacity: 0; background: none; border: none; color: var(--red); cursor: pointer; font-size: 12px; padding: 2px 5px; border-radius: 3px; }
.hist-item:hover .del { opacity: .5; }
.hist-item .del:hover { opacity: 1; }
/* ─── History bulk selection ─── */
.hist-select-btn { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 13px; padding: 1px 4px; border-radius: 3px; line-height: 1; opacity: .6; flex-shrink: 0; }
.hist-select-btn:hover { opacity: 1; color: var(--accent); }
.hist-select-btn.active { color: var(--accent); opacity: 1; }
.hist-item .hist-chk { width: 14px; height: 14px; flex-shrink: 0; accent-color: var(--accent); cursor: pointer; display: none; }
.hist-selmode .hist-item .hist-chk { display: block; }
.hist-selmode .hist-item .del { display: none !important; }
.hist-selmode .hist-item { cursor: default; }
.hist-selmode .hist-item.selected { background: var(--abg) !important; }
.hist-bulk-bar { display: none; padding: 5px 8px; gap: 5px; border-top: 1px solid var(--border); margin-top: 2px; }
.hist-bulk-bar.visible { display: flex; align-items: center; }
.hist-bulk-bar .bulk-info { font-size: 11px; color: var(--muted); flex: 1; }
.hist-bulk-bar .bulk-all { background: none; border: 1px solid var(--border); color: var(--fg); font-size: 11px; padding: 3px 8px; border-radius: 3px; cursor: pointer; white-space: nowrap; }
.hist-bulk-bar .bulk-all:hover { border-color: var(--accent); color: var(--accent); }
.hist-bulk-bar .bulk-del { background: var(--red); border: none; color: #fff; font-size: 11px; padding: 3px 10px; border-radius: 3px; cursor: pointer; white-space: nowrap; }
.hist-bulk-bar .bulk-del:hover { opacity: .85; }
.hist-bulk-bar .bulk-del:disabled { opacity: .35; cursor: not-allowed; }
.hist-spin { width: 8px; height: 8px; flex-shrink: 0; margin-right: 4px; }

/* ─── Header ─── */
.hdr { display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; background: var(--s1); border-bottom: 1px solid var(--border); }
.hdr-l { display: flex; align-items: center; gap: 10px; }
.logo { width: 32px; height: 32px; border-radius: 9px; background: linear-gradient(135deg, var(--accent), #a855f7); display: flex; align-items: center; justify-content: center; font-weight: 800; font-size: 10px; color: white; flex-shrink: 0; box-shadow: 0 2px 8px rgba(124,106,239,.4); }
.hdr h1 { font-size: 16px; font-weight: 700; letter-spacing: -.2px; }
.hdr-meta { display: flex; align-items: center; gap: 6px; }
.status-dot { display: inline-flex; align-items: center; gap: 5px; font-size: 13px; }
.status-dot::before { content: '●'; font-size: 8px; }
.status-dot.ok { color: var(--green); }
.status-dot.ok::before { color: var(--green); }
.status-dot.err { color: var(--red); }
.status-dot.err::before { color: var(--red); }
.status-dot.warn { color: var(--orange); }
.status-dot.warn::before { color: var(--orange); }
.hdr-btns { display: flex; gap: 5px; }
.hb { background: var(--s2); border: 1px solid var(--border); color: var(--muted); padding: 5px 11px; border-radius: 7px; cursor: pointer; font-size: 13px; transition: all .15s; font-weight: 500; }
.hb:hover { color: var(--text); border-color: var(--accent2); background: var(--s3); }
.hb.active { color: var(--accent2); border-color: var(--accent); background: var(--abg); }
/* ─── Nav switcher (Chat ↔ Kanban) ─── */
.nav-sw { display: flex; align-items: center; background: var(--s3); border: 1px solid var(--border); border-radius: 8px; padding: 3px; gap: 2px; }
.nav-sw-btn { display: inline-flex; align-items: center; gap: 5px; padding: 4px 11px; border-radius: 6px; font-size: 13px; font-weight: 600; color: var(--muted); text-decoration: none; transition: all .15s; white-space: nowrap; }
.nav-sw-btn:hover { color: var(--text); background: rgba(255,255,255,.05); }
.nav-sw-btn.active { background: var(--s2); color: var(--accent2); box-shadow: 0 1px 3px rgba(0,0,0,.3); }

/* ─── Toolbar ─── */
.toolbar { display: flex; align-items: center; gap: 7px; padding: 6px 14px; background: var(--s1); border-bottom: 1px solid var(--border); flex-wrap: nowrap; overflow-x: auto; }
.tb-group { display: flex; align-items: center; gap: 2px; background: var(--s2); border: 1px solid var(--border); border-radius: 8px; padding: 3px; }
.tb-group .label { font-size: 11px; color: var(--muted); padding: 0 7px; text-transform: uppercase; letter-spacing: .6px; font-weight: 700; }
.tb-btn { padding: 4px 11px; border-radius: 6px; border: none; background: transparent; color: var(--muted); cursor: pointer; font-size: 13px; transition: all .12s; white-space: nowrap; font-weight: 500; }
.tb-btn:hover { color: var(--text); background: rgba(255,255,255,.06); }
.tb-btn.on { background: var(--accent); color: white; box-shadow: 0 1px 6px rgba(124,106,239,.4); }
.tb-sep { width: 1px; height: 20px; background: var(--border); margin: 0 2px; }
.tb-input { background: var(--s2); border: 1px solid var(--border); color: var(--text); padding: 4px 8px; border-radius: 6px; font-size: 13px; width: 55px; outline: none; text-align: center; }
.tb-input:focus { border-color: var(--accent); }
.mode-ind { font-size: 12px; color: var(--muted); padding: 2px 8px; display: flex; align-items: center; gap: 5px; }
.dot { width: 7px; height: 7px; border-radius: 50%; display: inline-block; flex-shrink: 0; }
.dot-plan { background: var(--blue); }
.dot-task { background: var(--green); }
.dot-auto { background: var(--orange); }

/* ─── Messages ─── */
.msgs { flex: 1; overflow-y: auto; padding: 12px 18px 40px; display: flex; flex-direction: column; gap: 12px; scroll-behavior: smooth; scroll-padding-bottom: 40px; }
.msgs::-webkit-scrollbar { width: 4px; }
.msgs::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.mw { max-width: 86%; animation: fadeUp .15s ease; position: relative; }
.mw:hover .cpb { opacity: .6; }
.mw:hover .cpmd { opacity: .6; }
@keyframes fadeUp { from { opacity: 0; transform: translateY(6px); } }
.mw.user { align-self: flex-end; }
.mw.assistant { align-self: flex-start; }

/* ─── Message bubbles ─── */
.msg { line-height: 1.75; font-size: var(--msg-font, 15.5px); word-break: break-word; }
.mw.user .msg { background: var(--user-msg); padding: 10px 15px; border-radius: 14px 14px 4px 14px; white-space: pre-wrap; border: 1px solid rgba(124,106,239,.3); }
.mw.assistant .msg { background: var(--s2); padding: 13px 16px; border-radius: 14px 14px 14px 4px; border: 1px solid var(--border); white-space: pre-wrap; }

/* ─── Message timestamp ─── */
.msg-time {
  font-size: 10px; color: var(--muted); opacity: .7;
  margin-top: 4px; text-align: right; user-select: none;
  transition: opacity .15s;
}
.mw:hover .msg-time { opacity: 1; }
.mw.user .msg-time { text-align: right; }
.mw.assistant .msg-time { text-align: left; }

/* ─── Assistant message avatar marker ─── */
.mw.assistant { padding-left: 34px; }
.mw.assistant::before {
  content: 'AI';
  position: absolute; left: 0; top: 2px;
  width: 26px; height: 26px; border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), #a855f7);
  display: flex; align-items: center; justify-content: center;
  font-size: 9px; font-weight: 800; color: white; letter-spacing: .3px;
  box-shadow: 0 2px 8px rgba(124,106,239,.35);
  flex-shrink: 0;
}

/* User message right-align avatar */
.mw.user { padding-right: 34px; }
.mw.user::after {
  content: 'You';
  position: absolute; right: 0; top: 2px;
  width: 26px; height: 26px; border-radius: 50%;
  background: var(--user-msg);
  border: 1px solid rgba(124,106,239,.4);
  display: flex; align-items: center; justify-content: center;
  font-size: 8px; font-weight: 700; color: var(--accent2); letter-spacing: .3px;
}

/* ─── Markdown styles inside .msg ─── */
.msg strong { font-weight: 700; color: var(--text); }
.msg em { font-style: italic; color: #c9d1d9; }
.msg del { color: var(--muted); text-decoration: line-through; }
.msg h1, .msg h2, .msg h3, .msg h4, .msg h5, .msg h6 { font-weight: 700; margin: 12px 0 6px; color: var(--text); }
.msg h1 { font-size: 1.35em; border-bottom: 1px solid var(--border); padding-bottom: 5px; }
.msg h2 { font-size: 1.16em; }
.msg h3 { font-size: 1.03em; }
.msg h4 { font-size: 0.94em; }
.msg h5 { font-size: 0.9em; color: var(--muted); }
.msg h6 { font-size: 0.84em; color: var(--muted); text-transform: uppercase; letter-spacing: .06em; }
.msg p { margin: 6px 0; }
.msg ul, .msg ol { margin: 6px 0 6px 20px; }
.msg li { margin: 3px 0; }
.msg li > ul, .msg li > ol { margin-top: 3px; margin-bottom: 1px; }
.msg code { background: rgba(110,118,129,.18); padding: 2px 6px; border-radius: 5px; font-family: 'SF Mono', Consolas, 'Courier New', monospace; font-size: 0.87em; color: #e6a77b; }
.msg pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 9px; margin: 10px 0; overflow: hidden; }
.msg pre .pre-header { display: flex; align-items: center; justify-content: space-between; padding: 6px 12px; background: var(--s3); border-bottom: 1px solid var(--border); font-size: 12px; color: var(--muted); }
.msg pre .pre-header .lang { font-family: 'SF Mono', monospace; color: var(--accent2); font-weight: 700; font-size: 12px; }
.msg pre code { background: none; padding: 12px 14px; border-radius: 0; font-size: 0.87em; color: var(--text); display: block; overflow-x: auto; line-height: 1.65; }
.msg a { color: var(--accent2); text-decoration: none; }
.msg a:hover { text-decoration: underline; }
.msg blockquote { display: flex; align-items: flex-start; gap: 8px; border-left: 3px solid #3a4560; padding: 7px 12px; margin: 6px 0 10px; background: rgba(20,27,42,.75); border-radius: 0 8px 8px 0; color: #8a9bba; font-size: 0.94em; font-style: italic; line-height: 1.5; }
.msg blockquote > svg { flex-shrink: 0; margin-top: 3px; opacity: .4; color: #8a9bba; }
.msg hr { border: none; border-top: 1px solid var(--border); margin: 12px 0; }
.msg .table-wrap { overflow-x: auto; margin: 12px 0; border-radius: 9px; border: 1px solid var(--border); }
.msg table { border-collapse: collapse; width: 100%; font-size: 0.9em; }
.msg th, .msg td { border: none; border-bottom: 1px solid var(--border); padding: 8px 14px; text-align: left; line-height: 1.5; }
.msg th { background: var(--s3); font-weight: 700; color: var(--accent2); border-bottom: 2px solid var(--border); white-space: nowrap; }
.msg tbody tr:nth-child(even) { background: rgba(255,255,255,.03); }
.msg tbody tr:hover { background: rgba(124,106,239,.08); }
.msg td { color: var(--text); }
.msg td:first-child, .msg th:first-child { padding-left: 16px; }
.msg td:last-child, .msg th:last-child { padding-right: 16px; }
.msg > :first-child { margin-top: 0; }
.msg > :last-child { margin-bottom: 0; }

/* ─── Copy button ─── */
.cpb { position: absolute; top: 5px; right: 5px; opacity: 0; background: var(--s3); border: 1px solid var(--border); color: var(--muted); padding: 3px 8px; border-radius: 5px; cursor: pointer; font-size: 11px; transition: opacity .15s; }
.cpb:hover { color: var(--text); opacity: 1 !important; }
.cpb.ok { color: var(--green); }
.cpmd { position: absolute; top: 5px; right: 38px; opacity: 0; background: var(--s3); border: 1px solid var(--border); color: var(--muted); padding: 3px 8px; border-radius: 5px; cursor: pointer; font-size: 11px; font-weight: 600; transition: opacity .15s; }
.cpmd:hover { color: var(--text); opacity: 1 !important; border-color: var(--accent2); }
.cpmd.ok { color: var(--green); }
.copy-code-btn { background: var(--s2); border: 1px solid var(--border); color: var(--muted); padding: 2px 9px; border-radius: 5px; cursor: pointer; font-size: 11px; font-family: inherit; transition: all .12s; }
.copy-code-btn:hover { color: var(--text); border-color: var(--accent2); }
.copy-code-btn.ok { color: var(--green); }

/* ─── Agent badge (multi-agent) ─── */
.ab { background: var(--accent); color: white; padding: 2px 8px; border-radius: 5px; font-size: 10px; font-weight: 700; flex-shrink: 0; }

/* ─── Agent status line (in-scroll legacy) ─── */
.agent-status { align-self: flex-start; display: flex; align-items: center; gap: 9px; padding: 5px 0 5px 2px; font-size: 12px; color: var(--muted); }
.agent-status .asdot { width: 7px; height: 7px; border-radius: 50%; background: var(--accent); flex-shrink: 0; animation: pulse-dot 1.4s ease-in-out infinite; }
.agent-status .astxt { opacity: .75; }
@keyframes pulse-dot { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: .25; transform: scale(.65); } }

/* ─── Agent team card ─── */
.agent-team-card {
  align-self: flex-start;
  background: var(--s2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 0;
  max-width: 380px;
  overflow: hidden;
  animation: status-appear .25s var(--ease-out);
  margin: 4px 0;
}
.atc-header {
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px 8px;
  border-bottom: 1px solid rgba(124,106,239,.1);
}
.atc-header .atc-icon {
  width: 28px; height: 28px; border-radius: 8px;
  background: linear-gradient(135deg, var(--accent) 0%, var(--accent2) 100%);
  display: flex; align-items: center; justify-content: center;
  font-size: 14px; flex-shrink: 0;
}
.atc-header .atc-title {
  font-size: 12px; font-weight: 700; color: var(--text); letter-spacing: .02em;
}
.atc-header .atc-plan {
  font-size: 10.5px; color: var(--muted); margin-top: 1px;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 280px;
}
.atc-agents {
  padding: 6px 10px 10px;
  display: flex; flex-direction: column; gap: 4px;
}
.atc-row {
  display: flex; align-items: center; gap: 8px;
  padding: 5px 8px;
  border-radius: 8px;
  background: rgba(255,255,255,.02);
  transition: background .15s;
}
.atc-row:hover { background: rgba(255,255,255,.04); }
.atc-row .atc-dot {
  width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
  background: var(--muted); opacity: .4;
  transition: all .25s var(--ease-out);
}
.atc-row.atc-working .atc-dot {
  background: var(--accent); opacity: 1;
  animation: pulse-dot 1.4s ease-in-out infinite;
  box-shadow: 0 0 6px rgba(124,106,239,.4);
}
.atc-row.atc-done .atc-dot {
  background: var(--green); opacity: 1;
  box-shadow: 0 0 6px rgba(63,185,80,.3);
}
.atc-row.atc-error .atc-dot {
  background: var(--red); opacity: 1;
  box-shadow: 0 0 6px rgba(248,81,73,.3);
}
.atc-row .atc-id {
  font-size: 10px; font-weight: 700; color: var(--accent2);
  min-width: 56px; flex-shrink: 0;
}
.atc-row .atc-role {
  font-size: 11px; color: var(--text); opacity: .8;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.atc-row .atc-task {
  font-size: 10px; color: var(--muted);
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  max-width: 200px;
  display: none;
}
.atc-row:hover .atc-task { display: inline; }
.atc-row:hover .atc-role { display: none; }
.atc-footer {
  padding: 4px 14px 8px;
  border-top: 1px solid rgba(124,106,239,.06);
  display: flex; align-items: center; gap: 6px;
}
.atc-footer .atc-count {
  font-size: 10px; color: var(--muted); opacity: .7;
}
.atc-footer .atc-progress {
  flex: 1; height: 3px; border-radius: 2px;
  background: rgba(255,255,255,.05);
  overflow: hidden;
}
.atc-footer .atc-progress-bar {
  height: 100%; border-radius: 2px;
  background: linear-gradient(90deg, var(--accent), var(--green));
  transition: width .4s var(--ease-out);
  width: 0%;
}
.atc-dispatch-btn {
  background: rgba(124,106,239,.12); color: var(--accent);
  border: 1px solid rgba(124,106,239,.22); border-radius: 6px;
  padding: 2px 10px; font-size: 10.5px; cursor: pointer;
  font-weight: 600; transition: all .15s; margin-left: auto; white-space: nowrap;
}
.atc-dispatch-btn:hover { background: rgba(124,106,239,.25); border-color: rgba(124,106,239,.4); }
.atc-dispatch-btn:disabled { opacity: .5; cursor: default; }

/* ─── Chain progress card (dispatched tasks) ─── */
.chain-progress-card {
  align-self: flex-start; background: var(--s2);
  border: 1px solid rgba(63,185,80,.15); border-radius: 12px;
  padding: 10px 14px; max-width: 400px; margin: 4px 0;
  animation: status-appear .25s var(--ease-out);
}
.chain-progress-card .cpc-title { font-size: 12px; font-weight: 700; color: var(--green); margin-bottom: 6px; }
.chain-progress-card .cpc-tasks { display: flex; flex-direction: column; gap: 3px; }
.chain-progress-card .cpc-task { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text); opacity: .8; }
.chain-progress-card .cpc-task .cpc-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--muted); opacity: .4; flex-shrink: 0; }
.chain-progress-card .cpc-task.cpc-done .cpc-dot { background: var(--green); opacity: 1; }
.chain-progress-card .cpc-task.cpc-running .cpc-dot { background: var(--accent); opacity: 1; animation: pulse-dot 1.4s ease-in-out infinite; }
.chain-progress-card .cpc-task.cpc-failed .cpc-dot { background: var(--red); opacity: 1; }
.chain-progress-card .cpc-task.cpc-retry .cpc-dot { background: var(--warn, #d29922); opacity: 1; }
.chain-progress-card .cpc-bar { margin-top: 6px; height: 3px; border-radius: 2px; background: rgba(255,255,255,.05); overflow: hidden; }
.chain-progress-card .cpc-bar-fill { height: 100%; border-radius: 2px; background: linear-gradient(90deg, var(--accent), var(--green)); transition: width .4s var(--ease-out); width: 0%; }

/* ─── Message status footer ─── */
.msg-status-footer {
  display: flex; align-items: center; gap: 7px;
  padding: 6px 14px 4px;
  border-top: 1px solid transparent;
  margin-top: 2px;
  animation: status-appear .2s var(--ease-out);
  overflow: hidden;
}
@keyframes status-appear {
  from { opacity: 0; transform: translateY(-4px); max-height: 0; padding-top: 0; }
  to   { opacity: 1; transform: translateY(0);    max-height: 36px; }
}

/* ─── Streaming state ─── */
.msg-status-footer.state-streaming {
  border-top-color: rgba(124,106,239,.12);
}
.msg-status-footer.state-streaming .msf-icon {
  position: relative; width: 14px; height: 14px; flex-shrink: 0;
}
.msg-status-footer.state-streaming .msf-icon::before,
.msg-status-footer.state-streaming .msf-icon::after {
  content: ''; position: absolute; border-radius: 50%;
}
.msg-status-footer.state-streaming .msf-icon::before {
  inset: 0;
  border: 2px solid rgba(124,106,239,.18);
  border-top-color: var(--accent);
  animation: msf-spin .7s linear infinite;
}
.msg-status-footer.state-streaming .msf-icon::after {
  inset: 4px;
  background: var(--accent);
  opacity: .45;
  animation: msf-pulse 1.4s ease-in-out infinite;
}
.msg-status-footer.state-streaming .msf-label {
  font-size: 11.5px; font-weight: 600; letter-spacing: .03em;
  color: var(--accent2); opacity: .85;
}
.msg-status-footer.state-streaming .msf-dots span {
  display: inline-block; width: 3px; height: 3px; border-radius: 50%;
  background: var(--accent2); opacity: .5; margin-left: 2px;
  animation: msf-dot-bounce .9s ease-in-out infinite;
}
.msg-status-footer.state-streaming .msf-dots span:nth-child(2) { animation-delay: .15s; }
.msg-status-footer.state-streaming .msf-dots span:nth-child(3) { animation-delay: .3s; }

/* ─── Done state ─── */
.msg-status-footer.state-done {
  border-top-color: rgba(63,185,80,.1);
  animation: status-done-in .35s var(--ease-out);
}
@keyframes status-done-in {
  from { opacity: 0; transform: translateY(-3px) scale(.97); }
  to   { opacity: 1; transform: translateY(0)    scale(1); }
}
.msg-status-footer.state-done .msf-icon {
  width: 20px; height: 20px; border-radius: 50%; flex-shrink: 0;
  background: rgba(63,185,80,.18);
  border: 1.5px solid rgba(63,185,80,.45);
  display: flex; align-items: center; justify-content: center;
  animation: msf-check-pop .3s var(--ease-out);
  box-shadow: 0 0 8px rgba(63,185,80,.2);
}
@keyframes msf-check-pop {
  0%   { transform: scale(0); opacity: 0; }
  60%  { transform: scale(1.2); }
  100% { transform: scale(1); opacity: 1; }
}
.msg-status-footer.state-done .msf-icon::after {
  content: '';
  display: block; width: 6px; height: 4px;
  border-left: 2px solid var(--green); border-bottom: 2px solid var(--green);
  transform: rotate(-45deg) translate(1px, -1px);
}
.msg-status-footer.state-done .msf-label {
  font-size: 12px; font-weight: 600; letter-spacing: .02em;
  color: var(--green); opacity: .85;
}

/* ─── Error state ─── */
.msg-status-footer.state-error {
  border-top-color: rgba(248,81,73,.1);
}
.msg-status-footer.state-error .msf-icon {
  width: 16px; height: 16px; border-radius: 50%; flex-shrink: 0;
  background: rgba(248,81,73,.12); border: 1.5px solid rgba(248,81,73,.35);
  display: flex; align-items: center; justify-content: center;
}
.msg-status-footer.state-error .msf-icon::after {
  content: '!'; font-size: 9px; font-weight: 800; color: var(--red); line-height: 1;
}
.msg-status-footer.state-error .msf-label {
  font-size: 11px; font-weight: 500; color: var(--red); opacity: .75;
}

/* ─── Waiting state ─── */
.msg-status-footer.state-waiting {
  border-top-color: rgba(229,164,53,.08);
}
.msg-status-footer.state-waiting .msf-icon {
  width: 14px; height: 14px; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center; gap: 2px;
}
.msg-status-footer.state-waiting .msf-icon span {
  display: block; width: 3px; border-radius: 2px; background: var(--orange);
  animation: msf-bar-bounce .8s ease-in-out infinite;
}
.msg-status-footer.state-waiting .msf-icon span:nth-child(1) { height: 5px; animation-delay: 0s; }
.msg-status-footer.state-waiting .msf-icon span:nth-child(2) { height: 9px; animation-delay: .12s; }
.msg-status-footer.state-waiting .msf-icon span:nth-child(3) { height: 5px; animation-delay: .24s; }
.msg-status-footer.state-waiting .msf-label {
  font-size: 11px; font-weight: 500; color: var(--orange); opacity: .75;
}

/* ─── Keyframe library ─── */
@keyframes msf-spin        { to { transform: rotate(360deg); } }
@keyframes msf-pulse       { 0%,100% { transform: scale(1); opacity: .45; } 50% { transform: scale(0); opacity: 0; } }
@keyframes msf-dot-bounce  { 0%,80%,100% { transform: translateY(0); opacity: .5; } 40% { transform: translateY(-3px); opacity: 1; } }
@keyframes msf-bar-bounce  { 0%,100% { transform: scaleY(1); opacity: .6; } 50% { transform: scaleY(1.5); opacity: 1; } }

/* ─── Tool Activity Bar ─── */
.tool-activity {
  display: flex; align-items: center; gap: 6px; flex-wrap: wrap;
  padding: 5px 14px 3px; margin-top: 2px;
  border-top: 1px solid rgba(139,148,158,.08);
  animation: status-appear .25s var(--ease-out);
}
.tool-activity .ta-icon {
  font-size: 11px; opacity: .5; flex-shrink: 0;
}
.tool-activity .ta-summary {
  font-size: 11px; font-weight: 600; color: var(--t2); opacity: .55;
  white-space: nowrap;
}
.tool-activity .ta-pills {
  display: flex; flex-wrap: wrap; gap: 4px;
}
.tool-activity .ta-pill {
  font-size: 10px; font-weight: 500; letter-spacing: .02em;
  padding: 1px 6px; border-radius: 3px;
  background: rgba(139,148,158,.08); color: var(--t2); opacity: .6;
  white-space: nowrap;
}

/* ─── Live Tool Activity (during & after generation) ─── */
.tool-live {
  margin: 4px 14px 2px; padding: 0;
  border-radius: 6px; background: rgba(139,148,158,.03);
  border: 1px solid rgba(139,148,158,.07);
  animation: status-appear .2s var(--ease-out);
  overflow: hidden;
}
.tool-live-header {
  display: flex; align-items: center; gap: 6px;
  font-size: 11px; font-weight: 600; color: var(--t2); opacity: .55;
  cursor: pointer; user-select: none;
  padding: 5px 10px;
  transition: background .15s;
}
.tool-live-header:hover { background: rgba(139,148,158,.05); }
.tool-live-header .tl-arrow {
  font-size: 8px; transition: transform .15s; display: inline-block; flex-shrink: 0;
}
.tool-live-header .tl-dot {
  width: 6px; height: 6px; border-radius: 50%; background: var(--accent);
  animation: tl-pulse 1.2s ease-in-out infinite; flex-shrink: 0;
}
@keyframes tl-pulse { 0%,100% { opacity: .3; } 50% { opacity: 1; } }
.tool-live.done .tl-dot { display: none; }
.tool-live.collapsed .tl-arrow { transform: rotate(-90deg); }
.tool-live.collapsed .tool-live-body { display: none; }
.tool-live-body {
  max-height: 220px; overflow-y: auto;
  scrollbar-width: thin; scrollbar-color: rgba(139,148,158,.12) transparent;
  padding: 0 10px 6px;
}
.tool-live-list { display: flex; flex-direction: column; gap: 0; }
.tool-live-item {
  border-bottom: 1px solid rgba(139,148,158,.04);
  padding: 3px 0;
}
.tool-live-item:last-child { border-bottom: none; }
.tl-row {
  display: flex; align-items: baseline; gap: 6px;
  cursor: pointer; padding: 1px 2px; border-radius: 3px;
  transition: background .1s;
}
.tl-row:hover { background: rgba(139,148,158,.05); }
.tl-row .tl-name {
  flex-shrink: 0; font-weight: 600; color: var(--accent); opacity: .6;
  font-size: 10.5px; min-width: 42px;
}
.tl-row .tl-brief {
  color: var(--t2); opacity: .45;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px; flex: 1; min-width: 0;
}
.tl-row .tl-chevron {
  font-size: 8px; opacity: .3; flex-shrink: 0; transition: transform .12s;
}
.tl-detail {
  display: none; margin: 2px 0 2px 48px; padding: 4px 8px;
  background: rgba(0,0,0,.15); border-radius: 4px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 10px; line-height: 1.45; color: var(--t2); opacity: .55;
  white-space: pre-wrap; word-break: break-all; max-height: 200px; overflow-y: auto;
  scrollbar-width: thin; scrollbar-color: rgba(139,148,158,.12) transparent;
}
.tool-live-item.expanded .tl-detail { display: block; }
.tool-live-item.expanded .tl-chevron { transform: rotate(90deg); opacity: .5; }

/* Legacy: keep spin for any old refs that may exist */
@keyframes spin { to { transform: rotate(360deg); } }
/* ─── Streaming cursor ─── */
.stream-cursor { display: inline-block; width: 2px; height: .85em; background: var(--accent); margin-left: 2px; vertical-align: middle; border-radius: 1px; animation: blink .8s step-end infinite; }
@keyframes blink { 0%,100%{ opacity:1 } 50%{ opacity:0 } }

/* ─── User message acknowledgement (green ✓ after response received) ─── */
.msg-ack { font-size: 13px; color: var(--green); text-align: right; padding: 3px 8px 0; line-height: 1; opacity: 0.9; animation: fadeUp .25s ease; }

/* ─── Load history button ─── */
.load-hist-btn {
  align-self: center; background: var(--s2); border: 1px solid var(--border);
  color: var(--muted); font-size: 12px; padding: 6px 18px; border-radius: 20px;
  cursor: pointer; transition: background .15s, color .15s, border-color .15s;
  margin-bottom: 4px; flex-shrink: 0;
}
.load-hist-btn:hover { background: var(--s3); color: var(--text); border-color: var(--accent); }
.load-hist-btn:disabled { opacity: .45; cursor: not-allowed; }

/* ─── Load more messages button ─── */
.load-more-wrap { display: flex; justify-content: center; padding: 8px 0 4px; flex-shrink: 0; }
.load-more-btn { background: var(--s2); border: 1px solid var(--border); color: var(--muted); font-size: 11px; padding: 5px 16px; border-radius: 20px; cursor: pointer; transition: background .15s, color .15s, border-color .15s; }
.load-more-btn:hover { background: var(--s3); color: var(--text); border-color: var(--accent); }

/* ─── Scroll-to-bottom button ─── */
#scrollBtn {
  position: absolute; bottom: 90px; right: 20px;
  width: 36px; height: 36px;
  background: var(--s2); border: 1px solid var(--border);
  border-radius: 50%; cursor: pointer; display: flex;
  align-items: center; justify-content: center;
  box-shadow: var(--shadow); color: var(--muted);
  opacity: 0; pointer-events: none; z-index: 20;
  transition: opacity .2s, background .15s, color .15s;
  font-size: 16px; line-height: 1;
}
#scrollBtn.visible { opacity: 1; pointer-events: all; }
#scrollBtn:hover { background: var(--accent); border-color: var(--accent); color: white; }

/* ─── Attachment chips (files & screenshots) ─── */
.att-chips { display: flex; flex-wrap: wrap; gap: 6px; padding: 6px 14px 2px; min-height: 0; }
.att-chips:empty { display: none; }
.att-chip { display: inline-flex; align-items: center; gap: 5px; background: var(--s3); border: 1px solid var(--border); border-radius: 6px; padding: 3px 8px 3px 6px; font-size: 11px; color: var(--text); max-width: 260px; position: relative; transition: border-color .12s; }
.att-chip:hover { border-color: var(--accent); }
.att-chip .chip-icon { font-size: 13px; flex-shrink: 0; }
.att-chip .chip-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px; }
.att-chip .chip-rm { background: none; border: none; color: var(--muted); cursor: pointer; padding: 0 0 0 2px; font-size: 13px; line-height: 1; flex-shrink: 0; transition: color .1s; }
.att-chip .chip-rm:hover { color: var(--red); }
.att-chip.chip-img { padding: 3px 8px 3px 3px; gap: 6px; }
.att-chip.chip-img img { width: 28px; height: 28px; object-fit: cover; border-radius: 3px; display: block; }

/* ─── @ File picker popup ─── */
.at-popup {
  position: absolute; bottom: 100%; left: 0; right: 0; margin-bottom: 4px;
  background: var(--s2); border: 1px solid var(--border); border-radius: 10px;
  box-shadow: var(--shadow); overflow: hidden; z-index: 200;
  max-height: 260px; display: flex; flex-direction: column;
}
.at-popup-hdr { padding: 7px 12px; font-size: 11px; color: var(--muted); border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
.at-popup-hdr input { flex: 1; background: none; border: none; outline: none; color: var(--text); font-size: 12px; }
.at-popup-list { overflow-y: auto; flex: 1; }
.at-item { display: flex; align-items: center; gap: 8px; padding: 7px 12px; cursor: pointer; font-size: 12px; transition: background .1s; }
.at-item:hover, .at-item.active { background: var(--s3); }
.at-item .at-info { display: flex; flex-direction: column; overflow: hidden; flex: 1; min-width: 0; }
.at-item .at-name { font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.at-item .at-dir { color: var(--muted); font-size: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 1px; }
.at-item .at-icon { font-size: 14px; flex-shrink: 0; }
.at-empty { padding: 12px; text-align: center; color: var(--muted); font-size: 11px; }
.at-loading { padding: 12px; text-align: center; color: var(--muted); font-size: 11px; }

/* ─── Welcome ─── */
.welcome { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; color: var(--muted); text-align: center; gap: 10px; }
.wi { width: 54px; height: 54px; border-radius: 16px; background: linear-gradient(135deg, var(--accent), #a855f7); display: flex; align-items: center; justify-content: center; font-size: 26px; margin-bottom: 4px; box-shadow: 0 4px 20px rgba(124,106,239,.35); }
.welcome h2 { color: var(--text); font-size: 18px; font-weight: 700; }
.welcome p { font-size: 13.5px; max-width: 300px; line-height: 1.65; }
.welcome-prompts { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 100%; max-width: 420px; margin-top: 20px; }
.wp-card { background: var(--s2); border: 1px solid var(--border); border-radius: 10px; padding: 10px 14px; font-size: 13px; color: var(--muted); cursor: pointer; transition: all .15s; text-align: left; line-height: 1.4; }
.wp-card:hover { background: var(--s3); border-color: rgba(124,106,239,.4); color: var(--text); transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,.2); }

/* ─── Collapsible header ─── */
.hdr-collapse-zone { overflow: visible; transition: max-height .3s var(--ease-out), opacity .2s; max-height: 200px; opacity: 1; }
.hdr-collapse-zone.collapsed { overflow: hidden; max-height: 0; opacity: 0; pointer-events: none; }
.hdr-toggle { display: flex; align-items: center; justify-content: center; width: 26px; height: 26px; flex-shrink: 0; background: var(--s2); border: 1px solid var(--border); border-radius: 5px; cursor: pointer; color: var(--muted); transition: all .15s; margin: 3px 4px 3px 6px; }
.hdr-toggle:hover { color: var(--accent2); border-color: var(--accent); background: var(--s3); }
.hdr-toggle svg { width: 11px; height: 11px; transition: transform .25s var(--ease-out); }
.hdr-toggle.collapsed svg { transform: rotate(180deg); }

/* ─── Font size slider ─── */
.font-slider-wrap { display: flex; align-items: center; gap: 5px; margin-left: auto; padding: 0 8px; flex-shrink: 0; }
.font-slider-wrap .fs-icon { font-size: 11px; color: var(--muted); user-select: none; flex-shrink: 0; }
.font-slider-wrap .fs-icon.lg { font-size: 15px; }
.font-slider { -webkit-appearance: none; appearance: none; width: 70px; height: 4px; border-radius: 2px; background: var(--border); outline: none; cursor: pointer; }
.font-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--accent); border: 2px solid var(--s1); box-shadow: 0 1px 4px rgba(0,0,0,.3); cursor: pointer; transition: background .15s; }
.font-slider::-webkit-slider-thumb:hover { background: var(--accent2); }
.font-slider::-moz-range-thumb { width: 14px; height: 14px; border-radius: 50%; background: var(--accent); border: 2px solid var(--s1); box-shadow: 0 1px 4px rgba(0,0,0,.3); cursor: pointer; }
.font-slider::-moz-range-track { height: 4px; border-radius: 2px; background: var(--border); }

/* ─── Collapsible large messages ─── */
.msg-clamp { max-height: 200px; overflow: hidden; position: relative; transition: max-height .35s var(--ease-out); }
.msg-clamp::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 60px; background: linear-gradient(transparent, var(--s2)); pointer-events: none; transition: opacity .2s; }
.mw.user .msg-clamp::after { background: linear-gradient(transparent, var(--user-msg)); }
.msg-clamp.expanded { max-height: none; }
.msg-clamp.expanded::after { opacity: 0; }
.msg-expand-btn { display: block; width: 100%; margin-top: 6px; padding: 4px 0; border: 1px solid var(--border); border-radius: 6px; background: var(--s3); color: var(--muted); font-size: 12px; font-family: inherit; cursor: pointer; transition: all .15s; text-align: center; }
.msg-expand-btn:hover { color: var(--accent2); border-color: var(--accent); background: var(--abg); }

/* ─── Tabs bar ─── */
.tabs-bar { display: flex; align-items: stretch; background: var(--bg); border-bottom: 1px solid var(--border); overflow-x: auto; flex-shrink: 0; min-height: 34px; }
.tabs-bar::-webkit-scrollbar { height: 2px; }
.tabs-bar::-webkit-scrollbar-thumb { background: var(--border); }
.tab { display: flex; align-items: center; gap: 6px; padding: 0 10px 0 12px; min-width: 90px; max-width: 180px; border-right: 1px solid var(--border); cursor: pointer; font-size: 12.5px; color: var(--muted); transition: background .1s, color .1s; flex-shrink: 0; position: relative; }
.tab:hover { background: var(--s2); color: var(--text); }
.tab.active { background: var(--s2); color: var(--text); }
.tab.active::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 2px; background: var(--accent); }
.tab-title { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; }
.tab-close { opacity: 0; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 3px; font-size: 11px; flex-shrink: 0; transition: opacity .12s; background: none; border: none; color: inherit; cursor: pointer; }
.tab:hover .tab-close, .tab.active .tab-close { opacity: .45; }
.tab-close:hover { opacity: 1 !important; background: var(--s3); }
.tab-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
.tab-dot.spinning { border: 1.5px solid rgba(124,106,239,.25); border-top-color: var(--accent); animation: spin .65s linear infinite; }
.tab-dot.done { background: var(--green); }
.proj-busy-dot { display: inline-block; margin-left: 5px; vertical-align: middle; position: relative; top: -1px; }
.tab-new { padding: 0 13px; display: flex; align-items: center; color: var(--muted); cursor: pointer; font-size: 20px; line-height: 1; transition: color .1s; flex-shrink: 0; background: none; border: none; }
.tab-new:hover { color: var(--text); }
.tab-rename-input { background: transparent; border: none; border-bottom: 1.5px solid var(--accent); color: var(--text); font-size: 12.5px; font-family: inherit; padding: 0 2px; outline: none; width: 100%; min-width: 40px; }

/* ─── Session info bar ─── */
.sess-bar { display:flex; align-items:center; gap:6px; padding:3px 14px; font-size:11px; color:var(--text-dim); border-bottom:1px solid var(--border); user-select:none; min-height:24px; flex-shrink:0; }
.sess-project { font-weight:600; color:var(--accent2); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:300px; }
.sess-skill-chip { font-size:10px; color:var(--accent2); background:rgba(124,106,239,.12); border:1px solid rgba(124,106,239,.25); padding:1px 7px; border-radius:4px; white-space:nowrap; max-width:120px; overflow:hidden; text-overflow:ellipsis; }
.sess-skill-auto { color:var(--orange); background:rgba(229,164,53,.12); border-color:rgba(229,164,53,.3); }

/* ─── Retry indicators ─── */
.retry-badge { font-size:11px; color:var(--text-dim); opacity:.65; margin-top:3px; letter-spacing:.01em; }
.msg-retry-indicator { margin:2px 12px 6px; font-size:11px; color:var(--text-dim); opacity:.6; }
.msg-interrupted { margin:4px 12px 6px; font-size:11px; color:var(--yellow,#e5c07b); opacity:.8; }
.msg-done-badge { margin:6px 14px 2px; padding:5px 10px; font-size:11.5px; color:var(--green,#98c379); opacity:.75; border-top:1px solid rgba(139,148,158,.06); }

/* ─── Message timestamps ─── */
.msg-time { display:flex; align-items:center; gap:6px; margin:3px 2px 0; font-size:10.5px; color:var(--muted); opacity:.55; line-height:1; user-select:none; transition:opacity .15s; }
.mw:hover .msg-time { opacity:.85; }
.mw.user .msg-time { justify-content:flex-end; }
.mw.assistant .msg-time { justify-content:flex-start; }
.msg-time .mt-duration { color:var(--green,#98c379); font-weight:500; }

/* ─── Ask User Card ─── */
.ask-user-card {
  margin: 10px 12px; padding: 16px 18px; background: var(--s2); border: 1px solid var(--accent);
  border-radius: var(--r-md); animation: askSlideIn .3s var(--ease-out);
  box-shadow: 0 0 0 2px rgba(124,106,239,.12), var(--shadow-sm);
}
@keyframes askSlideIn { from { opacity:0; transform:translateY(8px); } to { opacity:1; transform:translateY(0); } }
.ask-user-card .ask-q { font-size: 14.5px; line-height: 1.5; margin-bottom: 12px; color: var(--text); }
.ask-user-card .ask-q p { margin: 0 0 6px; }
.ask-user-card .ask-q p:last-child { margin-bottom: 0; }
.ask-user-card .ask-q strong { font-weight: 700; color: var(--text); }
.ask-user-card .ask-q em { font-style: italic; color: #c9d1d9; }
.ask-user-card .ask-q h1, .ask-user-card .ask-q h2, .ask-user-card .ask-q h3,
.ask-user-card .ask-q h4, .ask-user-card .ask-q h5, .ask-user-card .ask-q h6 { font-weight: 700; margin: 10px 0 5px; color: var(--text); }
.ask-user-card .ask-q h1 { font-size: 19px; } .ask-user-card .ask-q h2 { font-size: 17px; } .ask-user-card .ask-q h3 { font-size: 15px; }
.ask-user-card .ask-q ul, .ask-user-card .ask-q ol { margin: 6px 0 6px 20px; }
.ask-user-card .ask-q li { margin: 3px 0; }
.ask-user-card .ask-q li > ul, .ask-user-card .ask-q li > ol { margin-top: 3px; margin-bottom: 1px; }
.ask-user-card .ask-q code { background: rgba(110,118,129,.18); padding: 2px 6px; border-radius: 5px; font-family: 'SF Mono', Consolas, 'Courier New', monospace; font-size: 13px; color: #e6a77b; }
.ask-user-card .ask-q pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 9px; margin: 8px 0; overflow: hidden; }
.ask-user-card .ask-q pre code { background: none; padding: 10px 14px; border-radius: 0; font-size: 13px; color: var(--text); display: block; overflow-x: auto; line-height: 1.6; }
.ask-user-card .ask-q a { color: var(--accent2); text-decoration: none; }
.ask-user-card .ask-q a:hover { text-decoration: underline; }
.ask-user-card .ask-q blockquote { border-left: 3px solid #3a4560; padding: 6px 12px; margin: 6px 0; background: rgba(20,27,42,.75); border-radius: 0 8px 8px 0; color: #8a9bba; font-style: italic; }
.ask-user-card .ask-options { display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px; }
.ask-user-card .ask-opt {
  display: flex; align-items: center; gap: 8px; padding: 8px 12px;
  background: var(--s3); border: 1px solid var(--border); border-radius: var(--r-sm);
  cursor: pointer; transition: border-color .15s, background .15s; font-size: 14px; color: var(--text);
}
.ask-user-card .ask-opt:hover { border-color: var(--accent); background: rgba(124,106,239,.08); }
.ask-user-card .ask-opt input[type="radio"],
.ask-user-card .ask-opt input[type="checkbox"] { accent-color: var(--accent); width: 16px; height: 16px; flex-shrink: 0; }
.ask-user-card .ask-opt.selected { border-color: var(--accent); background: rgba(124,106,239,.12); }
.ask-user-card .ask-text {
  width: 100%; padding: 10px 12px; background: var(--s3); border: 1px solid var(--border);
  border-radius: var(--r-sm); color: var(--text); font-size: 14px; font-family: inherit;
  resize: vertical; min-height: 56px; margin-bottom: 12px; outline: none;
  transition: border-color .15s;
}
.ask-user-card .ask-text:focus { border-color: var(--accent); }
.ask-user-card .ask-btns { display: flex; gap: 8px; align-items: center; }
.ask-user-card .ask-submit {
  padding: 7px 18px; background: var(--accent); color: #fff; border: none;
  border-radius: var(--r-sm); font-size: 13.5px; font-weight: 600; cursor: pointer;
  transition: opacity .15s;
}
.ask-user-card .ask-submit:hover { opacity: .88; }
.ask-user-card .ask-submit:disabled { opacity: .4; cursor: default; }
.ask-user-card .ask-skip {
  padding: 7px 14px; background: transparent; color: var(--muted); border: 1px solid var(--border);
  border-radius: var(--r-sm); font-size: 13px; cursor: pointer; transition: color .15s, border-color .15s;
}
.ask-user-card .ask-skip:hover { color: var(--text); border-color: var(--muted); }
.ask-user-card .ask-timer { font-size: 11px; color: var(--muted); margin-left: auto; }
.ask-user-card.ask-answered {
  border-color: var(--green); opacity: .7; pointer-events: none;
}
.ask-user-card.ask-answered .ask-btns { display: none; }
.ask-user-card.ask-answered .ask-timer { display: none; }
.ask-user-card .ask-answer-display {
  display: none; margin-top: 10px; padding: 8px 12px; background: rgba(63,185,80,.08);
  border: 1px solid rgba(63,185,80,.25); border-radius: var(--r-sm); font-size: 13px; color: var(--green);
}
.ask-user-card.ask-answered .ask-answer-display { display: block; }
/* "Other" free-text row on choice questions */
.ask-user-card .ask-other-row {
  display: flex; gap: 8px; align-items: center; margin-top: 6px;
  padding: 8px 12px; background: var(--s3); border: 1px solid var(--border);
  border-radius: var(--r-sm); cursor: pointer; transition: border-color .15s, background .15s;
}
.ask-user-card .ask-other-row:hover { border-color: var(--accent); background: rgba(124,106,239,.08); }
.ask-user-card .ask-other-row.selected { border-color: var(--accent); background: rgba(124,106,239,.12); }
.ask-user-card .ask-other-radio { accent-color: var(--accent); width: 16px; height: 16px; flex-shrink: 0; }
.ask-user-card .ask-other-input {
  flex: 1; padding: 4px 8px; background: transparent; border: 1px solid var(--border);
  border-radius: var(--r-sm); color: var(--text); font-size: 13px; outline: none;
  transition: border-color .15s;
}
.ask-user-card .ask-other-input:focus { border-color: var(--accent); }
.ask-user-card .ask-other-input::placeholder { color: var(--muted); }
/* Rich option with description */
.ask-user-card .ask-opt-content { display: flex; flex-direction: column; gap: 1px; }
.ask-user-card .ask-opt-desc { font-size: 12px; color: var(--muted); line-height: 1.3; }
/* Header badge */
.ask-user-card .ask-header {
  display: inline-block; font-size: 11px; font-weight: 600; color: var(--accent);
  padding: 2px 8px; background: rgba(124,106,239,.1); border-radius: 10px;
  margin-bottom: 6px; text-transform: uppercase; letter-spacing: .5px;
}
/* Pagination controls */
.ask-user-card .ask-pagination {
  display: flex; align-items: center; gap: 8px; margin-bottom: 12px;
}
.ask-user-card .ask-page-btn {
  padding: 4px 10px; background: var(--s3); border: 1px solid var(--border);
  border-radius: var(--r-sm); color: var(--text); font-size: 12px; cursor: pointer;
  transition: border-color .15s;
}
.ask-user-card .ask-page-btn:hover { border-color: var(--accent); }
.ask-user-card .ask-page-btn:disabled { opacity: .3; cursor: default; pointer-events: none; }
.ask-user-card .ask-page-indicator { font-size: 12px; color: var(--muted); }
.ask-user-card .ask-page { display: none; }
.ask-user-card .ask-page.active { display: block; }

/* ─── Notifications (non-blocking, top-right stacked) ─── */
#notifContainer {
  position: fixed; top: 16px; right: 16px; z-index: 250;
  display: flex; flex-direction: column; gap: 8px;
  max-height: calc(100vh - 32px); overflow: hidden;
  pointer-events: none; width: 340px;
}
.notif-card {
  pointer-events: auto;
  padding: 12px 14px; background: var(--s2); border-radius: var(--r-sm);
  border-left: 3px solid var(--blue); box-shadow: var(--shadow-md);
  animation: notifSlideIn .3s ease-out;
  transition: opacity .3s, transform .3s;
  position: relative; cursor: default;
}
.notif-card.notif-out { opacity: 0; transform: translateX(100%); pointer-events: none; }
@keyframes notifSlideIn {
  from { opacity: 0; transform: translateX(60px); }
  to   { opacity: 1; transform: translateX(0); }
}
.notif-card.notif-info     { border-left-color: var(--blue); }
.notif-card.notif-warning  { border-left-color: var(--orange); }
.notif-card.notif-error    { border-left-color: var(--red); }
.notif-card.notif-milestone{ border-left-color: var(--green); }
.notif-card.notif-progress { border-left-color: #a78bfa; }
.notif-header { display: flex; align-items: center; gap: 4px; }
.notif-icon { font-size: 14px; margin-right: 6px; flex-shrink: 0; }
.notif-title { font-size: 13px; font-weight: 600; color: var(--text); flex: 1; line-height: 1.35; }
.notif-close {
  background: none; border: none; color: var(--muted); cursor: pointer;
  font-size: 15px; padding: 0 2px; line-height: 1; opacity: 0;
  transition: opacity .15s, color .15s; flex-shrink: 0;
}
.notif-card:hover .notif-close { opacity: 1; }
.notif-close:hover { color: var(--text); }
.notif-detail { font-size: 12px; color: var(--muted); margin-top: 4px; line-height: 1.4; }
.notif-progress-bar { margin-top: 8px; height: 4px; background: var(--s3); border-radius: 2px; overflow: hidden; }
.notif-progress-fill { height: 100%; background: #a78bfa; border-radius: 2px; transition: width .4s ease-out; }
.notif-progress-text { font-size: 11px; color: var(--muted); margin-top: 3px; text-align: right; }

/* ─── Input area ─── */
.ia { padding: 12px 16px; background: var(--s1); border-top: 1px solid var(--border); }
.iw { display: flex; align-items: flex-end; gap: 8px; background: var(--s2); border: 1px solid var(--border); border-radius: 12px; padding: 5px 5px 5px 14px; transition: border-color .15s, box-shadow .15s; }
.iw:focus-within { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124,106,239,.15); }
.iw textarea { flex: 1; background: none; border: none; color: var(--text); font-size: 14.5px; font-family: inherit; resize: none; outline: none; max-height: 130px; padding: 7px 0; line-height: 1.55; }
.iw textarea::placeholder { color: var(--muted); }
.sb { width: 36px; height: 36px; border: none; background: var(--accent); color: white; border-radius: 9px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: background .12s, box-shadow .12s; box-shadow: 0 2px 8px rgba(124,106,239,.4); }
.sb:hover { background: var(--accent2); box-shadow: 0 3px 12px rgba(124,106,239,.5); }
.sb:disabled { opacity: .35; cursor: not-allowed; box-shadow: none; }
.stop-btn { background: var(--red); box-shadow: 0 2px 8px rgba(248,81,73,.4); }
.stop-btn:hover { background: #ff6b6b !important; box-shadow: 0 3px 12px rgba(248,81,73,.5) !important; }
.sb svg { width: 15px; height: 15px; }
.msg-queued { display: inline-flex; align-items: center; gap: 5px; font-size: 11px; color: var(--muted); margin-top: 5px; padding: 3px 6px 3px 8px; background: var(--s2); border: 1px solid var(--border); border-radius: 10px; }
.msg-queued::before { content: '⏳'; font-size: 11px; }
.mq-label { line-height: 1; }
.qd-btn { background: none; border: none; cursor: pointer; color: var(--muted); font-size: 11px; padding: 1px 3px; line-height: 1; border-radius: 3px; transition: color .12s, background .12s; display: inline-flex; align-items: center; }
.qd-btn:hover { background: var(--s3); }
.qd-edit:hover { color: var(--accent2); }
.qd-del:hover { color: var(--red); }
.queue-editor { display: flex; flex-direction: column; gap: 5px; margin: 4px 0 2px; }
.queue-edit-area { width: 100%; box-sizing: border-box; background: var(--s2); border: 1px solid var(--accent); border-radius: 8px; color: var(--text); font-size: 14px; font-family: inherit; padding: 10px 12px; resize: vertical; outline: none; min-height: 80px; max-height: 60vh; line-height: 1.55; }
.queue-edit-area:focus { box-shadow: 0 0 0 2px rgba(124,106,239,.18); }
.queue-edit-btns { display: flex; gap: 6px; justify-content: flex-end; }
.qe-save { background: var(--accent); color: #fff; border: none; border-radius: 6px; padding: 4px 13px; font-size: 12px; font-family: inherit; cursor: pointer; transition: background .12s; }
.qe-save:hover { background: var(--accent2); }
.qe-cancel { background: var(--s3); color: var(--muted); border: 1px solid var(--border); border-radius: 6px; padding: 4px 13px; font-size: 12px; font-family: inherit; cursor: pointer; transition: color .12s; }
.qe-cancel:hover { color: var(--text); }
.queue-badge { display:none; align-items:center; gap:4px; background:var(--orange); color:#000; font-size:11px; font-weight:700; padding:2px 9px 2px 7px; border-radius:12px; white-space:nowrap; flex-shrink:0; line-height:1.5; }
.queue-badge.visible { display:inline-flex; animation:qbpulse 2s ease-in-out infinite; }
.queue-badge::before { content:'⏳'; font-size:10px; }
@keyframes qbpulse { 0%,100%{opacity:1} 50%{opacity:.72} }

/* ─── File browser ─── */
.fh { padding: 10px 14px; border-bottom: 1px solid var(--border); font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: .7px; color: var(--muted); display: flex; justify-content: space-between; align-items: center; }
.fh button { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 15px; transition: color .12s; }
.fh button:hover { color: var(--text); }
.ft { flex: 1; overflow-y: auto; padding: 5px 7px; }
.fii { display: flex; align-items: center; gap: 7px; padding: 5px 7px; border-radius: 6px; cursor: pointer; font-size: 13px; color: var(--muted); transition: all .1s; }
.fii:hover { background: var(--s2); color: var(--text); }
.fii .fi { width: 17px; text-align: center; font-size: 14px; flex-shrink: 0; }
.fii .fn { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.fii .fs { font-size: 10.5px; color: var(--muted); }
/* ─── File Preview Modal ─── */
.fpv-modal { width: calc(100vw - 40px) !important; max-width: calc(100vw - 40px) !important; height: calc(100vh - 40px); max-height: calc(100vh - 40px) !important; border-radius: 12px; }
.fpv-toolbar { display: flex; align-items: center; gap: 8px; padding: 8px 16px; border-bottom: 1px solid var(--border); background: var(--s2); flex-shrink: 0; }
.fpv-toolbar .fpv-ext { font-size: 10px; color: var(--muted); background: var(--s3); border: 1px solid var(--border); border-radius: 3px; padding: 1px 6px; margin-right: auto; }
.fpv-body { flex: 1; overflow: auto; display: flex; flex-direction: column; min-height: 0; }
.fpv-body img { max-width: 100%; max-height: calc(100vh - 155px); object-fit: contain; margin: auto; display: block; padding: 16px; }
.fpv-body iframe { width: 100%; flex: 1; border: none; min-height: calc(100vh - 155px); flex: 1; }
.fpv-body .fpv-text { padding: 16px; font-family: 'SF Mono', monospace; font-size: 13.5px; line-height: 1.7; color: var(--text); white-space: pre-wrap; word-break: break-word; }
.fpv-body .fpv-md { padding: 16px 20px; line-height: 1.7; }
.fpv-body .fpv-binary { padding: 32px; display: flex; flex-direction: column; align-items: center; gap: 12px; color: var(--muted); font-size: 14px; }
.fpv-btn { background: var(--s2); border: 1px solid var(--border); color: var(--muted); padding: 5px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 5px; transition: all .15s; flex-shrink: 0; }
.fpv-btn:hover { color: var(--text); border-color: var(--accent2); }

/* ─── Modal ─── */
.modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.7); display: flex; align-items: center; justify-content: center; z-index: 100; animation: fadeUp .15s; backdrop-filter: blur(14px) saturate(150%); }
.modal { background: var(--s1); border: 1px solid var(--border); border-radius: var(--r-lg); width: 740px; max-width: 92vw; max-height: 86vh; display: flex; flex-direction: column; overflow: hidden; box-shadow: var(--shadow-xl); }
.modal-hdr { display: flex; align-items: center; justify-content: space-between; padding: 14px 18px; border-bottom: 1px solid var(--border); }
.modal-hdr h2 { font-size: 15px; font-weight: 700; }
.modal-close { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 20px; padding: 4px; transition: color .12s; line-height: 1; }
.modal-close:hover { color: var(--text); }
.modal-tabs { display: flex; border-bottom: 1px solid var(--border); padding: 0 14px; }
.modal-tab { padding: 9px 16px; font-size: 13px; cursor: pointer; color: var(--muted); border-bottom: 2px solid transparent; transition: all .15s; font-weight: 500; }
.modal-tab:hover { color: var(--text); }
.modal-tab.active { color: var(--accent2); border-bottom-color: var(--accent); }
.modal-body { flex: 1; overflow: auto; padding: 16px; }
.modal-body textarea { width: 100%; min-height: 340px; background: var(--bg); border: 1px solid var(--border); color: var(--text); padding: 14px; border-radius: 9px; font-family: 'SF Mono', Consolas, monospace; font-size: 13px; line-height: 1.6; resize: vertical; outline: none; transition: border .15s; }
.modal-body textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124,106,239,.12); }
.modal-footer { padding: 12px 18px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; gap: 8px; }
.modal-footer button { padding: 7px 18px; border-radius: 7px; border: none; cursor: pointer; font-size: 13px; font-weight: 600; }
.save-notice { color: var(--green); font-size: 12px; }
.cfg-path { font-size: 11px; color: var(--muted); padding: 0 2px 10px; font-family: 'SF Mono', Consolas, monospace; letter-spacing: .2px; display: flex; align-items: center; gap: 6px; }

/* ─── MCP Settings: env key-value editor ─── */
.mcp-cfg-label { font-size:12px;color:var(--muted);font-weight:600;text-transform:uppercase;letter-spacing:.4px;display:flex;align-items:center;justify-content:space-between;margin-bottom:8px }
.mcp-cfg-input { background:var(--s2);border:1px solid var(--border);color:var(--text);padding:9px 12px;border-radius:7px;font-size:13px;outline:none;width:100%;font-family:'SF Mono',Consolas,monospace;transition:border .15s }
.mcp-cfg-input:focus { border-color:var(--accent);box-shadow:0 0 0 3px rgba(124,106,239,.1) }
.mcp-cfg-input::placeholder { color:var(--muted);opacity:.6 }
.env-kv-row { display:flex;gap:8px;align-items:center }
.env-kv-key { flex:0 0 40%;min-width:0 }
.env-kv-val { flex:1;min-width:0 }
.env-kv-del { background:none;border:1px solid var(--border);color:var(--muted);width:32px;height:34px;border-radius:7px;cursor:pointer;font-size:14px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .15s }
.env-kv-del:hover { color:var(--red, #f87171);border-color:var(--red, #f87171);background:rgba(248,113,113,.08) }
.env-add-btn { background:none;border:1px dashed var(--border);color:var(--muted);padding:8px 14px;border-radius:7px;cursor:pointer;font-size:12px;font-weight:600;width:100%;transition:all .15s;margin-top:4px }
.env-add-btn:hover { border-color:var(--accent);color:var(--accent) }

/* ─── Toast notifications ─── */
#toast { position: fixed; bottom: 22px; left: 50%; transform: translateX(-50%); background: var(--s3); border: 1px solid var(--border); color: var(--text); padding: 9px 18px; border-radius: 10px; font-size: 13px; z-index: 200; pointer-events: none; opacity: 0; transition: opacity .25s; box-shadow: var(--shadow); white-space: nowrap; }
#toast.show { opacity: 1; }
#toast.toast-err { border-color: var(--red); color: var(--red); }

/* ─── Tooltips (floating JS div) ─── */
#globalTip {
  position: fixed; z-index: 9999; pointer-events: none;
  padding: 6px 11px; background: #1a2235; border: 1px solid rgba(255,255,255,.13);
  border-radius: 8px; font-size: 12px; line-height: 1.5; max-width: 280px;
  white-space: normal; color: var(--text);
  box-shadow: 0 4px 20px rgba(0,0,0,.55), 0 1px 4px rgba(0,0,0,.3);
  opacity: 0; transition: opacity .12s ease; word-break: break-word;
}

/* ─── Scrollbars ─── */
* { scrollbar-width: thin; scrollbar-color: var(--border) transparent; }
::-webkit-scrollbar { width: 5px; height: 5px; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #4a5568; }
::-webkit-scrollbar-track { background: transparent; }

/* ─── Tactile button feedback ─── */
.hb:active { transform: scale(0.95); transition-duration: 0.07s; }
.tb-btn:active { transform: scale(0.93); transition-duration: 0.07s; }
.add-btn:active { transform: scale(0.97); transition-duration: 0.07s; }
.ci:active { transform: scale(0.98); transition-duration: 0.07s; }

/* ─── Sidebar item left-border accent on hover ─── */
.ci { transition: background .12s, box-shadow .12s, transform .12s; }
.ci:hover { background: var(--s2); box-shadow: inset 2px 0 0 rgba(124,106,239,.3); }
.ci.on { box-shadow: inset 2px 0 0 var(--accent); }
.ci.on:hover { background: rgba(124,106,239,.13); }

/* ─── History hover accent ─── */
.hist-item { transition: background .12s, box-shadow .12s; }
.hist-item:hover { background: var(--s2); box-shadow: inset 2px 0 0 rgba(124,106,239,.3); }

/* ─── Language selector ─── */
.lang-sel { background: var(--s2); border: 1px solid var(--border); color: var(--text); padding: 3px 8px; border-radius: 6px; font-size: 12px; outline: none; cursor: pointer; font-weight: 500; }
.lang-sel:hover, .lang-sel:focus { border-color: var(--accent2); }
.lang-sel option { background: var(--s2); }

/* ─── Directory browser ─── */
.dir-modal { width: 520px; }
.dir-path-bar { padding: 8px 16px; border-bottom: 1px solid var(--border); background: var(--bg); display: flex; align-items: center; gap: 6px; }
.dir-path-bar .path-text { font-size: 12px; color: var(--accent2); font-family: 'SF Mono', monospace; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; word-break: break-all; }
.dir-list { flex: 1; overflow-y: auto; max-height: 340px; padding: 4px 6px; }
.dir-list::-webkit-scrollbar { width: 3px; }
.dir-list::-webkit-scrollbar-thumb { background: var(--border); }
.dii { display: flex; align-items: center; gap: 8px; padding: 7px 10px; border-radius: 7px; cursor: pointer; font-size: 13px; transition: background .1s; color: var(--text); }
.dii:hover { background: var(--s2); }
.dii.selected { background: var(--abg); border: 1px solid rgba(124,106,239,.3); }
.dii .di { font-size: 15px; flex-shrink: 0; }
.dii .dn { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.dii.hidden-dir { opacity: .5; }
.dir-footer { padding: 10px 16px; border-top: 1px solid var(--border); display: flex; align-items: center; gap: 10px; }
.dir-footer label { display: flex; align-items: center; gap: 7px; font-size: 12px; cursor: pointer; color: var(--muted); }
.dir-footer input[type=checkbox] { width: 14px; height: 14px; accent-color: var(--accent); cursor: pointer; }

/* ─── Project name input in dir modal ─── */
.proj-name-row { padding: 8px 16px; border-top: 1px solid var(--border); display: flex; align-items: center; gap: 8px; }
.proj-name-row input { flex: 1; background: var(--s2); border: 1px solid var(--border); color: var(--text); padding: 5px 9px; border-radius: 6px; font-size: 12px; font-family: inherit; outline: none; }

/* ─── Remote SSH Project UI ─── */
.proj-type-toggle { display:flex; gap:6px; padding:10px 16px 0; }
.proj-type-btn { flex:1; padding:7px 0; border:1px solid var(--s2); border-radius:8px; background:var(--bg); color:var(--muted); font-size:12px; cursor:pointer; transition:all .15s; font-family:inherit; }
.proj-type-btn.active { background:var(--accent); color:#fff; border-color:var(--accent); font-weight:600; }
.proj-type-btn:hover:not(.active) { border-color:var(--accent2); color:var(--text); }
.remote-form { padding:12px 16px; display:flex; flex-direction:column; gap:10px; }
.rh-form-row { display:flex; align-items:center; gap:8px; }
.rh-label { font-size:12px; color:var(--muted); white-space:nowrap; min-width:110px; }
.rh-form-row input, .rh-form-row select { flex:1; background:var(--s2); border:1px solid var(--border); color:var(--text); padding:5px 9px; border-radius:6px; font-size:12px; font-family:inherit; outline:none; transition:border .12s; }
.rh-form-row input:focus, .rh-form-row select:focus { border-color:var(--accent); box-shadow:0 0 0 3px rgba(124,106,239,.15); }
.rh-test-result { font-size:12px; min-height:18px; padding:2px 0; }
.rh-test-result.ok { color:#22c55e; }
.rh-test-result.err { color:var(--red); }
.rh-item { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:var(--r); font-size:13px; border:1px solid transparent; transition:background .12s; margin-bottom:2px; }
.rh-item:hover { background:var(--s2); box-shadow:inset 2px 0 0 rgba(124,106,239,.3); }
.rh-dot { width:7px; height:7px; border-radius:50%; background:var(--muted); flex-shrink:0; transition:background .3s; }
.rh-dot.ok { background:#22c55e; }
.rh-dot.err { background:#ef4444; }
.rh-item .inf { flex:1; min-width:0; }
.rh-item .inf .nm { font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:var(--text); }
.rh-item .inf .ds { font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-top:2px; }
.rh-item .rm { opacity:0; background:none; border:none; color:var(--red); cursor:pointer; font-size:14px; padding:3px 6px; border-radius:4px; transition:opacity .12s; flex-shrink:0; }
.rh-item:hover .rm { opacity:.45; }
.rh-item .rm:hover { opacity:1 !important; background:rgba(248,81,73,.1); }
.rh-item .cfg { opacity:0; background:none; border:none; color:var(--muted); cursor:pointer; font-size:13px; padding:3px 6px; border-radius:4px; transition:opacity .12s, color .12s; flex-shrink:0; }
.rh-item:hover .cfg { opacity:.6; }
.rh-item .cfg:hover { opacity:1 !important; color:var(--accent2); background:rgba(124,106,239,.1); }
.ssh-host-modal { width:480px; }
.ssh-host-form { padding:16px; display:flex; flex-direction:column; gap:12px; }
.ssh-host-form label { font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }
.ssh-host-form input { width:100%; background:var(--s2); border:1px solid var(--border); color:var(--text); padding:6px 10px; border-radius:6px; font-size:12px; font-family:inherit; outline:none; box-sizing:border-box; transition:border .12s; }
.ssh-host-form input:focus { border-color:var(--accent); box-shadow:0 0 0 3px rgba(124,106,239,.15); }
.remote-badge { display:inline-flex; align-items:center; gap:3px; font-size:10px; color:var(--accent2); background:rgba(124,106,239,.12); border-radius:4px; padding:1px 5px; margin-left:4px; flex-shrink:0; }

/* ─── Confirm Stop Dialog ─── */
.confirm-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.65); display: flex; align-items: center; justify-content: center; z-index: 300; backdrop-filter: blur(4px); animation: fadeUp .12s ease; }
.confirm-dialog { background: var(--s1); border: 1px solid var(--border); border-radius: 14px; padding: 28px 32px 24px; width: 320px; max-width: 90vw; box-shadow: 0 20px 60px rgba(0,0,0,.65); text-align: center; }
.confirm-dialog .cd-icon { font-size: 28px; margin-bottom: 12px; line-height: 1; }
.confirm-dialog h3 { font-size: 16px; font-weight: 700; margin-bottom: 6px; color: var(--text); }
.confirm-dialog p { font-size: 13px; color: var(--muted); margin-bottom: 22px; line-height: 1.45; }
.confirm-actions { display: flex; gap: 10px; justify-content: center; }
.confirm-actions button { padding: 8px 22px; border-radius: 8px; border: none; cursor: pointer; font-size: 13px; font-weight: 600; transition: background .12s, transform .08s, box-shadow .12s; }
.confirm-actions button:active { transform: scale(.96); }
.cd-btn-stop { background: var(--red); color: #fff; box-shadow: 0 2px 8px rgba(248,81,73,.35); }
.cd-btn-stop:hover { background: #ff6b6b; box-shadow: 0 3px 12px rgba(248,81,73,.5); }
.cd-btn-cancel { background: var(--s3); color: var(--text); border: 1px solid var(--border) !important; }
.cd-btn-cancel:hover { background: var(--border); }
.proj-name-row input:focus { border-color: var(--accent); }

/* ─── HUD Panel ─── */
#hud {
  display: flex; align-items: center; gap: 8px;
  background: var(--s1); border-top: 1px solid var(--border);
  height: 32px; flex-shrink: 0; padding: 0 10px;
  overflow: hidden; transition: height .2s cubic-bezier(.4,0,.2,1);
  font-size: 11px; color: var(--muted); user-select: none;
}
#hud.collapsed { height: 12px; cursor: pointer; }
#hud.collapsed > *:not(.hud-toggle) { opacity: 0; pointer-events: none; }
.hud-toggle { font-size: 8px; opacity: .5; cursor: pointer; flex-shrink: 0; transition: transform .2s, opacity .15s; line-height: 1; padding: 2px 4px; border-radius: 3px; }
.hud-toggle:hover { opacity: 1; background: var(--s3); }
#hud.collapsed .hud-toggle { transform: rotate(-90deg); opacity: .4; }
.hud-sep { width: 1px; height: 14px; background: var(--border); flex-shrink: 0; }
.hud-item { display: flex; align-items: center; gap: 4px; white-space: nowrap; flex-shrink: 0; }
.hud-label { font-size: 10px; text-transform: uppercase; letter-spacing: .5px; opacity: .6; }
.hud-val { color: var(--text); font-weight: 600; }
.hud-dim { font-size: 10px; opacity: .55; }
.hud-reset { font-size: 10px; opacity: .5; }
.hud-warn { color: var(--orange) !important; }
.hud-crit { color: var(--red) !important; }
.hud-ctx-bar { width: 70px; height: 4px; background: var(--s3); border-radius: 2px; overflow: hidden; flex-shrink: 0; }
.hud-ctx-fill { height: 100%; width: 0%; border-radius: 2px; background: var(--accent); transition: width .5s ease; }

/* ─── File attachment bar (chips above input) ─── */
.attach-bar { display: flex; flex-wrap: wrap; gap: 6px; padding: 0 2px 8px; }
.attach-bar:empty { display: none; }
.attach-chip {
  display: inline-flex; align-items: center; gap: 5px;
  background: var(--s3); border: 1px solid var(--border); border-radius: 8px;
  padding: 4px 5px; max-width: 200px; animation: fadeUp .12s ease;
}
.attach-chip img { width: 30px; height: 30px; object-fit: cover; border-radius: 4px; flex-shrink: 0; cursor: zoom-in; }
.attach-chip-icon {
  width: 30px; height: 30px; border-radius: 4px; background: var(--s2);
  display: flex; align-items: center; justify-content: center; font-size: 15px; flex-shrink: 0;
}
.attach-chip-name {
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  font-size: 11.5px; color: var(--muted); max-width: 120px;
}
.attach-chip-rm {
  background: none; border: none; color: var(--muted); cursor: pointer;
  font-size: 13px; padding: 0 2px; line-height: 1; flex-shrink: 0; transition: color .12s;
}
.attach-chip-rm:hover { color: var(--red); }

/* ─── Paperclip button ─── */
.attach-btn {
  width: 30px; height: 30px; border: none; background: none; color: var(--muted);
  border-radius: 7px; cursor: pointer; display: flex; align-items: center; justify-content: center;
  flex-shrink: 0; transition: color .12s, background .12s; margin-bottom: 3px; align-self: flex-end;
}
.attach-btn:hover { color: var(--accent2); background: rgba(124,106,239,.1); }
.attach-btn.has-files { color: var(--accent2); }
.attach-btn svg { width: 16px; height: 16px; }

/* ─── Full-screen drag-drop overlay ─── */
.drop-overlay {
  position: fixed; inset: 0; background: rgba(9,13,19,.82);
  display: flex; align-items: center; justify-content: center;
  z-index: 300; opacity: 0; pointer-events: none;
  transition: opacity .15s; backdrop-filter: blur(6px);
}
.drop-overlay.active { opacity: 1; }
.drop-overlay-inner { text-align: center; color: var(--accent2); user-select: none; pointer-events: none; }
.drop-overlay-inner svg { opacity: .8; }
.drop-overlay-inner p { font-size: 20px; font-weight: 700; margin-top: 14px; letter-spacing: -.3px; }
.drop-overlay-inner span { font-size: 13px; color: var(--muted); margin-top: 6px; display: block; }

/* ─── Attachment previews inside message bubbles ─── */
.msg-attachments { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; }
.msg-attach-img {
  width: 72px; height: 72px; object-fit: cover; border-radius: 8px;
  border: 1px solid rgba(124,106,239,.35); cursor: zoom-in; transition: opacity .15s;
}
.msg-attach-img:hover { opacity: .85; }
.msg-attach-file {
  display: inline-flex; align-items: center; gap: 6px;
  background: rgba(255,255,255,.05); border: 1px solid var(--border);
  border-radius: 7px; padding: 5px 10px; font-size: 12px; color: var(--muted);
}

/* ─── Reply button (hover on message) ─── */
.reply-btn {
  position: absolute; top: 30px; right: 5px;
  opacity: 0; background: var(--s3); border: 1px solid var(--border);
  color: var(--muted); padding: 3px 7px; border-radius: 5px;
  cursor: pointer; font-size: 13px; line-height: 1; transition: opacity .15s;
}
.mw:hover .reply-btn { opacity: .6; }
.reply-btn:hover { color: var(--text); opacity: 1 !important; background: var(--s2); }
/* User messages: shift action buttons left past the 34px avatar padding so they stay inside the bubble */
.mw.user .cpb   { right: 39px; } /* 34px avatar + 5px gap */
.mw.user .cpmd  { right: 72px; } /* 34px avatar + 38px original */
.mw.user .reply-btn { right: 39px; } /* same shift as .cpb */

/* ─── Fork button (continue in new chat) ─── */
.fork-btn {
  position: absolute; top: 55px; right: 5px;
  opacity: 0; background: var(--s3); border: 1px solid var(--border);
  color: var(--muted); padding: 3px 7px; border-radius: 5px;
  cursor: pointer; font-size: 12px; line-height: 1; transition: opacity .15s;
}
.mw:hover .fork-btn { opacity: .6; }
.fork-btn:hover { color: var(--text); opacity: 1 !important; background: var(--s2); }
.mw.user .fork-btn { right: 39px; top: 55px; }

/* ─── Use as input button (copy message to input field) ─── */
.use-btn {
  position: absolute; top: 55px; right: 5px;
  opacity: 0; background: var(--s3); border: 1px solid var(--border);
  color: var(--muted); padding: 3px 7px; border-radius: 5px;
  cursor: pointer; font-size: 12px; line-height: 1; transition: opacity .15s;
}
.mw:hover .use-btn { opacity: .6; }
.use-btn:hover { color: var(--text); opacity: 1 !important; background: var(--s2); }
.mw.user .use-btn { right: 39px; top: 55px; }
.mw.assistant .use-btn { top: 80px; } /* below fork-btn */

/* ─── Reply preview bar (above textarea) ─── */
.reply-preview {
  display: flex; align-items: center; gap: 8px;
  background: var(--s2); border: 1px solid var(--border);
  border-radius: 8px; padding: 6px 10px; margin-bottom: 6px;
  animation: fadeUp .12s ease;
}
.reply-preview-accent { width: 3px; background: var(--accent); border-radius: 2px; align-self: stretch; flex-shrink: 0; }
.reply-preview-content { flex: 1; min-width: 0; }
.reply-preview-role { font-size: 10px; color: var(--accent2); font-weight: 700; text-transform: uppercase; letter-spacing: .4px; margin-bottom: 2px; }
.reply-preview-text { font-size: 12px; color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.reply-preview-close { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 15px; padding: 0 3px; line-height: 1; flex-shrink: 0; transition: color .12s; }
.reply-preview-close:hover { color: var(--red); }

/* ─── Reply quote inside message bubble ─── */
.msg-reply-quote {
  font-size: 12px; color: var(--muted);
  border-left: 3px solid var(--accent);
  padding: 4px 8px; margin-bottom: 8px;
  background: rgba(124,106,239,.08); border-radius: 0 6px 6px 0;
  overflow: hidden;
}
.msg-reply-quote .rq-role { font-size: 10px; font-weight: 700; color: var(--accent2); text-transform: uppercase; letter-spacing: .4px; display: block; margin-bottom: 2px; }
.msg-reply-quote .rq-text { display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* ─── Responsive / Mobile ─── */
#mobileBackdrop {
  display: none; position: fixed; inset: 0; z-index: 45;
  background: rgba(0,0,0,.55); backdrop-filter: blur(4px);
}
@media (max-width: 800px) {
  /* Sidebars: fixed overlay instead of shrinking */
  .left {
    position: fixed; top: 0; left: 0; bottom: 0; z-index: 50;
    width: min(85vw, 300px) !important;
    transform: translateX(0);
    transition: transform .28s var(--ease-out), opacity .28s;
    box-shadow: 6px 0 40px rgba(0,0,0,.55);
    opacity: 1 !important;
  }
  .left.collapsed { transform: translateX(-105%); opacity: 0 !important; pointer-events: none; }
  .right {
    position: fixed; top: 0; right: 0; bottom: 0; z-index: 50;
    width: min(85vw, 300px) !important;
    transform: translateX(0);
    transition: transform .28s var(--ease-out), opacity .28s;
    box-shadow: -6px 0 40px rgba(0,0,0,.55);
    opacity: 1 !important;
  }
  .right.collapsed { transform: translateX(105%); opacity: 0 !important; pointer-events: none; }
  /* Panel tabs — bigger touch targets */
  .panel-tab { width: 32px; }
  .panel-tab-inner { width: 32px; height: 48px; }
  /* Center area adjustments */
  .msgs { padding: 12px 10px 40px; }
  .mw { max-width: 94%; }
  .mw.assistant { padding-left: 28px; }
  .mw.assistant::before { width: 22px; height: 22px; font-size: 8px; }
  .mw.user { padding-right: 28px; }
  .mw.user::after { width: 22px; height: 22px; font-size: 7px; }
  .mw.user .cpb, .mw.user .reply-btn { right: 33px; } /* 28px avatar + 5px on mobile */
  .mw.user .cpmd { right: 66px; } /* 28px avatar + 38px on mobile */
  .toolbar { gap: 5px; padding: 5px 10px; }
  .tb-group .label { display: none; }
  .hdr { padding: 8px 12px; }
  .hdr h1 { font-size: 14px; }
  /* Input area */
  .ia { padding: 10px 12px; }
  /* Tabs bar */
  .tabs-bar { overflow-x: auto; }
  .tab { max-width: 140px; }
  /* File preview: full screen on mobile */
  .fpv-modal { width: 100vw !important; max-width: 100vw !important; height: 100vh !important; max-height: 100vh !important; border-radius: 0 !important; }
}
@media (max-width: 480px) {
  .hdr-btns .hb span { display: none; }
  .hb { padding: 5px 8px; }
  .nav-sw-btn { padding: 4px 8px; }
  .toolbar { font-size: 12px; }
}
</style>
</head>
<body>

<!-- LEFT PANEL -->
<div class="left" id="leftPanel">
  <div class="left-inner">
    <div class="sec">
      <div class="sec-title" role="button" tabindex="0" aria-expanded="true" onclick="toggleSec('proj')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggleSec('proj')}">
        <span data-i18n="sec.projects">Проекти</span>
        <span class="badge" id="projCount"></span>
      </div>
      <div class="sec-body" id="projBody">
        <div id="projList"></div>
        <button class="add-btn" onclick="openAddProject()" data-i18n="proj.add">＋ Додати проект</button>
      </div>
    </div>

    <!-- SSH Hosts section -->
    <div class="sec">
      <div class="sec-title" role="button" tabindex="0" aria-expanded="true" onclick="toggleSec('sshHosts')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggleSec('sshHosts')}">
        <span>🌐 SSH Хости</span>
        <span class="badge" id="sshHostCount"></span>
      </div>
      <div class="sec-body" id="sshHostsBody">
        <div id="sshHostList"></div>
        <button class="add-btn" onclick="openAddHostModal()">＋ Додати SSH хост</button>
      </div>
    </div>

    <div class="sec">
      <div class="sec-title" role="button" tabindex="0" aria-expanded="true" onclick="toggleSec('hist')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggleSec('hist')}">
        <span><span data-i18n="sec.chats">Чати</span> <span class="badge" id="histCount">0</span></span>
        <button class="hist-select-btn" id="histSelBtn" onclick="event.stopPropagation();toggleHistSelect()" title="Вибрати кілька">☑</button>
      </div>
      <div class="sec-body" id="histBody">
        <div class="hist-list" id="histList"></div>
        <div class="hist-bulk-bar" id="histBulkBar">
          <span class="bulk-info" id="histBulkInfo">0 вибрано</span>
          <button class="bulk-all" onclick="selectAllHist()">Всі</button>
          <button class="bulk-del" id="histBulkDel" onclick="delSelectedHist()" disabled>Видалити</button>
        </div>
      </div>
    </div>

    <div class="sec">
      <div class="sec-title" role="button" tabindex="0" aria-expanded="true" onclick="toggleSec('mcp')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggleSec('mcp')}">
        <span data-i18n="sec.mcp">MCP</span>
        <span class="badge" id="mcpCount">0</span>
      </div>
      <div class="sec-body" id="mcpBody">
        <div style="font-size:11px;color:var(--muted);padding:2px 2px 8px;line-height:1.5" data-i18n="mcp.hint">Увімкніть інструменти, які Claude може використовувати в цьому чаті.</div>
        <div id="mcpList"></div>
        <button class="add-btn" onclick="showMcpForm()" data-i18n="mcp.add">＋ Додати MCP-сервер</button>
        <div style="display:flex;gap:5px;margin-top:4px">
          <button class="bg" onclick="openMcpImport()" style="flex:1;font-size:11px;padding:5px 6px;display:inline-flex;align-items:center;justify-content:center;gap:4px" data-i18n-title="mcp.import.title" title="Імпортувати MCP з JSON файлу (Claude Desktop формат)"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> <span data-i18n="mcp.import.btn">Імпорт</span></button>
          <button class="bg" onclick="exportMcp()" style="flex:1;font-size:11px;padding:5px 6px;display:inline-flex;align-items:center;justify-content:center;gap:4px" data-i18n-title="mcp.export.title" title="Експортувати всі MCP у JSON файл"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg> <span data-i18n="mcp.export.btn">Експорт</span></button>
        </div>
        <div id="mcpForm" style="display:none" class="af">
          <select id="mcpType" onchange="updateMcpFormType()">
            <option value="stdio" data-i18n="mcp.type.stdio">stdio (команда)</option>
            <option value="sse" data-i18n="mcp.type.sse">SSE (URL потік)</option>
            <option value="http">HTTP (REST)</option>
          </select>
          <input id="mcpId" data-i18n-ph="mcp.id" placeholder="ID (напр. my-server)">
          <input id="mcpLabel" data-i18n-ph="mcp.label" placeholder="Назва">
          <div id="mcpStdioFields">
            <input id="mcpCmd" data-i18n-ph="mcp.cmd" placeholder="Команда (напр. npx)">
            <input id="mcpArgs" data-i18n-ph="mcp.args" placeholder="Аргументи через кому">
          </div>
          <div id="mcpUrlFields" style="display:none">
            <input id="mcpUrl" placeholder="URL (https://...)">
            <textarea id="mcpHeadersArea" placeholder='{"Authorization":"Bearer TOKEN"}' style="display:none"></textarea>
          </div>
          <textarea id="mcpEnv" placeholder='{"KEY":"value"}'></textarea>
          <div class="fr">
            <button class="bp" onclick="addMcp()" data-i18n="mcp.add_btn">Додати</button>
            <button class="bg" onclick="hideMcpForm()">✕</button>
          </div>
        </div>
      </div>
    </div>

    <div class="sec">
      <div class="sec-title" role="button" tabindex="0" aria-expanded="true" onclick="toggleSec('skills')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggleSec('skills')}">
        <span data-i18n="sec.skills">Навички</span>
        <div style="display:flex;align-items:center;gap:6px;margin-left:auto">
          <span class="badge" id="skillsCount">0</span>
          <button id="autoSkillsBtn" class="auto-skills-btn" onclick="event.stopPropagation();toggleAutoSkills()">⚡ Auto</button>
        </div>
      </div>
      <div class="sec-body" id="skillsBody">
        <div style="font-size:11px;color:var(--muted);padding:2px 2px 8px;line-height:1.5" data-i18n="skills.hint">Навички — файли інструкцій, що додаються до системного промпту.</div>
        <div id="autoSkillsHint" class="auto-notif" style="display:none" data-i18n="skills.auto_hint">⚡ Навички обираються автоматично по тексту задачі</div>
        <div id="skillsList"></div>
        <button class="add-btn" onclick="$i('skillUpload').click()" data-i18n="skills.upload">＋ Завантажити .md файл</button>
        <input type="file" id="skillUpload" accept=".md,.txt" style="display:none" onchange="uploadSkill(this)">
      </div>
    </div>
  </div>
</div>

<!-- LEFT PANEL TAB -->
<div class="panel-tab panel-tab-left active" role="button" tabindex="0" aria-label="Toggle left panel" onclick="toggle('leftPanel')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggle('leftPanel')}" data-tip="Сховати/показати ліву панель" data-i18n-tip="tip.panels.left">
  <div class="panel-tab-inner">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
  </div>
</div>

<!-- CENTER PANEL -->
<div class="center">
  <div class="hdr-collapse-zone" id="hdrZone">
  <div class="hdr">
    <div class="hdr-l">
      <div class="logo">CCS</div>
      <nav class="nav-sw" aria-label="Навігація між розділами" data-i18n-aria="nav.aria">
        <a class="nav-sw-btn active" href="/" data-tip="Чат" data-i18n-tip="nav.chat.tip">
          <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.3"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg>
          Chat
        </a>
        <a class="nav-sw-btn" href="/kanban" data-tip="Kanban дошка" data-i18n-tip="nav.kanban.tip">
          <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.3"><rect x="3" y="3" width="5" height="18" rx="1"/><rect x="10" y="3" width="5" height="13" rx="1"/><rect x="17" y="3" width="5" height="9" rx="1"/></svg>
          Kanban
        </a>
      </nav>
      <div class="hdr-meta">
        <div class="proj-dd-wrap" id="projDdWrap">
          <button class="proj-dd-btn" id="projDdBtn" onclick="toggleProjDropdown()">
            <span class="proj-dd-icon">📁</span>
            <span class="proj-dd-name" id="projDdName">Проект</span>
            <span class="proj-dd-arrow">▼</span>
          </button>
          <div class="proj-dd-menu" id="projDdMenu">
            <div class="proj-dd-search">
              <input type="text" id="projDdSearch" data-i18n-ph="proj.search" placeholder="Пошук проекту..." oninput="filterProjDropdown(this.value)">
            </div>
            <div class="proj-dd-list" id="projDdList"></div>
          </div>
        </div>
        <span id="versionBadge" data-i18n-title="ver.checking" title="Перевірка версії..."></span>
      </div>
    </div>
    <div class="hdr-btns">
      <div id="rlBadge">
        <span class="rl-dot"></span>
        <span class="rl-label" id="rlBadgeLabel">Max ⚠</span>
        <div id="rlTooltip">
          <div class="rl-tt-title"><span id="rl-tt-icon">⚠️</span> <span id="rl-tt-title-text" data-i18n="rl.title.warn">Наближається ліміт</span></div>
          <div class="rl-bar"><div class="rl-bar-fill" id="rl-bar-fill"></div></div>
          <div class="rl-tt-row"><span class="rl-tt-key" data-i18n="rl.key.type">Тип</span><span class="rl-tt-val" id="rl-tt-type">—</span></div>
          <div class="rl-tt-row"><span class="rl-tt-key" data-i18n="rl.key.used">Використано</span><span class="rl-tt-val" id="rl-tt-used">—</span></div>
          <div class="rl-tt-row"><span class="rl-tt-key" data-i18n="rl.key.left">Залишилось</span><span class="rl-tt-val" id="rl-tt-left">—</span></div>
          <div class="rl-tt-row"><span class="rl-tt-key" data-i18n="rl.key.reset">Скидання</span><span class="rl-tt-val" id="rl-tt-reset">—</span></div>
          <div class="rl-tt-row"><span class="rl-tt-key" data-i18n="rl.key.via">Через</span><span class="rl-tt-val" id="rl-tt-countdown">—</span></div>
        </div>
      </div>
      <button class="hb" onclick="newSession()" data-tip="Новий чат" data-i18n-tip="tip.new">&#xFF0B; <span data-i18n="btn.new">Чат</span></button>
      <button class="hb" onclick="openCfgEditor()" data-tip="Налаштування" data-i18n-tip="tip.cfg"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2"><line x1="4" y1="21" x2="4" y2="14"/><line x1="4" y1="10" x2="4" y2="3"/><line x1="12" y1="21" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="3"/><line x1="20" y1="21" x2="20" y2="16"/><line x1="20" y1="12" x2="20" y2="3"/><line x1="1" y1="14" x2="7" y2="14"/><line x1="9" y1="8" x2="15" y2="8"/><line x1="17" y1="16" x2="23" y2="16"/></svg></button>
      <select class="lang-sel" id="langSel" onchange="setLang(this.value)" aria-label="Interface language" data-tip="Мова інтерфейсу" data-i18n-tip="tip.lang">
        <option value="en">EN</option>
        <option value="uk">UK</option>
        <option value="ru">RU</option>
      </select>
      <a class="hb" href="https://github.com/Lexus2016/claude-code-studio" target="_blank" rel="noopener" data-tip="GitHub" style="text-decoration:none"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.477 2 2 6.477 2 12c0 4.418 2.865 8.166 6.839 9.489.5.092.682-.217.682-.482 0-.237-.009-.868-.013-1.703-2.782.604-3.369-1.34-3.369-1.34-.454-1.154-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.115 2.504.337 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.163 22 16.418 22 12c0-5.523-4.477-10-10-10z"/></svg></a>
      <button class="hb" onclick="logout()" data-tip="Вийти" data-i18n-tip="tip.logout"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2"><path d="M9 21H5a2 2 0 01-2-2V5a2 2 0 012-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg></button>
    </div>
  </div>

  <div class="toolbar">
    <div class="tb-group">
      <span class="label" data-i18n="tb.mode">Режим</span>
      <button class="tb-btn on" data-v="auto" onclick="setOpt(this,'mode')">Auto</button>
      <button class="tb-btn" data-v="planning" onclick="setOpt(this,'mode')">Plan</button>
      <button class="tb-btn" data-v="task" onclick="setOpt(this,'mode')">Task</button>
    </div>
    <div class="tb-sep"></div>
    <div class="tb-group">
      <span class="label" data-i18n="tb.agent">Агент</span>
      <button class="tb-btn on" data-v="single" onclick="setOpt(this,'agent')">Single</button>
      <button class="tb-btn" data-v="multi" onclick="setOpt(this,'agent')">Multi</button>
      <button class="tb-btn" data-v="dispatch" onclick="setOpt(this,'agent')">Plan</button>
    </div>
    <div class="tb-sep"></div>
    <div class="tb-group">
      <span class="label" data-i18n="tb.model">Модель</span>
      <button class="tb-btn" data-v="haiku" onclick="setOpt(this,'model')">Haiku</button>
      <button class="tb-btn on" data-v="sonnet" onclick="setOpt(this,'model')">Sonnet</button>
      <button class="tb-btn" data-v="opus" onclick="setOpt(this,'model')">Opus</button>
    </div>
    <div class="tb-sep"></div>
    <div class="tb-group">
      <span class="label" data-i18n="tb.turns">Кроки</span>
      <input type="number" class="tb-input" id="maxTurns" value="50" min="1" max="200">
    </div>
    <div style="flex:1"></div>
    <span class="status-dot warn" id="statusEl" data-i18n="status.connecting">Підключення...</span>
  </div>
  </div><!-- /hdr-collapse-zone -->

  <div class="tabs-bar" id="tabsBar"></div>

  <div class="sess-bar" id="sessBar" style="display:none">
    <span id="sessBarSkills" style="display:flex;gap:4px;align-items:center;overflow:hidden;flex-shrink:1;"></span>
    <span style="flex:1"></span>
    <span id="sessBarRetry" style="display:none;font-size:11px;color:var(--warn,#f59e0b);opacity:.85;flex-shrink:0;"></span>
    <span id="sessBarClaudeId" style="display:none;font-family:monospace;font-size:10px;color:var(--muted);background:var(--s3,#1f2637);padding:1px 6px;border-radius:4px;border:1px solid var(--border);cursor:pointer;flex-shrink:0;" title="" onclick="copySessId()"></span>
    <a id="sessBarOpenBtn" style="display:none;font-size:11px;color:var(--accent2);text-decoration:none;padding:1px 7px;border-radius:4px;border:1px solid rgba(124,106,239,.25);flex-shrink:0;cursor:pointer;" onclick="openInClaude()">⚡ Claude Code</a>
  </div>

  <div class="msgs" id="messages" role="log" aria-live="polite" aria-label="Chat messages">
    <div class="welcome">
      <div class="wi">CC</div>
      <h2>Claude Code Studio</h2>
      <p data-i18n="welcome.desc">Виберіть MCP та Навички зліва, файли — справа.</p>
      <div class="welcome-prompts">
        <div class="wp-card" onclick="setPrompt(this)">&#x1F4A1; <span data-i18n="welcome.prompt.1">Поясни цей код крок за кроком</span></div>
        <div class="wp-card" onclick="setPrompt(this)">&#x1F41B; <span data-i18n="welcome.prompt.2">Знайди та виправ помилки</span></div>
        <div class="wp-card" onclick="setPrompt(this)">&#x2728; <span data-i18n="welcome.prompt.3">Напиши unit-тести</span></div>
        <div class="wp-card" onclick="setPrompt(this)">&#x1F3D7;&#xFE0F; <span data-i18n="welcome.prompt.4">Спроектуй архітектуру</span></div>
      </div>
    </div>
  </div>

  <button id="scrollBtn" onclick="scrollToBottom()" data-i18n-title="scroll.down" title="Scroll to bottom">↓</button>

  <div class="ia" style="position:relative">
    <!-- Hidden file input for local file attachment -->
    <input type="file" id="filePickerInput" multiple style="display:none" onchange="onFilePicker(this)">
    <!-- @ file picker popup -->
    <div class="at-popup hidden" id="atPopup">
      <div class="at-popup-hdr">
        <span>📁</span>
        <input id="atSearch" data-i18n-ph="at.search" placeholder="Search file..." autocomplete="off" oninput="onAtSearch(this.value)">
      </div>
      <div class="at-popup-list" id="atList"></div>
    </div>
    <!-- Attachment chips (files + screenshots) -->
    <div class="att-chips" id="attChips"></div>
    <div id="replyPreview" class="reply-preview" style="display:none">
      <div class="reply-preview-accent"></div>
      <div class="reply-preview-content">
        <div class="reply-preview-role" id="replyPreviewRole"></div>
        <div class="reply-preview-text" id="replyPreviewText"></div>
      </div>
      <button class="reply-preview-close" onclick="clearReply()" data-i18n-title="reply.cancel" title="Cancel reply">✕</button>
    </div>
    <div class="iw">
      <button class="attach-btn" type="button" onclick="$i('filePickerInput').click()" data-i18n-title="attach.file" title="Додати файл" aria-label="Attach file">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
        </svg>
      </button>
      <textarea id="input" rows="1" data-i18n-ph="input.ph" placeholder="Напишіть завдання... Вставте скріншот (Ctrl+V) · @ для файлів проекту · 📎 для будь-яких файлів" autofocus aria-label="Message input" aria-multiline="true"></textarea>
      <span class="queue-badge" id="queueBadge" data-i18n-title="queue.title" title="Завдань у черзі"></span>
      <button class="sb stop-btn hidden" id="stopBtn" onclick="confirmStop()" data-i18n-title="stop.agent" title="Stop agent">
        <svg viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
      </button>
      <button class="sb" id="sendBtn" onclick="send()" data-i18n-title="send.msg" title="Send (Enter)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
          <line x1="22" y1="2" x2="11" y2="13"/>
          <polygon points="22 2 15 22 11 13 2 9 22 2"/>
        </svg>
      </button>
    </div>
  </div>
</div>

<!-- RIGHT PANEL TAB (left side of right panel) -->
<div class="panel-tab panel-tab-right active" role="button" tabindex="0" aria-label="Toggle right panel" onclick="toggle('rightPanel')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggle('rightPanel')}" data-tip="Сховати/показати праву панель" data-i18n-tip="tip.panels.right">
  <div class="panel-tab-inner">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
  </div>
</div>

<!-- RIGHT PANEL: File Browser -->
<div class="right" id="rightPanel">
  <div class="fh">
    <span data-i18n="files.title">Робоча директорія</span>
    <button onclick="loadFiles()" data-i18n-title="files.refresh" title="Оновити">↻</button>
  </div>
  <div class="ft" id="filesTree"></div>
</div>

<!-- Config Modal -->
<div class="modal-overlay hidden" id="cfgModal" onclick="if(event.target===this)closeCfg()">
  <div class="modal">
    <div class="modal-hdr">
      <h2 data-i18n="cfg.title">Налаштування</h2>
      <button class="modal-close" onclick="closeCfg()">✕</button>
    </div>
    <div class="modal-tabs" id="cfgTabs"></div>
    <div class="modal-body">
      <div class="cfg-path hidden" id="cfgPathInfo"></div>
      <textarea id="cfgEditor" spellcheck="false"></textarea>
    </div>
    <div class="modal-footer">
      <span class="save-notice hidden" id="saveNotice" data-i18n="cfg.saved">✓ Збережено</span>
      <div style="display:flex;gap:8px">
        <button class="bg" onclick="closeCfg()" data-i18n="cfg.close">Закрити</button>
        <button class="bp" onclick="saveCfg()" data-i18n="cfg.save">Зберегти</button>
      </div>
    </div>
  </div>
</div>

<!-- MCP Settings Modal -->
<div class="modal-overlay hidden" id="mcpSettingsModal" onclick="if(event.target===this)closeMcpSettings()">
  <div class="modal" style="width:580px;max-height:85vh">
    <div class="modal-hdr">
      <h2 id="mcpSettingsTitle" style="font-size:16px;font-weight:700">⚙ MCP</h2>
      <button class="modal-close" onclick="closeMcpSettings()">✕</button>
    </div>
    <div class="modal-body" id="mcpSettingsBody" style="padding:18px 20px;display:flex;flex-direction:column;gap:14px;overflow-y:auto"></div>
    <div class="modal-footer">
      <button class="bg" onclick="closeMcpSettings()" data-i18n="mcp.cfg.cancel">Скасувати</button>
      <button class="bp" onclick="saveMcpSettings()" data-i18n="mcp.cfg.save">Зберегти</button>
    </div>
  </div>
</div>

<!-- MCP Import Modal -->
<div class="modal-overlay hidden" id="mcpImportModal" onclick="if(event.target===this)closeMcpImport()">
  <div class="modal" style="width:500px;max-height:82vh">
    <div class="modal-hdr">
      <h2 style="font-size:14px;display:flex;align-items:center;gap:6px"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> <span data-i18n="mcp.import.modal.title">Імпорт MCP серверів</span></h2>
      <button class="modal-close" onclick="closeMcpImport()">✕</button>
    </div>
    <div class="modal-body" style="padding:14px 16px;display:flex;flex-direction:column;gap:10px;overflow-y:auto">
      <div style="font-size:12px;color:var(--muted);line-height:1.6">
        Підтримується формат <strong>Claude Desktop</strong> (<code>claude_desktop_config.json</code>) та будь-який JSON вигляду <code style="font-size:11px">{"mcpServers":{...}}</code>
      </div>
      <div id="mcpImportDrop"
           style="border:2px dashed var(--border);border-radius:8px;padding:18px 12px;text-align:center;cursor:pointer;transition:border-color .15s"
           onclick="$i('mcpImportFile').click()"
           ondragover="event.preventDefault();this.style.borderColor='var(--accent)'"
           ondragleave="this.style.borderColor='var(--border)'"
           ondrop="event.preventDefault();this.style.borderColor='var(--border)';handleMcpImportDrop(event)">
        <div style="font-size:13px;color:var(--muted);display:flex;flex-direction:column;align-items:center;gap:8px"><svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 16 12 12 8 16"/><line x1="12" y1="12" x2="12" y2="21"/><path d="M20.39 18.39A5 5 0 0018 9h-1.26A8 8 0 103 16.3"/></svg><span data-i18n="mcp.import.drop">Перетягніть .json файл або натисніть для вибору</span></div>
        <input type="file" id="mcpImportFile" accept=".json" style="display:none" onchange="handleMcpImportFile(this)">
      </div>
      <div style="text-align:center;font-size:11px;color:var(--muted);margin:-2px 0" data-i18n="mcp.import.or">— або вставте JSON вручну —</div>
      <textarea id="mcpImportJson"
                placeholder='{"mcpServers":{"my-server":{"command":"npx","args":["my-mcp"],"env":{"API_KEY":"value"}}}}'
                style="background:var(--s2);border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:6px;font-size:11px;outline:none;width:100%;font-family:monospace;min-height:90px;resize:vertical;transition:border .15s"
                oninput="mcpImportPreviewClear()"></textarea>
      <div id="mcpImportError" style="display:none;font-size:12px;color:var(--orange);padding:7px 10px;background:var(--s2);border-radius:6px;border:1px solid var(--orange)"></div>
      <div id="mcpImportPreview" style="display:none;flex-direction:column;gap:6px">
        <div style="font-size:11px;font-weight:600;color:var(--muted);text-transform:uppercase;letter-spacing:.4px">
          <span data-i18n="mcp.import.found">Знайдено серверів:</span> <span id="mcpImportCount" style="color:var(--text)">0</span>
        </div>
        <div id="mcpImportList" style="display:flex;flex-direction:column;gap:3px;max-height:200px;overflow-y:auto"></div>
      </div>
      <label style="display:flex;align-items:center;gap:8px;font-size:12px;cursor:pointer;padding:8px 10px;background:var(--s2);border-radius:6px">
        <input type="checkbox" id="mcpImportReplace">
        <span data-i18n="mcp.import.replace">Замінити існуючі кастомні сервери (інакше — злиття)</span>
      </label>
    </div>
    <div class="modal-footer">
      <button class="bg" onclick="closeMcpImport()" data-i18n="mcp.cfg.cancel">Скасувати</button>
      <button class="bg" onclick="previewMcpImport()" style="margin-left:auto" data-i18n="mcp.import.preview.btn">👁 Перегляд</button>
      <button class="bp" onclick="doMcpImport()" id="mcpImportBtn" disabled data-i18n="mcp.import.do">Імпортувати</button>
    </div>
  </div>
</div>

<!-- File Preview Modal -->
<div class="modal-overlay hidden" id="filePreviewModal" onclick="if(event.target===this)closeFpv()">
  <div class="modal fpv-modal">
    <div class="modal-hdr">
      <h2 id="fpvTitle" style="font-size:14px;font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;min-width:0"></h2>
      <button class="modal-close" onclick="closeFpv()">✕</button>
    </div>
    <div class="fpv-toolbar">
      <span class="fpv-ext" id="fpvExt"></span>
      <button class="fpv-btn" onclick="fpvDownload()" data-i18n-title="fpv.download.title" title="Завантажити файл">
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
        <span data-i18n="fpv.download">Завантажити</span>
      </button>
      <button class="fpv-btn" onclick="fpvShare()" id="fpvShareBtn" data-i18n-title="fpv.share.title" title="Поділитись / Скопіювати посилання">
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>
        <span data-i18n="fpv.share">Поділитись</span>
      </button>
    </div>
    <div class="fpv-body" id="fpvBody"></div>
  </div>
</div>

<!-- Directory Browser Modal -->
<div class="modal-overlay hidden" id="dirModal" onclick="if(event.target===this)closeDirModal()">
  <div class="modal dir-modal">
    <div class="modal-hdr">
      <h2 data-i18n="dir.title">Новий проект</h2>
      <button class="modal-close" onclick="closeDirModal()">✕</button>
    </div>

    <!-- Local / Remote toggle -->
    <div class="proj-type-toggle">
      <button class="proj-type-btn active" id="projTypeLocal" onclick="setProjType('local')">📁 Локальний</button>
      <button class="proj-type-btn" id="projTypeRemote" onclick="setProjType('remote')">🌐 Віддалений SSH</button>
    </div>

    <!-- LOCAL section -->
    <div id="projLocalSection">
      <div class="dir-path-bar">
        <span class="path-text" id="dirCurrentPath">/</span>
      </div>
      <div class="dir-list" id="dirList">
        <div style="padding:14px;color:var(--muted);text-align:center;font-size:12px" data-i18n="toast.loading">Завантаження...</div>
      </div>
    </div>

    <!-- REMOTE section -->
    <div id="projRemoteSection" style="display:none">
      <div class="remote-form">
        <div class="rh-form-row">
          <span class="rh-label">SSH Хост:</span>
          <select id="remoteHostSelect" style="flex:1">
            <option value="">— оберіть хост —</option>
          </select>
          <button class="bg" onclick="openAddHostModal()" style="padding:5px 10px;font-size:12px;flex-shrink:0">＋ Новий</button>
        </div>
        <div class="rh-form-row">
          <span class="rh-label">Шлях на сервері:</span>
          <input id="remoteWorkdirInput" placeholder="/home/user/myproject" style="flex:1">
        </div>
        <div class="rh-form-row">
          <span class="rh-label"></span>
          <button class="bg" onclick="testSelectedHost()" style="padding:5px 12px;font-size:12px">🔌 Тест з'єднання</button>
          <div class="rh-test-result" id="remoteTestResult"></div>
        </div>
      </div>
    </div>

    <div class="proj-name-row">
      <span style="font-size:12px;color:var(--muted);white-space:nowrap" data-i18n="dir.name.label">Назва:</span>
      <input id="projNameInput" data-i18n-ph="dir.proj_name" placeholder="Назва проекту (авто якщо порожньо)">
    </div>
    <div class="dir-footer">
      <label id="gitInitLabel">
        <input type="checkbox" id="gitInitChk">
        <span data-i18n="dir.git.init">git init (якщо ще не репозиторій)</span>
      </label>
      <div style="flex:1"></div>
      <button class="bg" onclick="closeDirModal()" style="padding:6px 14px" data-i18n="dir.cancel">Cancel</button>
      <button class="bp" onclick="selectDir()" style="padding:6px 14px" data-i18n="proj.add">＋ Додати проект</button>
    </div>
  </div>
</div>

<!-- Add SSH Host Modal -->
<div class="modal-overlay hidden" id="sshHostModal" onclick="if(event.target===this)closeSshHostModal()">
  <div class="modal ssh-host-modal">
    <div class="modal-hdr">
      <h2 id="sshHostModalTitle">🌐 Додати SSH хост</h2>
      <button class="modal-close" onclick="closeSshHostModal()">✕</button>
    </div>
    <div class="ssh-host-form">
      <div>
        <label>Назва хоста *</label>
        <input id="sshHostLabel" placeholder="Мій продакшн сервер">
      </div>
      <div>
        <label>Хост (user@host або host) *</label>
        <input id="sshHostHost" placeholder="deploy@eu.myserver.com">
      </div>
      <div class="rh-form-row" style="gap:12px">
        <div style="flex:1">
          <label style="display:block;font-size:12px;color:var(--muted);margin-bottom:4px">Порт</label>
          <input id="sshHostPort" type="number" placeholder="22" value="22" style="width:100%;box-sizing:border-box">
        </div>
        <div style="flex:3">
          <label style="display:block;font-size:12px;color:var(--muted);margin-bottom:4px">Метод автентифікації</label>
          <div style="display:flex;gap:6px">
            <button class="proj-type-btn active" id="sshAuthBtnKey" onclick="setAuthType('key')" style="flex:1;padding:5px 0;font-size:11px">🔑 SSH ключ</button>
            <button class="proj-type-btn" id="sshAuthBtnPwd" onclick="setAuthType('pwd')" style="flex:1;padding:5px 0;font-size:11px">🔐 Пароль</button>
          </div>
        </div>
      </div>
      <div id="sshHostKeyRow">
        <label>Шлях до SSH ключа (необов'язково)</label>
        <input id="sshHostKey" placeholder="~/.ssh/id_rsa">
      </div>
      <div id="sshHostPasswordRow" class="hidden">
        <label>Пароль</label>
        <input id="sshHostPassword" type="password" placeholder="••••••••" autocomplete="current-password">
      </div>
      <div style="font-size:11px;color:var(--muted);line-height:1.5;padding:2px 0">
        💡 SSH ключ: без пароля або доданий у ssh-agent. Перше підключення автоматично підтвердить fingerprint. Пароль зберігається у відкритому вигляді — рекомендуємо використовувати ключ.
      </div>
      <div class="rh-test-result" id="sshHostTestResult"></div>
    </div>
    <div class="dir-footer">
      <button class="bg" onclick="testNewSshHost()" style="padding:6px 14px">🔌 Тест</button>
      <div style="flex:1"></div>
      <button class="bg" onclick="closeSshHostModal()" style="padding:6px 14px">Скасувати</button>
      <button class="bp" id="sshHostSaveBtn" onclick="saveNewSshHost()" style="padding:6px 14px">＋ Зберегти хост</button>
    </div>
  </div>
</div>

<!-- Confirm Stop Modal -->
<div class="confirm-overlay hidden" id="confirmStopModal" onclick="if(event.target===this)cancelStop()">
  <div class="confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="confirmStopTitle">
    <div class="cd-icon">⏹</div>
    <h3 id="confirmStopTitle" data-i18n="confirm.stop.h">Stop task?</h3>
    <p data-i18n="confirm.stop.desc">Виконання агента буде перервано.</p>
    <div class="confirm-actions">
      <button class="cd-btn-cancel" onclick="cancelStop()" data-i18n="confirm.stop.cancel">Cancel</button>
      <button class="cd-btn-stop" id="confirmStopBtn" onclick="doStop()" data-i18n="confirm.stop.yes">Yes, stop</button>
    </div>
  </div>
</div>

<!-- Rate Limit Rejected Modal -->
<div class="confirm-overlay hidden" id="rlRejectedModal" onclick="if(event.target===this)closeRlModal()">
  <div class="confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="rlModalTitle">
    <div class="cd-icon">🚫</div>
    <div class="rl-modal-type" id="rlModalType">—</div>
    <h3 id="rlModalTitle">Ліміт вичерпано</h3>
    <p id="rlModalDesc">Ваш ліміт Claude Max вичерпано.</p>
    <div class="rl-modal-countdown">
      <span class="rl-cd-label" data-i18n="rl.modal.reset">Скидання через:</span>
      <span id="rlModalTimer">—</span>
    </div>
    <div class="confirm-actions" style="margin-top:18px">
      <button class="cd-btn-ok" onclick="closeRlModal()" data-i18n="rl.modal.ok">Зрозуміло</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div id="toast"></div>

<!-- Notifications (non-blocking, from notify_user MCP) -->
<div id="notifContainer"></div>

<script>
'use strict';

// ─── State ───────────────────────────────────────────────────────────────────
let ws = null, isGen = false, currentSessionId = null, generatingTabId = null;
let replyTo = null; // { id, role, content }
let openTabs = [], activeTabId = null;
const tabState = {}; // per-tab: { curEl, curTxt, currentSessionId, generating, draft, agentStatus, _toolCounts, _toolLog }
function getTS(id) {
  if (!tabState[id]) tabState[id] = { curEl: null, curTxt: '', currentSessionId: null, generating: false, draft: '', agentStatus: '', _toolCounts: {}, _toolLog: [] };
  return tabState[id];
}

// ─── Streaming state proxy (isolated per-tab) ────────────────────────────────
// CRITICAL: These provide transparent access to the ACTIVE tab's streaming state.
// Using this proxy ensures tab isolation — switching tabs mid-stream won't mix messages.
// Usage: `streaming.el` reads/writes curEl property of active tab's tabState.
const streaming = {
  get el() { return getTS(activeTabId).curEl; },
  set el(v) { getTS(activeTabId).curEl = v; },
  get txt() { return getTS(activeTabId).curTxt; },
  set txt(v) { getTS(activeTabId).curTxt = v; },
  get toolCounts() { return getTS(activeTabId)._toolCounts; },
  set toolCounts(v) { getTS(activeTabId)._toolCounts = v; },
  get toolLog() { return getTS(activeTabId)._toolLog; },
  set toolLog(v) { getTS(activeTabId)._toolLog = v; },
  reset() { const s = getTS(activeTabId); s.curEl = null; s.curTxt = ''; s._toolCounts = {}; s._toolLog = []; },
};
let config = { mcpServers: {}, skills: {} };
let activeMcp = new Set(), activeSkills = new Set();
let autoSkillsMode = true; // ON by default; user can disable
let cfgFiles = {}, activeCfgTab = null;
let curMode = 'auto', curAgent = 'single', curModel = 'sonnet';
let curWorkdir = null; // current working directory for the session
let projects = [], curProjectId = null; // projects list + active project

// ─── Per-project in-memory tab state ─────────────────────────────────────
// Keeps all projects' tabs alive simultaneously so background generation continues
const projectTabs = {};      // { projectId: Tab[] }  — live references to openTabs arrays
const projectActiveTab = {}; // { projectId: string|null } — last active tab per project

// Find a tab across current project and all background projects
function findTabAcrossProjects(tabId) {
  let tab = openTabs.find(t => t.id === tabId);
  if (tab) return { tab, tabs: openTabs, projId: curProjectId, isCurrent: true };
  for (const [pid, tabs] of Object.entries(projectTabs)) {
    if (pid === curProjectId) continue;
    tab = tabs.find(t => t.id === tabId);
    if (tab) return { tab, tabs, projId: pid, isCurrent: false };
  }
  return null;
}
let userScrolled = false; // track if user scrolled up
let histOffset = 0;       // offset of the oldest rendered message (non-tool)
let histTotal  = 0;       // total non-tool message count for current session
let dirBrowsePath = null; // path currently shown in dir browser
let _onProjectCreated = null; // callback to invoke after a new project is created

const $i = id => document.getElementById(id);
const msgsEl = $i('messages');
const inEl = $i('input');

// ─── i18n ─────────────────────────────────────────────────────────────────
const TRANSLATIONS = {
  uk: {
    'sec.proactive':'Статус',
    'sec.chats':'Чати','sec.mcp':'MCP',
    'mcp.hint':'Увімкніть інструменти, які Claude може використовувати в цьому чаті.',
    'mcp.add':'＋ Додати MCP-сервер','mcp.id':'ID (напр. my-server)','mcp.label':'Назва',
    'mcp.cmd':'Команда (напр. npx)','mcp.args':'Аргументи через кому','mcp.add_btn':'Додати',
    'sec.skills':'Навички','skills.hint':'Навички — файли інструкцій, що додаються до системного промпту.',
    'skills.upload':'＋ Завантажити .md файл','sec.projects':'Проекти','proj.add':'＋ Додати проект',
    'tip.new':'Новий чат','tip.cfg':'Налаштування','tip.logout':'Вийти',
    'tip.panels.left':'Сховати/показати ліву панель','tip.panels.right':'Сховати/показати праву панель',
    'btn.new':'Чат','tb.mode':'Режим','tb.agent':'Агент','tb.model':'Модель','tb.turns':'Кроки',
    'welcome.title':'Нова сесія','welcome.ready':'Готовий до роботи',
    'welcome.desc':'Виберіть MCP та Навички зліва, файли — справа.',
    'input.ph':'Напишіть завдання... Вставте скріншот (Ctrl+V) · @ для файлів проекту · 📎 для будь-яких файлів',
    'files.title':'Робоча директорія','files.refresh':'Оновити','queue.title':'Завдань у черзі',
    'cfg.title':'Налаштування','cfg.saved':'✓ Збережено','cfg.close':'Закрити','cfg.save':'Зберегти',
    'dir.title':'Новий проект','toast.loading':'Завантаження...',
    'scroll.down':'Прокрутити вниз',
    'at.search':'Пошук файлу...',
    'reply.cancel':'Скасувати відповідь',
    'stop.agent':'Зупинити агента',
    'send.msg':'Надіслати (Enter)',
    'dir.cancel':'Скасувати',
    'confirm.stop.h':'Зупинити завдання?',
    'confirm.stop.yes':'Так, зупинити',
    'confirm.stop.cancel':'Скасувати',
    'copy.code':'Копіювати',
    'copy.msg':'Копіювати',
    'msg.reply':'Відповісти',
    'fork.title':'Продовжити в новому чаті',
    'use.input':'Вставити в поле вводу',
    'tab.new':'Новий чат',
    'you.label':'Ви',
    'err.stop.switch':'Зупиніть агента перед переключенням',
    'err.stop.close':'Зупиніть агента перед закриттям',
    'err.stop.new':'Зупиніть агента перед відкриттям нового чату',
    'err.stop.project':'Зупиніть агента перед зміною проекту',
    'queue.cancel':'Скасувати','queue.save':'Зберегти',
    'proj.deactivated':'Проект деактивовано',
    'load.more':'↑ Завантажити попередні повідомлення',
    'logout.confirm':'Вийти з системи?\n\nВсі активні сесії залишаться збережені.',
    'proj.delete.confirm':'Видалити проект "{{name}}"?\n\nДиректорія НЕ буде видалена.',
    'proj.active':'● Активний','proj.inactive':'○ Не активний',
    'proj.active.title':'Активний проект','proj.click.title':'Клік — активувати',
    'proj.del.title':'Видалити проект','proj.rename.title':'Перейменувати проект',
    'chip.remove':'Видалити',
    'attach.file':'Додати файл (📎)',
    'queue.label':'У черзі','queue.edit.title':'Редагувати повідомлення','queue.del.title':'Видалити з черги',
    'agents.title':'Активні агенти',
    'sess.delete.confirm':'Видалити сесію?','sess.delete.tasks':'Видалити сесію?\n\nДо неї прив\'язано завдань у Kanban: {n}. Вони також будуть видалені.','sess.load.err':'Помилка завантаження сесії',
    'mcp.active':'● Активний у чаті','mcp.inactive':'○ Вимкнений','mcp.del.title':'Видалити сервер','mcp.del.confirm':'Видалити сервер',
    'mcp.cfg.tip':'Налаштування','mcp.cfg.warn':'Потрібна конфігурація',
    'mcp.toggle.on':'Клік — вимкнути','mcp.toggle.off':'Клік — увімкнути',
    'mcp.cfg.api_warn':'⚠ Вкажіть API ключі для активації',
    'mcp.cfg.no_params':'Немає параметрів для налаштування',
    'mcp.cfg.saved':'✓ Налаштування збережено','mcp.cfg.save_err':'Помилка збереження',
    'mcp.cfg.cancel':'Скасувати','mcp.cfg.save':'Зберегти',
    'mcp.add.id_req':'ID обов\'язковий','mcp.add.url_req':'URL обов\'язковий',
    'mcp.add.cmd_req':'Команда обов\'язкова','mcp.add.ok':'✓ MCP сервер додано',
        'skill.active':'● У системному промпті','skill.inactive':'○ Не активний','skill.del.title':'Видалити skill','skill.name_prompt':'Назва скілу:',
    'skills.auto_hint':'⚡ Навички обираються автоматично по тексту задачі',
    'auto.title.on':'⚡ Auto-Skills: увімкнено — клік для вимкнення',
    'auto.title.off':'⚡ Auto-Skills: вимкнено — клік для увімкнення',
    'status.connected':'Підключено','status.generating':'Генерація…','status.thinking':'Обдумування...','status.processing':'Обробка...','status.reconnecting':'Перепідключення…','status.stopped':'Зупинено','status.error':'Помилка',
    'fpv.download':'Завантажити','fpv.download.title':'Завантажити файл','fpv.share':'Поділитись','fpv.share.title':'Поділитись / Скопіювати посилання','fpv.binary':'Бінарний файл — перегляд недоступний','fpv.img_error':'Помилка завантаження зображення','fpv.load_error':'Помилка завантаження файлу',
    'toast.no_connection':'Немає з\'єднання','toast.sess_not_found':'Сесію не знайдено','toast.cfg_load_err':'Помилка завантаження конфігурації','toast.skill_uploaded':'✓ Скіл завантажено','toast.link_copied':'✓ Посилання скопійовано','toast.select_dir':'Виберіть директорію','toast.link_prompt':'Скопіюйте посилання:',
    'at.no_project':'Оберіть проект, щоб шукати файли','at.searching':'Пошук...','at.search_err':'Помилка пошуку','at.no_files':'Файлів не знайдено',
    'dir.this_dir':'. (ця директорія)','dir.no_subdirs':'Немає підпапок',
    'toast.read_err':'Не вдалося прочитати: ','toast.err_prefix':'Помилка: ','dir.proj_name':'Назва проекту (авто якщо порожньо)',
    'welcome.prompt.1':'Поясни цей код крок за кроком','welcome.prompt.2':'Знайди та виправ помилки','welcome.prompt.3':'Напиши unit-тести','welcome.prompt.4':'Спроектуй архітектуру',
    'toast.task_resumed':'Задачу відновлено','toast.task_lost':'З\'єднання втрачено, вивід недоступний','toast.task_retry':'retry',
    'ask.submit':'Надіслати відповідь','ask.skip':'Пропустити','ask.answered':'Відповідь','ask.skipped':'Пропущено','ask.timer':'Залишилось','ask.other':'Інше...','ask.prev':'← Назад','ask.next':'Далі →',
    'session.copy_id':'Скопіювати ID сесії Claude','session.open_claude':'Відкрити в Claude Code',
    'stream.interrupted':'Відповідь була перервана',
    'rl.title.warn':'Наближається ліміт','rl.title.crit':'Ліміт вичерпується!',
    'rl.key.type':'Тип','rl.key.used':'Використано','rl.key.left':'Залишилось','rl.key.reset':'Скидання','rl.key.via':'Через',
    'rl.reset.done':'вже скинуто','rl.time.h':'г','rl.time.m':'хв','rl.time.s':'с',
    'rl.toast.80':'⚠️ {type} ліміт: використано 80%','rl.toast.90':'🔶 {type} ліміт: залишилось 10%!','rl.toast.95':'🚫 {type} ліміт майже вичерпано!',
    'rl.modal.title':'Ліміт вичерпано','rl.modal.desc':'Ваш {type} ліміт Claude Max вичерпано. Нові запити заблоковані до скидання.','rl.modal.reset':'Скидання через:','rl.modal.ok':'Зрозуміло',
    'rl.notify.title':'Claude Max — ліміт','rl.notify.body':'{type} ліміт: використано {pct}%',
    'queue.badge':'{n} у черзі',
    'ver.current':'Поточна версія','ver.update':'Доступне оновлення {tag}!\nЗапустіть: npx github:Lexus2016/claude-code-studio','ver.latest':' — остання версія ✓','ver.checking':'Перевірка версії...',
    'status.connecting':'Підключення...',
    'toast.cmd_copied':'✓ Команду скопійовано','toast.json_req':'Потрібен .json файл','toast.json_enter':'Введіть або завантажте JSON',
    'toast.mcp_imported':'✓ Імпортовано {n} MCP серверів','toast.mcp_import_err':'Помилка імпорту: ','toast.mcp_export_err':'Помилка експорту',
    'skill.toggle.on':'Клік — вимкнути skill','skill.toggle.off':'Клік — додати skill до системного промпту',
    'files.empty':'Порожньо','files.view':'Переглянути',
    'proj.empty':'Немає проектів. Додайте директорію для роботи з Claude Code.',
    'proj.search':'Пошук проекту...','search.empty':'Не знайдено',
    'nav.chat.tip':'Чат','nav.kanban.tip':'Kanban дошка','nav.aria':'Навігація між розділами','tip.lang':'Мова інтерфейсу',
    'mcp.import.btn':'Імпорт','mcp.import.title':'Імпортувати MCP з JSON файлу (Claude Desktop формат)',
    'mcp.export.btn':'Експорт','mcp.export.title':'Експортувати всі MCP у JSON файл','mcp.replace.title':'Замінить існуючий',
    'mcp.type.stdio':'stdio (команда)','mcp.type.sse':'SSE (URL потік)',
    'mcp.import.modal.title':'Імпорт MCP серверів',
    'mcp.import.drop':'Перетягніть .json файл або натисніть для вибору',
    'mcp.import.or':'— або вставте JSON вручну —',
    'mcp.import.found':'Знайдено серверів:',
    'mcp.import.replace':'Замінити існуючі кастомні сервери (інакше — злиття)',
    'mcp.import.preview.btn':'👁 Перегляд',
    'mcp.import.do':'Імпортувати',
    'dir.name.label':'Назва:',
    'dir.git.init':'git init (якщо ще не репозиторій)',
    'confirm.stop.desc':'Виконання агента буде перервано.',
    'rl.type.five_hour':'5-годинний','rl.type.seven_day':'7-денний',
    'proj.generating':'Генерація у фоні...',
    'mcp.parse.no_servers':'Не вдалося знайти MCP сервери. Очікується {"mcpServers":{...}} або сумісний формат.',
    'mcp.parse.empty':'Список серверів порожній',
    'mcp.cfg.env_json_err':'Невірний формат ENV JSON',
    'agent.planning':'🧠 Планування...','agent.fallback_single':'⚠️ Перехід до одиночного режиму','agent.done':'✅ Всі агенти завершили','agent.circular_deps':'⚠️ Кругова залежність між агентами',
    'msf.working':'Працює','msf.done':'Готово','msf.error':'Помилка','msf.waiting':'Очікування',
    'ta.calls':'операцій','ta.activity':'Активність',
    'msf.team':'Команда агентів',
    'hdr.toggle':'Згорнути/розгорнути панель','msg.show_more':'Показати більше','msg.show_less':'Показати менше',
  },
  en: {
    'sec.proactive':'Status',
    'sec.chats':'Chats','sec.mcp':'MCP',
    'mcp.hint':'Enable tools that Claude can use in this chat.',
    'mcp.add':'＋ Add MCP server','mcp.id':'ID (e.g. my-server)','mcp.label':'Label',
    'mcp.cmd':'Command (e.g. npx)','mcp.args':'Args comma-separated','mcp.add_btn':'Add',
    'sec.skills':'Skills','skills.hint':'Skills are instruction files added to the system prompt.',
    'skills.upload':'＋ Upload .md file','sec.projects':'Projects','proj.add':'＋ Add project',
    'tip.new':'New chat','tip.cfg':'Configuration','tip.logout':'Logout',
    'tip.panels.left':'Toggle left panel','tip.panels.right':'Toggle right panel',
    'btn.new':'Chat','tb.mode':'Mode','tb.agent':'Agent','tb.model':'Model','tb.turns':'Turns',
    'welcome.title':'New session','welcome.ready':'Ready to work',
    'welcome.desc':'Choose MCP and Skills on the left, files on the right.',
    'input.ph':'Write a task... Paste screenshot (Ctrl+V) · @ for project files · 📎 for any files',
    'files.title':'Workspace','files.refresh':'Refresh','queue.title':'Tasks waiting in queue',
    'cfg.title':'Configuration','cfg.saved':'✓ Saved','cfg.close':'Close','cfg.save':'Save',
    'dir.title':'New project','toast.loading':'Loading...',
    'scroll.down':'Scroll to bottom',
    'at.search':'Search file...',
    'reply.cancel':'Cancel reply',
    'stop.agent':'Stop agent',
    'send.msg':'Send (Enter)',
    'dir.cancel':'Cancel',
    'confirm.stop.h':'Stop task?',
    'confirm.stop.yes':'Yes, stop',
    'confirm.stop.cancel':'Cancel',
    'copy.code':'Copy',
    'copy.msg':'Copy',
    'msg.reply':'Reply',
    'fork.title':'Continue in new chat',
    'use.input':'Insert into input field',
    'tab.new':'New chat',
    'you.label':'You',
    'err.stop.switch':'Stop agent before switching',
    'err.stop.close':'Stop agent before closing',
    'err.stop.new':'Stop agent before opening a new chat',
    'err.stop.project':'Stop agent before switching project',
    'queue.cancel':'Cancel','queue.save':'Save',
    'proj.deactivated':'Project deactivated',
    'load.more':'↑ Load previous messages',
    'logout.confirm':'Sign out?\n\nAll active sessions will remain saved.',
    'proj.delete.confirm':'Delete project "{{name}}"?\n\nThe directory will NOT be deleted.',
    'proj.active':'● Active','proj.inactive':'○ Inactive',
    'proj.active.title':'Active project','proj.click.title':'Click to activate',
    'proj.del.title':'Delete project','proj.rename.title':'Rename project',
    'chip.remove':'Remove',
    'attach.file':'Attach file (📎)',
    'queue.label':'In queue','queue.edit.title':'Edit message','queue.del.title':'Remove from queue',
    'agents.title':'Active agents',
    'sess.delete.confirm':'Delete session?','sess.delete.tasks':'Delete session?\n\nLinked Kanban tasks: {n}. They will also be deleted.','sess.load.err':'Error loading session',
    'mcp.active':'● Active in chat','mcp.inactive':'○ Disabled','mcp.del.title':'Remove server','mcp.del.confirm':'Remove server',
    'mcp.cfg.tip':'Settings','mcp.cfg.warn':'Configuration required',
    'mcp.toggle.on':'Click to disable','mcp.toggle.off':'Click to enable',
    'mcp.cfg.api_warn':'⚠ Set API keys to enable',
    'mcp.cfg.no_params':'No parameters to configure',
    'mcp.cfg.saved':'✓ Settings saved','mcp.cfg.save_err':'Save error',
    'mcp.cfg.cancel':'Cancel','mcp.cfg.save':'Save',
    'mcp.add.id_req':'ID is required','mcp.add.url_req':'URL is required',
    'mcp.add.cmd_req':'Command is required','mcp.add.ok':'✓ MCP server added',
        'skill.active':'● In system prompt','skill.inactive':'○ Inactive','skill.del.title':'Remove skill','skill.name_prompt':'Skill name:',
    'skills.auto_hint':'⚡ Skills are auto-selected based on task text',
    'auto.title.on':'⚡ Auto-Skills: enabled — click to disable',
    'auto.title.off':'⚡ Auto-Skills: disabled — click to enable',
    'status.connected':'Connected','status.generating':'Generating…','status.thinking':'Thinking...','status.processing':'Processing...','status.reconnecting':'Reconnecting…','status.stopped':'Stopped','status.error':'Error',
    'fpv.download':'Download','fpv.download.title':'Download file','fpv.share':'Share','fpv.share.title':'Share / Copy link','fpv.binary':'Binary file — preview not available','fpv.img_error':'Image load error','fpv.load_error':'File load error',
    'toast.no_connection':'No connection','toast.sess_not_found':'Session not found','toast.cfg_load_err':'Config load error','toast.skill_uploaded':'✓ Skill uploaded','toast.link_copied':'✓ Link copied','toast.select_dir':'Select a directory','toast.link_prompt':'Copy link:',
    'at.no_project':'Select a project to search files','at.searching':'Searching...','at.search_err':'Search error','at.no_files':'No files found',
    'dir.this_dir':'. (this directory)','dir.no_subdirs':'No subdirectories',
    'toast.read_err':'Failed to read: ','toast.err_prefix':'Error: ','dir.proj_name':'Project name (auto if empty)',
    'welcome.prompt.1':'Explain this code step by step','welcome.prompt.2':'Find and fix bugs','welcome.prompt.3':'Write unit tests','welcome.prompt.4':'Design the architecture',
    'toast.task_resumed':'Task resumed','toast.task_lost':'Connection lost, output unavailable','toast.task_retry':'retry',
    'ask.submit':'Send Answer','ask.skip':'Skip','ask.answered':'Answer','ask.skipped':'Skipped','ask.timer':'Remaining','ask.other':'Other...','ask.prev':'← Back','ask.next':'Next →',
    'session.copy_id':'Copy Claude session ID','session.open_claude':'Open in Claude Code',
    'stream.interrupted':'Response was interrupted',
    'rl.title.warn':'Limit approaching','rl.title.crit':'Limit critical!',
    'rl.key.type':'Type','rl.key.used':'Used','rl.key.left':'Left','rl.key.reset':'Resets','rl.key.via':'In',
    'rl.reset.done':'already reset','rl.time.h':'h','rl.time.m':'m','rl.time.s':'s',
    'rl.toast.80':'⚠️ {type} limit: 80% used','rl.toast.90':'🔶 {type} limit: only 10% left!','rl.toast.95':'🚫 {type} limit almost exhausted!',
    'rl.modal.title':'Limit exhausted','rl.modal.desc':'Your {type} Claude Max limit has been exhausted. New requests are blocked until reset.','rl.modal.reset':'Resets in:','rl.modal.ok':'Got it',
    'rl.notify.title':'Claude Max — limit','rl.notify.body':'{type} limit: {pct}% used',
    'queue.badge':'{n} in queue',
    'ver.current':'Current version','ver.update':'Update available {tag}!\nRun: npx github:Lexus2016/claude-code-studio','ver.latest':' — latest ✓','ver.checking':'Checking version...',
    'status.connecting':'Connecting...',
    'toast.cmd_copied':'✓ Command copied','toast.json_req':'.json file required','toast.json_enter':'Enter or upload JSON',
    'toast.mcp_imported':'✓ {n} MCP servers imported','toast.mcp_import_err':'Import error: ','toast.mcp_export_err':'Export error',
    'skill.toggle.on':'Click to disable skill','skill.toggle.off':'Click to add skill to system prompt',
    'files.empty':'Empty','files.view':'Preview',
    'proj.empty':'No projects. Add a directory to work with Claude Code.',
    'proj.search':'Search project...','search.empty':'Not found',
    'nav.chat.tip':'Chat','nav.kanban.tip':'Kanban board','nav.aria':'Navigation','tip.lang':'Interface language',
    'mcp.import.btn':'Import','mcp.import.title':'Import MCP from JSON file (Claude Desktop format)',
    'mcp.export.btn':'Export','mcp.export.title':'Export all MCP to JSON file','mcp.replace.title':'Will replace existing',
    'mcp.type.stdio':'stdio (command)','mcp.type.sse':'SSE (URL stream)',
    'mcp.import.modal.title':'Import MCP servers',
    'mcp.import.drop':'Drag .json file or click to browse',
    'mcp.import.or':'— or paste JSON manually —',
    'mcp.import.found':'Servers found:',
    'mcp.import.replace':'Replace existing custom servers (otherwise — merge)',
    'mcp.import.preview.btn':'👁 Preview',
    'mcp.import.do':'Import',
    'dir.name.label':'Name:',
    'dir.git.init':'git init (if not already a repository)',
    'confirm.stop.desc':'Agent execution will be interrupted.',
    'rl.type.five_hour':'5-hour','rl.type.seven_day':'7-day',
    'proj.generating':'Generating in background...',
    'mcp.parse.no_servers':'Could not find MCP servers. Expected {"mcpServers":{...}} or compatible format.',
    'mcp.parse.empty':'Server list is empty',
    'mcp.cfg.env_json_err':'Invalid ENV JSON format',
    'agent.planning':'🧠 Planning...','agent.fallback_single':'⚠️ Falling back to single mode','agent.done':'✅ All agents done','agent.circular_deps':'⚠️ Circular dependency between agents',
    'msf.working':'Working','msf.done':'Done','msf.error':'Error','msf.waiting':'Waiting',
    'ta.calls':'calls','ta.activity':'Activity',
    'msf.team':'Agent Team',
    'hdr.toggle':'Collapse/expand header','msg.show_more':'Show more','msg.show_less':'Show less',
  },
  ru: {
    'sec.proactive':'Статус',
    'sec.chats':'Чаты','sec.mcp':'MCP',
    'mcp.hint':'Включите инструменты, которые Claude может использовать в этом чате.',
    'mcp.add':'＋ Добавить MCP-сервер','mcp.id':'ID (напр. my-server)','mcp.label':'Название',
    'mcp.cmd':'Команда (напр. npx)','mcp.args':'Аргументы через запятую','mcp.add_btn':'Добавить',
    'sec.skills':'Навыки','skills.hint':'Навыки — файлы инструкций, добавляемые в системный промпт.',
    'skills.upload':'＋ Загрузить .md файл','sec.projects':'Проекты','proj.add':'＋ Добавить проект',
    'tip.new':'Новый чат','tip.cfg':'Настройки','tip.logout':'Выйти',
    'tip.panels.left':'Скрыть/показать левую панель','tip.panels.right':'Скрыть/показать правую панель',
    'btn.new':'Чат','tb.mode':'Режим','tb.agent':'Агент','tb.model':'Модель','tb.turns':'Шаги',
    'welcome.title':'Новая сессия','welcome.ready':'Готов к работе',
    'welcome.desc':'Выберите MCP и Навыки слева, файлы — справа.',
    'input.ph':'Напишите задание... Вставьте скриншот (Ctrl+V) · @ для файлов проекта · 📎 для любых файлов',
    'files.title':'Рабочая директория','files.refresh':'Обновить','queue.title':'Задач в очереди',
    'cfg.title':'Настройки','cfg.saved':'✓ Сохранено','cfg.close':'Закрыть','cfg.save':'Сохранить',
    'dir.title':'Новый проект','toast.loading':'Загрузка...',
    'scroll.down':'Прокрутить вниз',
    'at.search':'Поиск файла...',
    'reply.cancel':'Отменить ответ',
    'stop.agent':'Остановить агента',
    'send.msg':'Отправить (Enter)',
    'dir.cancel':'Отмена',
    'confirm.stop.h':'Остановить задание?',
    'confirm.stop.yes':'Да, остановить',
    'confirm.stop.cancel':'Отмена',
    'copy.code':'Копировать',
    'copy.msg':'Копировать',
    'msg.reply':'Ответить',
    'fork.title':'Продолжить в новом чате',
    'use.input':'Вставить в поле ввода',
    'tab.new':'Новый чат',
    'you.label':'Вы',
    'err.stop.switch':'Остановите агента перед переключением',
    'err.stop.close':'Остановите агента перед закрытием',
    'err.stop.new':'Остановите агента перед открытием нового чата',
    'err.stop.project':'Остановите агента перед сменой проекта',
    'queue.cancel':'Отмена','queue.save':'Сохранить',
    'proj.deactivated':'Проект деактивирован',
    'load.more':'↑ Загрузить предыдущие сообщения',
    'logout.confirm':'Выйти из системы?\n\nВсе активные сессии останутся сохранены.',
    'proj.delete.confirm':'Удалить проект "{{name}}"?\n\nДиректория НЕ будет удалена.',
    'proj.active':'● Активен','proj.inactive':'○ Не активен',
    'proj.active.title':'Активный проект','proj.click.title':'Клик — активировать',
    'proj.del.title':'Удалить проект','proj.rename.title':'Переименовать проект',
    'chip.remove':'Удалить',
    'attach.file':'Прикрепить файл (📎)',
    'queue.label':'В очереди','queue.edit.title':'Редактировать сообщение','queue.del.title':'Удалить из очереди',
    'agents.title':'Активные агенты',
    'sess.delete.confirm':'Удалить сессию?','sess.delete.tasks':'Удалить сессию?\n\nПривязанных задач в Kanban: {n}. Они также будут удалены.','sess.load.err':'Ошибка загрузки сессии',
    'mcp.active':'● Активен в чате','mcp.inactive':'○ Отключен','mcp.del.title':'Удалить сервер','mcp.del.confirm':'Удалить сервер',
    'mcp.cfg.tip':'Настройки','mcp.cfg.warn':'Требуется настройка',
    'mcp.toggle.on':'Клик — отключить','mcp.toggle.off':'Клик — включить',
    'mcp.cfg.api_warn':'⚠ Укажите API ключи для активации',
    'mcp.cfg.no_params':'Нет параметров для настройки',
    'mcp.cfg.saved':'✓ Настройки сохранены','mcp.cfg.save_err':'Ошибка сохранения',
    'mcp.cfg.cancel':'Отмена','mcp.cfg.save':'Сохранить',
    'mcp.add.id_req':'ID обязателен','mcp.add.url_req':'URL обязателен',
    'mcp.add.cmd_req':'Команда обязательна','mcp.add.ok':'✓ MCP сервер добавлен',
        'skill.active':'● В системном промпте','skill.inactive':'○ Неактивен','skill.del.title':'Удалить skill','skill.name_prompt':'Название навыка:',
    'skills.auto_hint':'⚡ Навыки выбираются автоматически по тексту задачи',
    'auto.title.on':'⚡ Auto-Skills: включено — клик для отключения',
    'auto.title.off':'⚡ Auto-Skills: отключено — клик для включения',
    'status.connected':'Подключено','status.generating':'Генерация…','status.thinking':'Обдумывание...','status.processing':'Обработка...','status.reconnecting':'Переподключение…','status.stopped':'Остановлено','status.error':'Ошибка',
    'fpv.download':'Скачать','fpv.download.title':'Скачать файл','fpv.share':'Поделиться','fpv.share.title':'Поделиться / Скопировать ссылку','fpv.binary':'Бинарный файл — предпросмотр недоступен','fpv.img_error':'Ошибка загрузки изображения','fpv.load_error':'Ошибка загрузки файла',
    'toast.no_connection':'Нет соединения','toast.sess_not_found':'Сессия не найдена','toast.cfg_load_err':'Ошибка загрузки конфигурации','toast.skill_uploaded':'✓ Навык загружен','toast.link_copied':'✓ Ссылка скопирована','toast.select_dir':'Выберите директорию','toast.link_prompt':'Скопируйте ссылку:',
    'at.no_project':'Выберите проект для поиска файлов','at.searching':'Поиск...','at.search_err':'Ошибка поиска','at.no_files':'Файлов не найдено',
    'dir.this_dir':'. (эта директория)','dir.no_subdirs':'Нет подпапок',
    'toast.read_err':'Не удалось прочитать: ','toast.err_prefix':'Ошибка: ','dir.proj_name':'Название проекта (авто если пусто)',
    'welcome.prompt.1':'Объясни этот код шаг за шагом','welcome.prompt.2':'Найди и исправь ошибки','welcome.prompt.3':'Напиши unit-тесты','welcome.prompt.4':'Спроектируй архитектуру',
    'toast.task_resumed':'Задача возобновлена','toast.task_lost':'Соединение потеряно, вывод недоступен','toast.task_retry':'retry',
    'ask.submit':'Отправить ответ','ask.skip':'Пропустить','ask.answered':'Ответ','ask.skipped':'Пропущено','ask.timer':'Осталось','ask.other':'Другое...','ask.prev':'← Назад','ask.next':'Далее →',
    'session.copy_id':'Скопировать ID сессии Claude','session.open_claude':'Открыть в Claude Code',
    'stream.interrupted':'Ответ был прерван',
    'rl.title.warn':'Приближается лимит','rl.title.crit':'Лимит исчерпывается!',
    'rl.key.type':'Тип','rl.key.used':'Использовано','rl.key.left':'Осталось','rl.key.reset':'Сброс','rl.key.via':'Через',
    'rl.reset.done':'уже сброшен','rl.time.h':'ч','rl.time.m':'м','rl.time.s':'с',
    'rl.toast.80':'⚠️ {type} лимит: использовано 80%','rl.toast.90':'🔶 {type} лимит: осталось 10%!','rl.toast.95':'🚫 {type} лимит почти исчерпан!',
    'rl.modal.title':'Лимит исчерпан','rl.modal.desc':'Ваш {type} лимит Claude Max исчерпан. Новые запросы заблокированы до сброса.','rl.modal.reset':'Сброс через:','rl.modal.ok':'Понятно',
    'rl.notify.title':'Claude Max — лимит','rl.notify.body':'{type} лимит: использовано {pct}%',
    'queue.badge':'{n} в очереди',
    'ver.current':'Текущая версия','ver.update':'Доступно обновление {tag}!\nЗапустите: npx github:Lexus2016/claude-code-studio','ver.latest':' — последняя ✓','ver.checking':'Проверка версии...',
    'status.connecting':'Подключение...',
    'toast.cmd_copied':'✓ Команда скопирована','toast.json_req':'Требуется .json файл','toast.json_enter':'Введите или загрузите JSON',
    'toast.mcp_imported':'✓ Импортировано {n} MCP серверов','toast.mcp_import_err':'Ошибка импорта: ','toast.mcp_export_err':'Ошибка экспорта',
    'skill.toggle.on':'Клик — отключить навык','skill.toggle.off':'Клик — добавить навык в системный промпт',
    'files.empty':'Пусто','files.view':'Просмотр',
    'proj.empty':'Нет проектов. Добавьте директорию для работы с Claude Code.',
    'proj.search':'Поиск проекта...','search.empty':'Не найдено',
    'nav.chat.tip':'Чат','nav.kanban.tip':'Kanban доска','nav.aria':'Навигация','tip.lang':'Язык интерфейса',
    'mcp.import.btn':'Импорт','mcp.import.title':'Импортировать MCP из JSON файла (формат Claude Desktop)',
    'mcp.export.btn':'Экспорт','mcp.export.title':'Экспортировать все MCP в JSON файл','mcp.replace.title':'Заменит существующий',
    'mcp.type.stdio':'stdio (команда)','mcp.type.sse':'SSE (URL поток)',
    'mcp.import.modal.title':'Импорт MCP серверов',
    'mcp.import.drop':'Перетащите .json файл или нажмите для выбора',
    'mcp.import.or':'— или вставьте JSON вручную —',
    'mcp.import.found':'Найдено серверов:',
    'mcp.import.replace':'Заменить существующие серверы (иначе — слияние)',
    'mcp.import.preview.btn':'👁 Предпросмотр',
    'mcp.import.do':'Импортировать',
    'dir.name.label':'Название:',
    'dir.git.init':'git init (если ещё не репозиторий)',
    'confirm.stop.desc':'Выполнение агента будет прервано.',
    'rl.type.five_hour':'5-часовой','rl.type.seven_day':'7-дневный',
    'proj.generating':'Генерация в фоне...',
    'mcp.parse.no_servers':'Не удалось найти MCP серверы. Ожидается {"mcpServers":{...}} или совместимый формат.',
    'mcp.parse.empty':'Список серверов пуст',
    'mcp.cfg.env_json_err':'Неверный формат ENV JSON',
    'agent.planning':'🧠 Планирование...','agent.fallback_single':'⚠️ Переход в одиночный режим','agent.done':'✅ Все агенты завершили','agent.circular_deps':'⚠️ Циклическая зависимость между агентами',
    'msf.working':'Работает','msf.done':'Готово','msf.error':'Ошибка','msf.waiting':'Ожидание',
    'ta.calls':'операций','ta.activity':'Активность',
    'msf.team':'Команда агентов',
    'hdr.toggle':'Свернуть/развернуть панель','msg.show_more':'Показать больше','msg.show_less':'Показать меньше',
  }
};
function t(key) {
  const lang = localStorage.getItem('lang') || 'uk';
  return (TRANSLATIONS[lang] || TRANSLATIONS.uk)[key] || key;
}
function setLang(lang) {
  const t = TRANSLATIONS[lang] || TRANSLATIONS.uk;
  localStorage.setItem('lang', lang);
  const sel = $i('langSel'); if (sel) sel.value = lang;
  document.documentElement.lang = lang;
  document.querySelectorAll('[data-i18n]').forEach(el => { const k = el.getAttribute('data-i18n'); if (t[k] !== undefined) el.textContent = t[k]; });
  document.querySelectorAll('[data-i18n-ph]').forEach(el => { const k = el.getAttribute('data-i18n-ph'); if (t[k] !== undefined) el.placeholder = t[k]; });
  document.querySelectorAll('[data-i18n-tip]').forEach(el => { const k = el.getAttribute('data-i18n-tip'); if (t[k] !== undefined) el.setAttribute('data-tip', t[k]); });
  document.querySelectorAll('[data-i18n-title]').forEach(el => { const k = el.getAttribute('data-i18n-title'); if (t[k] !== undefined) el.title = t[k]; });
  document.querySelectorAll('[data-i18n-aria]').forEach(el => { const k = el.getAttribute('data-i18n-aria'); if (t[k] !== undefined) el.setAttribute('aria-label', t[k]); });
}

// ─── Auth ─────────────────────────────────────────────────────────────────
(async () => {
  const r = await fetch('/api/auth/status');
  const d = await r.json();
  if (!d.loggedIn) window.location.href = d.setupDone ? '/login' : '/setup';
})();

async function logout() {
  if (!confirm(t('logout.confirm'))) return;
  await fetch('/api/auth/logout', { method: 'POST' });
  window.location.href = '/login';
}

// ─── Toast ────────────────────────────────────────────────────────────────
let toastTimer = null;
function toast(msg, isErr = false, dur = 3000) {
  const el = $i('toast');
  el.textContent = msg;
  el.className = 'show' + (isErr ? ' toast-err' : '');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => el.className = '', dur);
}

// ─── Notifications (non-blocking, from notify_user MCP) ──────────────────
const NOTIF_MAX_VISIBLE = 5;
const NOTIF_ICONS = { info: 'ℹ️', warning: '⚠️', error: '❌', milestone: '✅', progress: '📊' };
const NOTIF_DURATIONS = { info: 5000, warning: 15000, error: 0, milestone: 8000, progress: 10000 };

function showNotification(data) {
  const container = $i('notifContainer');
  if (!container) return;

  const level = data.level || 'info';
  const icon = NOTIF_ICONS[level] || 'ℹ️';
  const dur = NOTIF_DURATIONS[level] ?? 5000;

  // Update existing progress card in-place instead of spawning a new one
  if (level === 'progress' && data.progress) {
    const existing = container.querySelector('.notif-card.notif-progress:not(.notif-out)');
    if (existing) {
      const pct = data.progress.total > 0 ? Math.min(100, Math.round((data.progress.current / data.progress.total) * 100)) : 0;
      const fill = existing.querySelector('.notif-progress-fill');
      const text = existing.querySelector('.notif-progress-text');
      const titleEl = existing.querySelector('.notif-title');
      if (fill) fill.style.width = pct + '%';
      if (text) text.textContent = `${data.progress.current} / ${data.progress.total}`;
      if (titleEl) titleEl.textContent = data.title || '';
      if (data.detail) {
        const det = existing.querySelector('.notif-detail');
        if (det) det.textContent = data.detail;
      }
      return;
    }
  }

  const card = document.createElement('div');
  card.className = `notif-card notif-${level}`;
  card.dataset.ts = String(data.timestamp || Date.now());

  let html = `<div class="notif-header">`;
  html += `<span class="notif-icon">${icon}</span>`;
  html += `<span class="notif-title">${escH(data.title || '')}</span>`;
  html += `<button class="notif-close" title="Dismiss">&times;</button>`;
  html += `</div>`;

  if (data.detail) {
    html += `<div class="notif-detail">${escH(data.detail)}</div>`;
  }

  if (level === 'progress' && data.progress) {
    const pct = data.progress.total > 0 ? Math.min(100, Math.round((data.progress.current / data.progress.total) * 100)) : 0;
    html += `<div class="notif-progress-bar"><div class="notif-progress-fill" style="width:${pct}%"></div></div>`;
    html += `<div class="notif-progress-text">${data.progress.current} / ${data.progress.total}</div>`;
  }

  card.innerHTML = html;

  // Dismiss handler
  const dismiss = () => {
    card.classList.add('notif-out');
    setTimeout(() => card.remove(), 300);
  };
  card.querySelector('.notif-close').addEventListener('click', dismiss);

  // Auto-dismiss (unless dur === 0 = manual dismiss only)
  if (dur > 0) setTimeout(dismiss, dur);

  container.appendChild(card);

  // Enforce max visible: remove oldest if over limit
  const cards = container.querySelectorAll('.notif-card:not(.notif-out)');
  if (cards.length > NOTIF_MAX_VISIBLE) {
    const oldest = cards[0];
    oldest.classList.add('notif-out');
    setTimeout(() => oldest.remove(), 300);
  }
}

// ─── Markdown renderer ───────────────────────────────────────────────────
function escH(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

// Parse a captured block of list lines (bullet or ordered, any indentation level)
function parseListBlock(blockText) {
  const lines = blockText.trimEnd().split('\n')
    .filter(l => /^\s*(?:[-*+]|\d+\.)\s/.test(l));
  if (!lines.length) return blockText;

  function getIndent(line) {
    return (line.match(/^(\s*)/) || [''])[1].length;
  }

  function buildList(arr) {
    if (!arr.length) return '';
    const baseInd = getIndent(arr[0]);
    const isOl = /^\s*\d+\./.test(arr[0]);
    const tag = isOl ? 'ol' : 'ul';
    const items = [];
    let i = 0;
    while (i < arr.length) {
      const ind = getIndent(arr[i]);
      if (ind < baseInd) break;
      if (ind > baseInd) { i++; continue; }
      const text = arr[i].replace(/^\s*(?:[-*+]|\d+\.)\s+/, '');
      i++;
      const nested = [];
      while (i < arr.length && getIndent(arr[i]) > ind) nested.push(arr[i++]);
      items.push('<li>' + text + (nested.length ? buildList(nested) : '') + '</li>');
    }
    return items.length ? `<${tag}>${items.join('')}</${tag}>` : '';
  }

  return buildList(lines);
}

// Pre-process: detect inline numbered items "1) text, 2) text, 3) text"
// and reformat as standard markdown list "1. text\n2. text\n3. text"
function reformatInlineNumberedItems(text) {
  return text.split('\n').map(line => {
    const regex = /\b(\d+)\)\s+/g;
    const matches = [...line.matchAll(regex)];
    if (matches.length < 2) return line;
    const nums = matches.map(m => parseInt(m[1]));
    if (nums[0] !== 1) return line;
    const prefix = line.substring(0, matches[0].index).trimEnd();
    const items = [];
    for (let i = 0; i < matches.length; i++) {
      const start = matches[i].index + matches[i][0].length;
      const end = i + 1 < matches.length ? matches[i + 1].index : line.length;
      let itemText = line.substring(start, end).trim();
      itemText = itemText.replace(/[,;]\s*$/, '');
      items.push(`${nums[i]}. ${itemText}`);
    }
    const parts = [];
    if (prefix) parts.push(prefix);
    parts.push(...items);
    return parts.join('\n');
  }).join('\n');
}

function renderMd(text) {
  if (!text) return '';

  // 0. Normalize line endings (\r\n → \n)
  text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

  // 0.5. Reformat inline numbered items into proper markdown list
  text = reformatInlineNumberedItems(text);

  // 1. Extract and protect code blocks
  const blocks = [];
  text = text.replace(/```(\w*)\r?\n?([\s\S]*?)```/g, (_, lang, code) => {
    const idx = blocks.length;
    blocks.push({ lang: lang.trim(), code: code.replace(/\n$/, '') });
    return `\x02BLOCK${idx}\x03`;
  });

  // 2. Escape remaining HTML
  text = escH(text);

  // 2.5. Extract inline code BEFORE bold/italic to protect underscores in filenames
  const inlineCodes = [];
  text = text.replace(/`([^`\n]+)`/g, (_, code) => {
    const idx = inlineCodes.length;
    inlineCodes.push(code);
    return `\x04ICODE${idx}\x05`;
  });

  // 3. Block elements (order matters)
  // Headers (h6→h1 order to avoid partial matches)
  text = text.replace(/^#{6}\s+(.+)$/gm, '<h6>$1</h6>');
  text = text.replace(/^#{5}\s+(.+)$/gm, '<h5>$1</h5>');
  text = text.replace(/^#{4}\s+(.+)$/gm, '<h4>$1</h4>');
  text = text.replace(/^#{3}\s+(.+)$/gm, '<h3>$1</h3>');
  text = text.replace(/^#{2}\s+(.+)$/gm, '<h2>$1</h2>');
  text = text.replace(/^#{1}\s+(.+)$/gm, '<h1>$1</h1>');

  // Horizontal rule
  text = text.replace(/^(?:---|\*\*\*|___)\s*$/gm, '<hr>');

  // Blockquote — merge consecutive > lines into single block
  text = text.replace(/((?:^&gt;\s*.+\n?)+)/gm, block => {
    const lines = block.trim().split('\n').map(l => l.replace(/^&gt;\s*/, ''));
    return '<blockquote><svg width="13" height="13" viewBox="0 0 24 24" fill="currentColor"><path d="M14.017 21v-7.391c0-5.704 3.731-9.57 8.983-10.609l.995 2.151c-2.432.917-3.995 3.638-3.995 5.849h4v10h-9.983zm-14.017 0v-7.391c0-5.704 3.748-9.57 9-10.609l.996 2.151c-2.433.917-3.996 3.638-3.996 5.849h3.983v10h-9.983z"/></svg><span>' + lines.join('<br>') + '</span></blockquote>';
  });

  // Lists — bullet and ordered, supports nested indentation via parseListBlock
  // Append \n so subsequent paragraph text is cleanly separated in step 5
  text = text.replace(/((?:^[ \t]*(?:[-*+]|\d+\.)\s+.+\n?)+)/gm, m => parseListBlock(m) + '\n');

  // 3.4 Split inline table headers: move pipe-delimited header from end of text line to its own line
  // Handles LLM output like "some text | Header1 | Header2 |\n|---|---|"
  text = text.replace(/(\S)[ \t]+(\|(?:[^|\n]+\|){2,})[ \t]*\n([ \t]*\|[\s\-:|]+\|)/gm, '$1\n$2\n$3');

  // 3.5 Tables — header row + separator row + data rows
  text = text.replace(/((?:^\|.+\|\s*\n?)+)/gm, block => {
    const rows = block.trim().split('\n');
    if (rows.length < 2) return block;
    const parseRow = row => row.replace(/^\||\|$/g, '').split('|').map(c => c.trim());
    const isSep = r => /^\|[\s\-:|]+\|$/.test(r.trim());

    // Standard: header + separator + data
    if (isSep(rows[1])) {
      const headers = parseRow(rows[0]);
      const dataRows = rows.slice(2).filter(r => r.trim());
      const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
      const tbody = dataRows.length
        ? `<tbody>${dataRows.map(r => `<tr>${parseRow(r).map(c => `<td>${c}</td>`).join('')}</tr>`).join('')}</tbody>`
        : '';
      return `<div class="table-wrap"><table>${thead}${tbody}</table></div>`;
    }

    // Fallback: separator is first row (header was on the preceding text line, not captured)
    if (isSep(rows[0])) {
      const dataRows = rows.slice(1).filter(r => r.trim());
      if (!dataRows.length) return block;
      const tbody = `<tbody>${dataRows.map(r => `<tr>${parseRow(r).map(c => `<td>${c}</td>`).join('')}</tr>`).join('')}</tbody>`;
      return `<div class="table-wrap"><table>${tbody}</table></div>`;
    }

    return block;
  });

  // 4. Inline elements
  // Bold + italic
  text = text.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
  // Bold
  text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  text = text.replace(/(?<!\w)__(.+?)__(?![\w]|\.\w)/g, '<strong>$1</strong>');
  // Italic
  text = text.replace(/\*(?!\s)(.+?)(?<!\s)\*/g, '<em>$1</em>');
  text = text.replace(/(?<!\w)_(?!\s|_)(.+?)(?<!\s)_(?![\w]|\.\w)/g, '<em>$1</em>');
  // Strikethrough
  text = text.replace(/~~(.+?)~~/g, '<del>$1</del>');
  // Restore inline code (was extracted in step 2.5)
  text = text.replace(/\x04ICODE(\d+)\x05/g, (_, i) => `<code>${inlineCodes[+i]}</code>`);
  // Links
  text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

  // 5. Paragraphs — wrap lines that aren't block elements
  const blockTags = /^<(?:h[1-6]|ul|ol|li|hr|blockquote|pre|div)|^\x02BLOCK\d+\x03/;
  const lines = text.split('\n');
  const out = [];
  let para = [];
  const flushPara = () => {
    if (para.length) { out.push('<p>' + para.join('<br>') + '</p>'); para = []; }
  };
  for (const line of lines) {
    if (blockTags.test(line.trimStart())) { flushPara(); out.push(line); }
    else if (line.trim() === '') { flushPara(); }
    else { para.push(line); }
  }
  flushPara();
  text = out.join('\n');

  // 6. Restore code blocks with header + copy button
  text = text.replace(/\x02BLOCK(\d+)\x03/g, (_, i) => {
    const { lang, code } = blocks[+i];
    const id = 'cb' + Math.random().toString(36).slice(2, 8);
    const langLabel = lang || 'code';
    return `<pre><div class="pre-header"><span class="lang">${escH(langLabel)}</span><button class="copy-code-btn" onclick="copyCode('${id}',this)">${t('copy.code')}</button></div><code id="${id}">${escH(code)}</code></pre>`;
  });

  return text;
}

// Handle streaming: unclosed code fences shown as plain pre
const STREAM_CURSOR = '<span class="stream-cursor"></span>';
function renderStreaming(text) {
  // Count code fences — if odd, the last block is open
  const fences = (text.match(/```/g) || []).length;
  if (fences % 2 !== 0) {
    // Has open code block — render what's closed, append raw for open
    const lastFence = text.lastIndexOf('```');
    const closed = text.substring(0, lastFence);
    const open = text.substring(lastFence + 3);
    const langEnd = open.indexOf('\n');
    const lang = langEnd > -1 ? open.substring(0, langEnd) : '';
    const code = langEnd > -1 ? open.substring(langEnd + 1) : '';
    return renderMd(closed) + `<pre><div class="pre-header"><span class="lang">${escH(lang || 'code')}</span></div><code>${escH(code)}</code></pre>` + STREAM_CURSOR;
  }
  return renderMd(text) + STREAM_CURSOR;
}

function copyCode(id, btn) {
  const code = $i(id);
  if (!code) return;
  navigator.clipboard.writeText(code.textContent).then(() => {
    const orig = btn.textContent;
    btn.textContent = '✓ ' + t('copy.code');
    btn.classList.add('ok');
    setTimeout(() => { btn.textContent = orig; btn.classList.remove('ok'); }, 1500);
  });
}

// ─── WebSocket ────────────────────────────────────────────────────────────

// Subscribe to all open tabs across all projects for live task events.
// Uses noCatchUp:true so we don't flood with buffer text for background tabs.
// When user switches to a tab, loadSess sends subscribe_session without noCatchUp
// which triggers a full catch-up with current buffer.
let _subscribingAllTabs = false;
async function subscribeAllTabs() {
  if (_subscribingAllTabs) return; // prevent concurrent in-flight calls (e.g. rapid reconnects)
  _subscribingAllTabs = true;
  try {
    // Fetch session IDs that currently have running tasks (for immediate spinner update)
    const running = await (await fetch('/api/tasks/running-sessions')).json();
    const runningSet = new Set(running);
    // Collect all tabs across all projects
    const groups = [{ tabs: openTabs, isCurrent: true }];
    for (const [pid, tabs] of Object.entries(projectTabs)) {
      if (pid !== curProjectId) groups.push({ tabs, isCurrent: false });
    }
    let needTabs = false, needProjs = false;
    for (const { tabs, isCurrent } of groups) {
      for (const tab of tabs) {
        if (!tab.id || tab.isNew) continue;
        // Subscribe to receive live task events (no catch-up — loadSess handles that for active tab)
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'subscribe_session', sessionId: tab.id, noCatchUp: true }));
        }
        // Immediately show spinner if this tab's session has a running task
        if (runningSet.has(tab.id) && !tab.generating) {
          tab.generating = true;
          if (isCurrent) needTabs = true; else needProjs = true;
        }
      }
    }
    if (needTabs) renderTabs();
    if (needProjs) renderProjects();
  } catch (e) { console.error('subscribeAllTabs:', e); }
  finally { _subscribingAllTabs = false; }
}

let _reconnectDelay = 1000; // starts at 1 s, doubles up to 30 s
let _reconnectTimer = null;
let _intentionalClose = false; // set before navigating away to suppress reconnect

function connect() {
  if (_reconnectTimer) { clearTimeout(_reconnectTimer); _reconnectTimer = null; }
  // Close any existing socket before opening a new one (prevents duplicate event handlers)
  if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
    ws.onclose = null; // suppress onclose reconnect loop — we're reconnecting intentionally
    ws.close();
  }

  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${proto}//${location.host}`);

  ws.onopen = () => {
    _reconnectDelay = 1000; // reset backoff on successful connect
    setStatus(t('status.connected'), 'ok');
    loadFiles();
    loadHist();
    // On page refresh: currentSessionId is null (restoreUIState doesn't call loadSess),
    // but activeTabId may point to a real session — load it now so history appears.
    if (!currentSessionId && activeTabId && openTabs.find(t => t.id === activeTabId && !t.isNew)) {
      loadSess(activeTabId); // loadSess sets currentSessionId and sends start_session at the end
    } else if (currentSessionId && ws.readyState === 1) {
      // Re-attach to active session after a reconnect
      ws.send(JSON.stringify({ type: 'start_session', sessionId: currentSessionId, mode: curMode, agentMode: curAgent, model: curModel}));
      ws.send(JSON.stringify({ type: 'subscribe_session', sessionId: currentSessionId }));
    }
    // Subscribe to all open tabs across all projects to receive live task events
    subscribeAllTabs();
  };

  ws.onclose = (ev) => {
    // Clean close (e.g. server shutdown code 1001, or intentional nav) — reconnect
    if (_intentionalClose) return;
    setStatus(t('status.reconnecting'), 'err');
    if (isGen) { isGen = false; setSendStop(false); generatingTabId = null; } // reset generating state
    // Exponential backoff with ±20 % jitter, capped at 30 s
    const jitter = _reconnectDelay * 0.2 * (Math.random() * 2 - 1);
    _reconnectTimer = setTimeout(() => {
      _reconnectDelay = Math.min(_reconnectDelay * 2, 30000);
      connect();
    }, _reconnectDelay + jitter);
  };

  ws.onmessage = e => {
    let d;
    try { d = JSON.parse(e.data); } catch { return; }
    handleWsMsg(d);
  };

  // onerror always precedes onclose — just log; onclose handles UI + reconnect
  ws.onerror = (err) => { console.warn('WebSocket error:', err); };
}

// Stop reconnect loop on page unload to avoid pointless connections
window.addEventListener('beforeunload', () => { _intentionalClose = true; if (_reconnectTimer) clearTimeout(_reconnectTimer); });

function handleWsMsg(d) {
  const tabId = d.tabId || activeTabId;
  // Look up tab across current project AND all background projects
  const found = findTabAcrossProjects(tabId);
  const isCurrent = found ? found.isCurrent : true;
  const isVisible = isCurrent && tabId === activeTabId;

  switch (d.type) {
    case 'task_started':
      // Update chain progress widget if this task belongs to a dispatched chain
      if (d.taskId) _chainProgressUpdate(d.taskId, 'in_progress');
      if (isVisible) {
        rmW();
        // Show user message (task prompt) before assistant response
        if (d.prompt) {
          const um = addMsg('user');
          um.querySelector('.msg').textContent = d.prompt;
          applyMsgClamp(um);
        }
        setStatus('⚙ ' + (d.title || 'Task') + '…', 'warn');
        if (!streaming.el) { streaming.el = addMsg('assistant'); streaming.txt = ''; addSpinner(streaming.el); }
      }
      if (found?.tab) {
        found.tab.generating = true;
        if (found.isCurrent) renderTabs(); else renderProjects();
      }
      break;

    case 'task_retrying': {
      if (d.taskId) _chainProgressUpdate(d.taskId, 'retry');
      if (isVisible) {
        const rc = d.retryCount || 1;
        // Show user message (task prompt) if not already visible
        if (d.prompt && !msgsEl.querySelector('.mw.user')) {
          const um = addMsg('user');
          um.querySelector('.msg').textContent = d.prompt;
          applyMsgClamp(um);
        }
        const ind = document.createElement('div');
        ind.className = 'msg-retry-indicator';
        ind.textContent = `↩ ${t('toast.task_retry')} #${rc}`;
        $i('messages')?.appendChild(ind);
        setStatus('⚙ ' + (d.title || 'Task') + '…', 'warn');
        if (!streaming.el) { streaming.el = addMsg('assistant'); streaming.txt = ''; addSpinner(streaming.el); }
        scrollBottom();
      }
      if (found?.tab) {
        found.tab.generating = true;
        if (found.isCurrent) renderTabs(); else renderProjects();
      }
      break;
    }

    case 'text':
      if (!isVisible) {
        // Accumulate text for background tabs — restored when user switches back
        // catchUp replaces accumulated text (full replay from server); normal chunks append
        const ts = getTS(tabId);
        ts.curTxt = d.catchUp ? d.text : (ts.curTxt || '') + d.text;
        break;
      }
      rmStatus();
      getTS(tabId).agentStatus = ''; // text has arrived — status no longer relevant
      if (!streaming.el) { rmW(); streaming.el = addMsg('assistant'); streaming.txt = ''; addSpinner(streaming.el); }
      // catchUp = full replay from server after reconnect → replace, not append
      if (d.catchUp) { streaming.txt = d.text; } else { streaming.txt += d.text; }
      streaming.el.querySelector('.msg').innerHTML = renderStreaming(streaming.txt);
      if (d.agent) addAgentBadge(streaming.el, d.agent);
      scrollBottom();
      break;

    case 'tool':
      // Track tool usage for activity summary on done — ALWAYS use tabId, not activeTabId
      { const ts = getTS(tabId); if (!ts._toolCounts) ts._toolCounts = {}; const tn = d.tool || 'tool'; ts._toolCounts[tn] = (ts._toolCounts[tn] || 0) + 1; }
      // Live tool activity panel — show what Claude Code is doing
      if (isVisible) {
        if (!streaming.el) { rmW(); rmStatus(); streaming.el = addMsg('assistant'); streaming.txt = ''; addSpinner(streaming.el); }
        streaming.toolLog.push({ tool: d.tool || 'tool', brief: _toolInputBrief(d.tool, d.input), input: d.input || '' });
        _renderToolLive(streaming.el, streaming.toolLog);
        scrollBottom();
      } else {
        // Background tab — accumulate tool log for restoration on tab switch
        const ts = getTS(tabId); if (!ts._toolLog) ts._toolLog = [];
        ts._toolLog.push({ tool: d.tool || 'tool', brief: _toolInputBrief(d.tool, d.input), input: d.input || '' });
      }
      break;

    case 'thinking':
      if (!streaming.el && isVisible) showStatus(t('status.thinking'));
      break;

    case 'agent_plan':
      if (isVisible && d.agents?.length) {
        _atcRender(d.plan || '', d.agents, d.dispatched || false);
      }
      break;

    case 'agent_status': {
      const _asTxt = (d.agent ? d.agent + ' · ' : '') + escH(d.statusKey ? t(d.statusKey) : d.status);
      getTS(tabId).agentStatus = _asTxt; // persist for tab-switch restoration
      if (isVisible) showStatus(_asTxt);
      // Update team card
      if (d.agent && d.agent !== 'orchestrator') {
        const st = d.status || '';
        if (st.startsWith('🔄')) _atcUpdate(d.agent, 'working');
        else if (st.startsWith('✅')) _atcUpdate(d.agent, 'done');
        else if (st.startsWith('❌')) _atcUpdate(d.agent, 'error');
      }
      break;
    }

    case 'status':
      if (isVisible) {
        setStatus(`CLI · ${d.mode || ''} · ${d.model || ''}`, 'warn');
        setSendStop(true);
      }
      if (found?.tab) { found.tab.generating = true; found.tab.done = false; }
      if (isCurrent) renderTabs(); else renderProjects(); // background: show busy dot on project
      if (tabId === activeTabId) { isGen = true; generatingTabId = tabId; }
      break;

    case 'done':
      // Update chain progress: check if this task completed or failed
      if (d.taskId && _chainData) {
        const ct = _chainData.tasks.find(x => x.id === d.taskId);
        // If task status wasn't already updated to 'retry' by notification, mark as done
        if (ct && ct.status === 'in_progress') _chainProgressUpdate(d.taskId, 'done');
      }
      getTS(tabId).agentStatus = ''; // task finished — clear saved status
      if (isVisible) {
        if (streaming.el && streaming.txt) { streaming.el.querySelector('.msg').innerHTML = renderMd(streaming.txt); applyMsgClamp(streaming.el); }
        // Finalize tool activity: if live panel exists, keep it (collapsed + done); otherwise show pills summary
        if (streaming.el && streaming.el.querySelector('.tool-live')) {
          _finalizeToolLive(streaming.el);
        } else if (streaming.el && Object.keys(streaming.toolCounts).length > 0) {
          _renderToolActivity(streaming.el, streaming.toolCounts);
        }
        // If agent didn't write a status line, show a "Done" badge so user knows it's finished
        if (streaming.el && streaming.txt && !/---\s*\n\s*[✅⏳❓⚠️]/.test(streaming.txt) && !/✅\s*Done/.test(streaming.txt)) {
          const badge = document.createElement('div');
          badge.className = 'msg-done-badge';
          // Build short summary from tool activity
          const tc = Object.keys(streaming.toolCounts).length;
          const total = tc ? Object.values(streaming.toolCounts).reduce((a,b) => a+b, 0) : 0;
          badge.textContent = total > 0 ? `✅ ${t('msf.done')} — ${total} ${t('ta.calls')}` : `✅ ${t('msf.done')}`;
          const footer = streaming.el.querySelector('.msg-status-footer');
          if (footer) streaming.el.insertBefore(badge, footer); else streaming.el.appendChild(badge);
        }
        markDone(streaming.el);
        streaming.el = null; streaming.txt = '';
        streaming.toolCounts = {}; streaming.toolLog = []; // reset tool tracking
        // Clear retry badge on successful completion
        { const rb = msgsEl.querySelector('.retry-badge'); if (rb) rb.remove(); }
        if (d.taskId) {
          setStatus(t('status.connected'), 'ok');
        } else {
          if (activeTabId === generatingTabId) {
            const first = [...msgsEl.querySelectorAll('.mw.user')].find(m => !m.querySelector('.msg-ack'));
            if (first) { const a = document.createElement('div'); a.className = 'msg-ack'; a.textContent = '✓'; first.appendChild(a); }
          }
          isGen = false;
          setSendStop(false);
          setStatus(t('status.connected'), 'ok');
        }
      }
      // For background tabs: clear saved streaming text (message is now persisted to DB)
      if (!isVisible) { const ts = getTS(tabId); if (ts) { ts.curTxt = ''; ts._toolCounts = {}; ts._toolLog = []; } }
      if (found?.tab) { found.tab.generating = false; found.tab.done = true; }
      if (isCurrent) { renderTabs(); if (tabId === activeTabId && !d.taskId) generatingTabId = null; }
      else renderProjects(); // background: remove busy dot from project
      loadHist();
      if (tabId === activeTabId) updateSessBar();
      break;

    case 'files_changed':
      loadFiles();
      break;

    case 'notification':
      // Update chain progress widget from chain task notifications
      if (d.chainTaskId && d.chainStatus) _chainProgressUpdate(d.chainTaskId, d.chainStatus);
      // Only show notification if it belongs to the current tab
      if (isVisible || !d.tabId) {
        showNotification(d);
      }
      break;

    case 'chain_dispatched':
      if (isVisible && d.tasks?.length) {
        _chainProgressRender(d.chain_id, d.tasks);
      }
      break;

    case 'error':
      getTS(tabId).agentStatus = ''; // task errored — clear saved status
      if (isVisible) {
        rmStatus();
        // Finalize tool activity on error — keep live panel if exists, otherwise show pills
        if (streaming.el && streaming.el.querySelector('.tool-live')) {
          _finalizeToolLive(streaming.el);
        } else if (streaming.el && Object.keys(streaming.toolCounts).length > 0) {
          _renderToolActivity(streaming.el, streaming.toolCounts);
        }
        if (streaming.el) {
          _msfRemove(streaming.el);
          const ef = _msfCreate('error', t('msf.error'));
          streaming.el.appendChild(ef);
          streaming.el.querySelector('.msg').innerHTML += `<br><span style="color:var(--red)">${escH(d.error)}</span>`;
        }
        else {
          const em = addMsg('assistant'); em.querySelector('.msg').innerHTML = `<span style="color:var(--red)">${escH(d.error)}</span>`;
          const ef = _msfCreate('error', t('msf.error')); em.appendChild(ef);
        }
        streaming.toolCounts = {}; streaming.toolLog = [];
        isGen = false;
        setSendStop(false);
        setStatus(t('status.error'), 'err');
        toast(d.error, true, 5000);
      }
      // For background tabs: clear saved streaming text on error
      if (!isVisible) { const ts = getTS(tabId); if (ts) { ts.curTxt = ''; ts._toolCounts = {}; ts._toolLog = []; } }
      if (found?.tab) { found.tab.generating = false; }
      if (isCurrent) { renderTabs(); if (tabId === activeTabId) generatingTabId = null; }
      else renderProjects();
      break;

    case 'rate_limit':
      updateRateLimit(d.info);
      break;

    case 'ask_user':
      if (isVisible) {
        renderAskUserCard(d);
      } else {
        // Store for background tab — will render on tab switch
        const ts = getTS(tabId);
        if (!ts._pendingAskUser) ts._pendingAskUser = [];
        ts._pendingAskUser.push(d);
      }
      break;

    case 'ask_tool':
      // CLI Ask tool - renders as interactive question card, answer sent as user message
      if (isVisible) {
        renderAskToolCard(d);
      } else {
        const ts = getTS(tabId);
        if (!ts._pendingAskTool) ts._pendingAskTool = [];
        ts._pendingAskTool.push(d);
      }
      break;

    case 'ask_user_timeout': {
      // Server timed out — disable the card
      const _ric = d.requestId;
      if (_ric && /^[a-f0-9-]{36}$/.test(_ric)) {
        const _card = document.querySelector(`.ask-user-card[data-rid="${_ric}"]`);
        if (_card && !_card.classList.contains('ask-answered')) {
          _card.classList.add('ask-answered');
          _card.querySelector('.ask-answer-display').textContent = t('ask.skipped') + ' (timeout)';
          _card.style.borderColor = 'var(--muted)';
          if (_card._askInterval) clearInterval(_card._askInterval);
        }
      }
      break;
    }

    case 'session_started':
      {
        const srcId = d.tabId || activeTabId;
        // Search across all projects, not just current
        const sf = findTabAcrossProjects(srcId) || (openTabs.find(x => x.id === srcId) ? { tab: openTabs.find(x => x.id === srcId), tabs: openTabs, isCurrent: true } : null);
        const tab = sf?.tab;
        if (tab?.isNew) {
          const oldId = tab.id;
          tab.id = d.sessionId; tab.isNew = false;
          // Move tabState from temp id to real id
          if (tabState[oldId]) { tabState[d.sessionId] = tabState[oldId]; delete tabState[oldId]; }
          if (generatingTabId === oldId) generatingTabId = d.sessionId;
          if (activeTabId === oldId) activeTabId = d.sessionId;
          // Update projectActiveTab if this was a background project's active tab
          if (!sf.isCurrent && sf.projId && projectActiveTab[sf.projId] === oldId) {
            projectActiveTab[sf.projId] = d.sessionId;
          }
          if (sf.isCurrent) renderTabs();
          saveUIState();
        }
      }
      if (activeTabId === d.sessionId) {
        currentSessionId = d.sessionId;
      }
      break;

    case 'session_title':
      {
        const titleTabId = d.tabId || activeTabId;
        const tf = findTabAcrossProjects(titleTabId);
        if (tf?.tab && d.title) {
          tf.tab.title = d.title;
          if (tf.isCurrent) renderTabs();
          saveUIState();
        }
      }
      loadHist();
      updateSessBar();
      break;

    case 'queued':
      break;

    case 'queue_update': {
      if (Array.isArray(d.items)) {
        const stillQueued = new Set(d.items.map(i => i.queueId).filter(Boolean));
        // Remove badges from items no longer in queue
        msgsEl.querySelectorAll('.mw[data-queue-id]').forEach(el => {
          if (!stillQueued.has(el.dataset.queueId)) {
            const q = el.querySelector('.msg-queued');
            if (q) q.remove();
            delete el.dataset.queueId;
          }
        });
        // Recreate queued message bubbles for items missing from DOM
        // (happens after tab switch when loadSess() cleared the DOM)
        const _existQIds = new Set([...msgsEl.querySelectorAll('.mw[data-queue-id]')].map(el => el.dataset.queueId));
        for (const item of d.items) {
          if (item.queueId && !_existQIds.has(item.queueId)) {
            const w = addMsg('user');
            w.dataset.queueId = item.queueId;
            w.querySelector('.msg').textContent = item.text || '';
            const qb = document.createElement('div');
            qb.className = 'msg-queued';
            qb.innerHTML = `<span class="mq-label">${t('queue.label')}</span><button class="qd-btn qd-edit" onclick="editQueuedMsg(this)" title="${t('queue.edit.title')}">✏</button><button class="qd-btn qd-del" onclick="deleteQueuedMsg(this)" title="${t('queue.del.title')}">✕</button>`;
            w.appendChild(qb);
          }
        }
      }
      break;
    }

    case 'queue_removed':
      {
        const el = msgsEl.querySelector(`.mw[data-queue-id="${CSS.escape(d.queueId)}"]`);
        if (el) { el.style.transition = 'opacity .2s'; el.style.opacity = '0'; setTimeout(() => el.remove(), 200); }
      }
      break;

    case 'queue_edited':
      break;

    case 'queue_start':
      { const q = msgsEl.querySelector('.msg-queued'); if (q) q.remove(); }
      if (isVisible) {
        isGen = true;
        showStatus(t('status.processing'));
        setStatus(t('status.processing'), 'warn');
        setSendStop(true);
      }
      break;

    case 'session_reset':
      msgsEl.innerHTML = '';
      _allMsgs = []; _shownFrom = 0;
      showW();
      currentSessionId = null;
      break;

    case 'task_resumed':
      toast('🔄 ' + t('toast.task_resumed'));
      // Re-show generating state for this tab
      { const tr = openTabs.find(x => x.id === tabId); if (tr) { tr.generating = true; renderTabs(); } }
      if (isVisible) { isGen = true; generatingTabId = tabId; setSendStop(true); }
      break;

    case 'task_lost': {
      const tl = openTabs.find(x => x.id === tabId);
      if (tl) { tl.generating = false; renderTabs(); saveUIState(); }
      if (isVisible) { isGen = false; setSendStop(false); setStatus(t('status.connected'), 'ok'); }
      toast(t('toast.task_lost'), true, 4000);
      break;
    }

    case 'task_interrupted': {
      if (!d.prompt) {
        const ti = openTabs.find(x => x.id === tabId);
        if (ti) { ti.generating = false; renderTabs(); saveUIState(); }
        if (isVisible) { isGen = false; setSendStop(false); setStatus(t('status.connected'), 'ok'); }
        break;
      }
      const targetSessionId = d.sessionId || tabId;
      // Deduplicate: both resume_task and subscribe_session can fire task_interrupted
      // for the same session — only retry once per page load
      if (_retryingSessions.has(targetSessionId)) break;
      _retryingSessions.add(targetSessionId);
      { // auto-retry silently — no new message in chat
        const ti = openTabs.find(x => x.id === tabId);
        if (ti) { ti.generating = false; renderTabs(); }
        if (isVisible) { isGen = false; setSendStop(false); }
        const retryCount = (d.retryCount || 0) + 1;
        // Show retry count in session bar (not in chat)
        if (tabId === activeTabId) {
          const retryEl = $i('sessBarRetry');
          if (retryEl) { retryEl.style.display = ''; retryEl.textContent = `↩ ×${retryCount}`; retryEl.title = `Retried ${retryCount} time(s)`; }
        }
        // Mark tab as generating and fire retry
        const targetTab = openTabs.find(x => x.id === targetSessionId);
        if (targetTab) { targetTab.generating = true; renderTabs(); saveUIState(); }
        if (isVisible) { isGen = true; generatingTabId = activeTabId; showStatus(t('status.processing')); setStatus(t('status.processing'), 'warn'); setSendStop(true); }
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({
            type: 'chat', text: d.prompt,
            tabId: targetSessionId, sessionId: targetSessionId,
            retry: true,
            skills: [...activeSkills], mcpServers: [...activeMcp],
            mode: curMode, agentMode: curAgent,
            model: curModel,
            maxTurns: parseInt($i('maxTurns').value) || 30,
            workdir: curWorkdir || undefined,
          }));
        }
      }
      break;
    }
  }
}

// ─── UI helpers ───────────────────────────────────────────────────────────
function setStatus(text, cls) {
  const el = $i('statusEl');
  el.textContent = text;
  el.className = `status-dot ${cls}`;
}

// ─── Rate limit badge + alerts ───────────────────────────────────────────────
const RL_STORAGE_KEY      = 'rl_info';
const RL_THRESHOLDS       = [80, 90, 95]; // toast alert thresholds (%)
const RL_NOTIFY_COOLDOWN  = 5 * 60 * 1000; // 5 min between browser notifications
let _rlInfo               = null;         // last received rate_limit_info
let _rlCountdownTimer     = null;         // interval for live countdown
let _rlLastAlertedPct     = 0;           // highest threshold already toasted (avoids spam)
let _rlLastNotifyTs       = 0;           // timestamp of last browser notification
let _rlModalShown         = false;        // true while rejected modal is visible
let _rlModalTimer         = null;         // interval for modal countdown

function _rlTypeLabel(info) {
  const map = { five_hour: t('rl.type.five_hour'), seven_day: t('rl.type.seven_day') };
  return map[info.rateLimitType] || info.rateLimitType || '';
}

function updateRateLimit(info) {
  if (!info) return;
  // Only show for CLI engine (Max subscription) — status 'allowed' without warning = skip
  if (info.status === 'allowed' && !info.surpassedThreshold) return;

  _rlInfo = info;
  const pct    = Math.round((info.utilization || 0) * 100);
  const isCrit = info.status === 'rejected' || pct >= 95;

  // ── Persist to localStorage (survives reload) ──
  _rlSave(info);

  // ── Threshold toast alerts ──
  _rlCheckThresholds(info, pct);

  // ── Rejected → blocking modal ──
  if (info.status === 'rejected' && !_rlModalShown) {
    _rlShowModal(info);
  }

  // ── Browser notification (background tab, 5min cooldown) ──
  if (pct >= 90 && document.hidden && (Date.now() - _rlLastNotifyTs > RL_NOTIFY_COOLDOWN)) {
    _rlBrowserNotify(info, pct);
    _rlLastNotifyTs = Date.now();
  }

  // ── Update badge UI ──
  _rlRenderBadge(info, pct, isCrit);
}

// ── Badge rendering (extracted for reuse on restore) ──
function _rlRenderBadge(info, pct, isCrit) {
  const badge  = $i('rlBadge');
  const typeLabel = _rlTypeLabel(info) || '—';

  // Badge label
  $i('rlBadgeLabel').textContent = `Max ${pct}%`;
  badge.classList.toggle('rl-crit', isCrit);

  // Tooltip fields
  $i('rl-tt-icon').textContent       = isCrit ? '🚫' : '⚠️';
  $i('rl-tt-title-text').textContent = isCrit ? t('rl.title.crit') : t('rl.title.warn');
  $i('rl-tt-type').textContent       = typeLabel;
  $i('rl-tt-used').textContent       = pct + '%';
  $i('rl-tt-left').textContent       = (100 - pct) + '%';

  // Progress bar
  const fill = $i('rl-bar-fill');
  fill.style.width = pct + '%';
  fill.classList.toggle('rl-crit', isCrit);

  // Reset date
  if (info.resetsAt) {
    const resetsAt = new Date(info.resetsAt * 1000);
    $i('rl-tt-reset').textContent = resetsAt.toLocaleString('uk-UA', { day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit' });
  } else {
    $i('rl-tt-reset').textContent = '—';
  }

  // Show badge
  badge.style.display = 'flex';

  // Start live countdown (update every 30s)
  _rlUpdateCountdown();
  if (_rlCountdownTimer) clearInterval(_rlCountdownTimer);
  _rlCountdownTimer = setInterval(_rlUpdateCountdown, 30000);
}

// ── Threshold toast alerts (fire once per threshold per escalation) ──
function _rlCheckThresholds(info, pct) {
  const typeLabel = _rlTypeLabel(info);

  for (const threshold of RL_THRESHOLDS) {
    if (pct >= threshold && _rlLastAlertedPct < threshold) {
      const key = `rl.toast.${threshold}`;
      const msg = t(key).replace('{type}', typeLabel);
      const isErr = threshold >= 95;
      const dur = threshold >= 95 ? 10000 : threshold >= 90 ? 8000 : 5000;
      toast(msg, isErr, dur);
      _rlLastAlertedPct = threshold;
    }
  }
  // Reset when utilization drops (limit was reset)
  if (pct < 80) _rlLastAlertedPct = 0;
}

// ── Rejected modal with live countdown ──
function _rlShowModal(info) {
  _rlModalShown = true;
  const modal = $i('rlRejectedModal');
  const typeLabel = _rlTypeLabel(info);

  $i('rlModalType').textContent = typeLabel;
  $i('rlModalTitle').textContent = t('rl.modal.title');
  $i('rlModalDesc').textContent = t('rl.modal.desc').replace('{type}', typeLabel);
  modal.classList.remove('hidden');

  // Live countdown inside modal (every 1s for precision)
  const updateTimer = () => {
    if (!_rlInfo || !_rlInfo.resetsAt) { $i('rlModalTimer').textContent = '—'; return; }
    const diff = (_rlInfo.resetsAt * 1000) - Date.now();
    if (diff <= 0) {
      $i('rlModalTimer').textContent = t('rl.reset.done');
      closeRlModal();
      return;
    }
    const h = Math.floor(diff / 3600000);
    const m = Math.floor((diff % 3600000) / 60000);
    const s = Math.floor((diff % 60000) / 1000);
    $i('rlModalTimer').textContent = h > 0
      ? `${h}${t('rl.time.h')} ${String(m).padStart(2,'0')}${t('rl.time.m')} ${String(s).padStart(2,'0')}${t('rl.time.s')}`
      : `${m}${t('rl.time.m')} ${String(s).padStart(2,'0')}${t('rl.time.s')}`;
  };
  updateTimer();
  if (_rlModalTimer) clearInterval(_rlModalTimer);
  _rlModalTimer = setInterval(updateTimer, 1000);
}

function closeRlModal() {
  $i('rlRejectedModal').classList.add('hidden');
  _rlModalShown = false;
  if (_rlModalTimer) { clearInterval(_rlModalTimer); _rlModalTimer = null; }
}

// ── Browser Notification API (background tab) ──
function _rlBrowserNotify(info, pct) {
  if (!('Notification' in window)) return;
  if (Notification.permission === 'default') {
    Notification.requestPermission(); // non-blocking, result used on next call
    return;
  }
  if (Notification.permission !== 'granted') return;
  const typeLabel = _rlTypeLabel(info);
  const body = t('rl.notify.body').replace('{type}', typeLabel).replace('{pct}', pct);
  try { new Notification(t('rl.notify.title'), { body, icon: '/favicon.ico', tag: 'rl-alert' }); } catch {}
}

// ── localStorage persistence ──
function _rlSave(info) {
  try { localStorage.setItem(RL_STORAGE_KEY, JSON.stringify(info)); } catch {}
}

function _rlRestore() {
  try {
    const raw = localStorage.getItem(RL_STORAGE_KEY);
    if (!raw) return;
    const info = JSON.parse(raw);
    if (!info || !info.resetsAt) return;
    // If reset time has passed — clean up and skip
    if (info.resetsAt * 1000 <= Date.now()) {
      localStorage.removeItem(RL_STORAGE_KEY);
      return;
    }
    // Restore badge silently (no toast, no modal — just the visual indicator)
    _rlInfo = info;
    const pct = Math.round((info.utilization || 0) * 100);
    const isCrit = info.status === 'rejected' || pct >= 95;
    _rlLastAlertedPct = pct >= 95 ? 95 : pct >= 90 ? 90 : pct >= 80 ? 80 : 0;
    _rlRenderBadge(info, pct, isCrit);
  } catch {}
}

function _rlUpdateCountdown() {
  if (!_rlInfo) {
    if (_rlCountdownTimer) { clearInterval(_rlCountdownTimer); _rlCountdownTimer = null; }
    return;
  }
  const badge = $i('rlBadge');
  if (!badge || badge.style.display === 'none') {
    if (_rlCountdownTimer) { clearInterval(_rlCountdownTimer); _rlCountdownTimer = null; }
    return;
  }
  const diff = (_rlInfo.resetsAt * 1000) - Date.now();
  if (diff <= 0) {
    // Limit reset — hide badge, clear storage
    $i('rl-tt-countdown').textContent = t('rl.reset.done');
    badge.style.display = 'none';
    if (_rlCountdownTimer) { clearInterval(_rlCountdownTimer); _rlCountdownTimer = null; }
    _rlInfo = null;
    _rlLastAlertedPct = 0;
    try { localStorage.removeItem(RL_STORAGE_KEY); } catch {}
    return;
  }
  const h = Math.floor(diff / 3600000);
  const m = Math.floor((diff % 3600000) / 60000);
  $i('rl-tt-countdown').textContent = h > 0 ? `${h}${t('rl.time.h')} ${m}${t('rl.time.m')}` : `${m}${t('rl.time.m')}`;
}
// ─────────────────────────────────────────────────────────────────────────────

function setSendStop(generating) {
  const stopBtn = $i('stopBtn');
  if (generating) {
    stopBtn.classList.remove('hidden');
  } else {
    stopBtn.classList.add('hidden');
  }
}

function updateQueueBadge(n) {
  const b = $i('queueBadge');
  if (!b) return;
  if (n > 0) { b.textContent = t('queue.badge').replace('{n}', n); b.classList.add('visible'); }
  else { b.classList.remove('visible'); }
}

function confirmStop() {
  const modal = $i('confirmStopModal');
  modal.classList.remove('hidden');
  setTimeout(() => $i('confirmStopBtn').focus(), 50);
}
function cancelStop() {
  $i('confirmStopModal').classList.add('hidden');
}
function doStop() {
  cancelStop();
  // Immediately reset client-side generating state (don't wait for server 'done')
  const activeTab = openTabs.find(t => t.id === activeTabId);
  if (activeTab) { activeTab.generating = false; renderTabs(); }
  // Remove spinner from current streaming message and show "Stopped" state
  if (streaming.el) {
    _msfRemove(streaming.el);
    streaming.el.appendChild(_msfCreate('error', t('status.stopped')));
    // Finalize any partial text
    if (streaming.txt) {
      streaming.el.querySelector('.msg').innerHTML = renderMd(streaming.txt);
    }
    // Finalize tool activity panel if present
    if (streaming.el.querySelector('.tool-live')) _finalizeToolLive(streaming.el);
  }
  streaming.reset();
  isGen = false;
  generatingTabId = null;
  setSendStop(false);
  rmStatus();
  setStatus(t('status.stopped'), 'ok');
  if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type: 'stop', tabId: activeTabId }));
}
function stopAgent() { confirmStop(); }

function addAgentBadge(el, agent) {
  if (el.querySelector('.ab')) return;
  const b = document.createElement('span');
  b.className = 'ab';
  b.style.cssText = 'position:absolute;top:-9px;left:10px;font-size:8px';
  b.textContent = agent;
  el.style.position = 'relative';
  el.style.marginTop = '10px';
  el.appendChild(b);
}

function addMsg(role, opts = {}) {
  rmW();
  const w = document.createElement('div');
  w.className = `mw ${role}`;
  if (opts.msgId) w.dataset.msgId = String(opts.msgId);
  let quoteHtml = '';
  if (opts.replyQuote) {
    const roleName = opts.replyQuote.quotedRole === 'user' ? t('you.label') : 'Claude';
    const preview = escH((opts.replyQuote.quotedContent || '').slice(0, 120) + (opts.replyQuote.quotedContent?.length > 120 ? '…' : ''));
    quoteHtml = `<div class="msg-reply-quote"><span class="rq-role">${escH(roleName)}</span><span class="rq-text">${preview}</span></div>`;
  }
  const forkBtn = role === 'assistant' ? `<button class="fork-btn" onclick="forkFromMsg(this)" title="${t('fork.title')}">↗</button>` : '';
  const useBtn = `<button class="use-btn" onclick="useAsInput(this)" title="${t('use.input')}">↓</button>`;
  w.innerHTML = `${quoteHtml}<div class="msg"></div><button class="cpb" onclick="cpMsg(this)" title="${t('copy.msg')}"><svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></button><button class="reply-btn" onclick="setReply(this)" title="${t('msg.reply')}">↩</button>${forkBtn}${useBtn}`;
  msgsEl.appendChild(w);
  scrollBottom();
  return w;
}

function addEl(cls) {
  const d = document.createElement('div');
  d.className = cls;
  msgsEl.appendChild(d);
  return d;
}

// ─── Agent team card ───
let _atcAgents = new Map(); // track agent states per current generation
let _atcPlanData = null;    // stored for dispatch button
function _atcRender(planText, agents, dispatched) {
  // Remove any existing card
  const old = msgsEl.querySelector('.agent-team-card');
  if (old) old.remove();
  _atcAgents.clear();
  _atcPlanData = { plan: planText, agents };
  agents.forEach(a => _atcAgents.set(a.id, { ...a, state: 'pending' }));

  const card = document.createElement('div');
  card.className = 'agent-team-card';
  card.innerHTML = `
    <div class="atc-header">
      <div class="atc-icon">${dispatched ? '📋' : '🤖'}</div>
      <div>
        <div class="atc-title">${dispatched ? 'Plan → Kanban' : escH(t('msf.team'))}</div>
        <div class="atc-plan" title="${escH(planText)}">${escH(planText)}</div>
      </div>
    </div>
    <div class="atc-agents">
      ${agents.map(a => `
        <div class="atc-row" data-agent-id="${escH(a.id)}">
          <span class="atc-dot"></span>
          <span class="atc-id">${escH(a.id)}</span>
          <span class="atc-role">${escH(a.role)}</span>
          <span class="atc-task">${escH(a.task || '')}</span>
        </div>
      `).join('')}
    </div>
    <div class="atc-footer">
      <span class="atc-count">0/${agents.length}</span>
      <div class="atc-progress"><div class="atc-progress-bar"></div></div>
      ${dispatched ? '' : '<button class="atc-dispatch-btn" onclick="_atcDispatch()">📋 Kanban</button>'}
    </div>`;
  msgsEl.appendChild(card);
  scrollBottom();
}
function _atcDispatch() {
  if (!_atcPlanData || !ws || ws.readyState !== 1) return;
  ws.send(JSON.stringify({
    type: 'dispatch_plan',
    plan: _atcPlanData.plan,
    agents: _atcPlanData.agents,
    sessionId: currentSessionId,
    tabId: activeTabId,
    workdir: curWorkdir || undefined,
    model: curModel,
  }));
  const btn = document.querySelector('.atc-dispatch-btn');
  if (btn) { btn.textContent = '✅ Sent'; btn.disabled = true; }
}
function _atcUpdate(agentId, state) {
  const card = msgsEl.querySelector('.agent-team-card');
  if (!card) return;
  const info = _atcAgents.get(agentId);
  if (info) info.state = state;

  const row = card.querySelector(`[data-agent-id="${agentId}"]`);
  if (row) {
    row.classList.remove('atc-working', 'atc-done', 'atc-error');
    if (state === 'working') row.classList.add('atc-working');
    else if (state === 'done') row.classList.add('atc-done');
    else if (state === 'error') row.classList.add('atc-error');
  }

  // Update progress
  const total = _atcAgents.size;
  const done = [..._atcAgents.values()].filter(a => a.state === 'done' || a.state === 'error').length;
  const countEl = card.querySelector('.atc-count');
  const barEl = card.querySelector('.atc-progress-bar');
  if (countEl) countEl.textContent = `${done}/${total}`;
  if (barEl) barEl.style.width = `${Math.round((done / total) * 100)}%`;
}

// ─── Chain progress card (dispatched tasks tracking) ────────────────────
let _chainData = null; // { chain_id, session_id, tasks }
function _chainProgressRender(chainId, tasks) {
  _chainData = { chain_id: chainId, tasks };
  const old = msgsEl.querySelector('.chain-progress-card');
  if (old) old.remove();
  const doneCount = tasks.filter(x => x.status === 'done').length;
  const failedCount = tasks.filter(x => x.status === 'cancelled').length;
  const pct = tasks.length ? Math.round((doneCount / tasks.length) * 100) : 0;
  const titleText = doneCount || failedCount
    ? `📋 Kanban Chain — ${doneCount}/${tasks.length} done${failedCount ? `, ${failedCount} failed` : ''}`
    : `📋 Kanban Chain — ${tasks.length} tasks`;
  const card = document.createElement('div');
  card.className = 'chain-progress-card';
  card.dataset.chainId = chainId;
  card.innerHTML = `
    <div class="cpc-title">${titleText}</div>
    <div class="cpc-tasks">
      ${tasks.map(t => {
        const st = t.status || 'todo';
        const cls = st === 'done' ? 'cpc-done' : st === 'in_progress' ? 'cpc-running' : st === 'cancelled' ? 'cpc-failed' : '';
        const label = st === 'in_progress' ? 'running' : st === 'cancelled' ? 'failed' : st;
        return `
        <div class="cpc-task ${cls}" data-task-id="${escH(t.id)}">
          <span class="cpc-dot"></span>
          <span class="cpc-name">${escH(t.title)}</span>
          <span class="cpc-status" style="font-size:10px;color:var(--muted);margin-left:auto">${label}</span>
        </div>`;
      }).join('')}
    </div>
    <div class="cpc-bar"><div class="cpc-bar-fill" style="width:${pct}%"></div></div>
    <div style="margin-top:6px;text-align:right">
      <a href="/kanban" target="_blank" style="font-size:10px;color:var(--accent);text-decoration:none;opacity:.7">Open Kanban →</a>
    </div>`;
  msgsEl.appendChild(card);
  scrollBottom();
}
function _chainProgressUpdate(taskId, status) {
  const card = msgsEl.querySelector('.chain-progress-card');
  if (!card || !_chainData) return;
  const row = card.querySelector(`[data-task-id="${taskId}"]`);
  if (row) {
    row.classList.remove('cpc-done', 'cpc-running', 'cpc-failed', 'cpc-retry');
    const statusEl = row.querySelector('.cpc-status');
    if (status === 'in_progress') { row.classList.add('cpc-running'); if (statusEl) statusEl.textContent = 'running'; }
    else if (status === 'done') { row.classList.add('cpc-done'); if (statusEl) statusEl.textContent = 'done'; }
    else if (status === 'cancelled') { row.classList.add('cpc-failed'); if (statusEl) statusEl.textContent = 'failed'; }
    else if (status === 'retry') { row.classList.add('cpc-retry'); if (statusEl) statusEl.textContent = 'retrying'; }
  }
  // Update task state in _chainData
  const t = _chainData.tasks.find(x => x.id === taskId);
  if (t) t.status = status;
  // Update progress bar
  const total = _chainData.tasks.length;
  const done = _chainData.tasks.filter(x => x.status === 'done').length;
  const bar = card.querySelector('.cpc-bar-fill');
  if (bar) bar.style.width = `${Math.round((done / total) * 100)}%`;
  // Update title
  const title = card.querySelector('.cpc-title');
  if (title) {
    const failed = _chainData.tasks.filter(x => x.status === 'cancelled').length;
    title.textContent = `📋 Kanban Chain — ${done}/${total} done${failed ? `, ${failed} failed` : ''}`;
  }
}

function rmW() { const w = msgsEl.querySelector('.welcome'); if (w) w.remove(); }
function showW() {
  streaming.el = null;
  msgsEl.innerHTML = `<div class="welcome"><div class="wi">CC</div><h2>Claude Code Studio</h2><p>${t('welcome.desc')}</p><div class="welcome-prompts"><div class="wp-card" onclick="setPrompt(this)">&#x1F4A1; ${t('welcome.prompt.1')}</div><div class="wp-card" onclick="setPrompt(this)">&#x1F41B; ${t('welcome.prompt.2')}</div><div class="wp-card" onclick="setPrompt(this)">&#x2728; ${t('welcome.prompt.3')}</div><div class="wp-card" onclick="setPrompt(this)">&#x1F3D7;&#xFE0F; ${t('welcome.prompt.4')}</div></div></div>`;
}

function showStatus(txt) {
  let el = msgsEl.querySelector('.agent-status');
  if (!el) { rmW(); el = addEl('agent-status'); el.innerHTML = '<span class="asdot"></span><span class="astxt"></span>'; scrollBottom(); }
  el.querySelector('.astxt').textContent = txt;
}
function rmStatus() { const el = msgsEl.querySelector('.agent-status'); if (el) el.remove(); }


function _msfCreate(state, labelText) {
  const f = document.createElement('div');
  f.className = `msg-status-footer state-${state}`;
  if (state === 'streaming') {
    f.innerHTML = `<div class="msf-icon"></div><span class="msf-label">${labelText}</span><div class="msf-dots"><span></span><span></span><span></span></div>`;
  } else if (state === 'waiting') {
    f.innerHTML = `<div class="msf-icon"><span></span><span></span><span></span></div><span class="msf-label">${labelText}</span>`;
  } else {
    f.innerHTML = `<div class="msf-icon"></div><span class="msf-label">${labelText}</span>`;
  }
  return f;
}
function _msfGet(el) { return el ? el.querySelector('.msg-status-footer') : null; }
function _msfRemove(el) { const f = _msfGet(el); if (f) f.remove(); }

function addSpinner(el) {
  if (!el || _msfGet(el)) return;
  const f = _msfCreate('streaming', t('msf.working'));
  el.appendChild(f);
}
// Map raw Claude tool names to user-friendly short labels
const _toolLabels = {
  Bash:'Bash', View:'Read', Read:'Read', Glob:'Search', Grep:'Search',
  GlobTool:'Search', GrepTool:'Search', ListDir:'Browse',
  SearchReplace:'Edit', Edit:'Edit', Write:'Write',
  ReadNotebook:'Read', NotebookEditCell:'Edit',
  Task:'Task', TodoWrite:'Todo', WebFetch:'Web', WebSearch:'Web',
  ToolSearch:'Tools', Skill:'Skill', AskUserQuestion:'Ask',
};
function _toolLabel(name) {
  if (_toolLabels[name]) return _toolLabels[name];
  // MCP tools: extract readable suffix (e.g. "mcp__playwright__browser_click" → "browser_click")
  if (name.startsWith('mcp_')) {
    const parts = name.split('__');
    return parts[parts.length - 1] || name;
  }
  return name;
}

// Merge tool counts, collapsing labels that map to the same display name
function _mergeToolCounts(raw) {
  const merged = {};
  for (const [k, v] of Object.entries(raw)) {
    const label = _toolLabel(k);
    merged[label] = (merged[label] || 0) + v;
  }
  return merged;
}

// ─── Live Tool Activity (during generation) ─────────────────────────────────

// Shorten a file path to last 2-3 segments for compact display
function _shortenPath(p) {
  if (!p || p.length < 50) return p;
  const parts = p.split('/').filter(Boolean);
  if (parts.length > 3) return '…/' + parts.slice(-3).join('/');
  return p;
}

// Extract readable summary from tool input JSON
function _toolInputBrief(toolName, inputStr) {
  if (!inputStr) return '';
  try {
    const inp = JSON.parse(inputStr);
    // File operations
    if (inp.file_path) return _shortenPath(inp.file_path);
    if (inp.command) { const c = inp.command; return c.length > 120 ? c.substring(0, 120) + '…' : c; }
    if (inp.pattern) {
      let s = inp.pattern;
      if (inp.path) s += '  in ' + _shortenPath(inp.path);
      if (inp.glob) s += '  ' + inp.glob;
      return s.length > 120 ? s.substring(0, 120) + '…' : s;
    }
    if (inp.path) return _shortenPath(inp.path);
    if (inp.query) return inp.query.length > 100 ? inp.query.substring(0, 100) + '…' : inp.query;
    if (inp.url) return inp.url.length > 100 ? inp.url.substring(0, 100) + '…' : inp.url;
    if (inp.description) return inp.description.length > 100 ? inp.description.substring(0, 100) + '…' : inp.description;
    if (inp.prompt) return inp.prompt.length > 80 ? inp.prompt.substring(0, 80) + '…' : inp.prompt;
    // Generic: first non-empty short string value
    for (const v of Object.values(inp)) {
      if (typeof v === 'string' && v.length > 0 && v.length < 200) {
        return v.length > 100 ? v.substring(0, 100) + '…' : v;
      }
    }
  } catch {
    // Not valid JSON — use raw string
    if (inputStr.length > 100) return inputStr.substring(0, 100) + '…';
    return inputStr;
  }
  return '';
}

// Render/update live tool activity panel inside message wrapper
// Panel is collapsed by default — user clicks to expand and see details
function _renderToolLive(mw, log) {
  if (!mw || !log.length) return;
  let panel = mw.querySelector('.tool-live');
  if (!panel) {
    panel = document.createElement('div');
    panel.className = 'tool-live collapsed'; // collapsed by default
    const header = document.createElement('div');
    header.className = 'tool-live-header';
    header.innerHTML = `<span class="tl-arrow">▼</span><span class="tl-dot"></span><span class="tl-count"></span>`;
    header.onclick = () => { panel.classList.toggle('collapsed'); };
    panel.appendChild(header);
    const body = document.createElement('div');
    body.className = 'tool-live-body';
    const list = document.createElement('div');
    list.className = 'tool-live-list';
    body.appendChild(list);
    panel.appendChild(body);
    // Insert before footer (spinner) if present
    const footer = mw.querySelector('.msg-status-footer');
    if (footer) mw.insertBefore(panel, footer);
    else mw.appendChild(panel);
  }
  // Update header count
  panel.querySelector('.tl-count').textContent = `${t('ta.activity')} · ${log.length}`;
  // Add only new items (incremental)
  const list = panel.querySelector('.tool-live-list');
  const existing = list.children.length;
  for (let i = existing; i < log.length; i++) {
    const item = document.createElement('div');
    item.className = 'tool-live-item';
    const entry = log[i];
    const briefHtml = entry.brief ? `<span class="tl-brief" title="${escH(entry.brief)}">${escH(entry.brief)}</span>` : '';
    const chevronHtml = entry.input ? '<span class="tl-chevron">▶</span>' : '';
    const row = document.createElement('div');
    row.className = 'tl-row';
    row.innerHTML = `<span class="tl-name">${escH(_toolLabel(entry.tool))}</span>${briefHtml}${chevronHtml}`;
    item.appendChild(row);
    // Expandable detail (raw input) — only if we have input data
    if (entry.input) {
      const detail = document.createElement('div');
      detail.className = 'tl-detail';
      // Try to pretty-print JSON, fallback to raw string
      try { detail.textContent = JSON.stringify(JSON.parse(entry.input), null, 2); }
      catch { detail.textContent = entry.input; }
      item.appendChild(detail);
      row.onclick = () => { item.classList.toggle('expanded'); };
    }
    list.appendChild(item);
  }
  // Auto-scroll body to bottom when expanded
  if (!panel.classList.contains('collapsed')) {
    const body = panel.querySelector('.tool-live-body');
    if (body) body.scrollTop = body.scrollHeight;
  }
}

// Mark live tool panel as done (keep it, just remove pulse animation)
function _finalizeToolLive(mw) {
  if (!mw) return;
  const panel = mw.querySelector('.tool-live');
  if (panel) {
    panel.classList.add('done');
    if (!panel.classList.contains('collapsed')) panel.classList.add('collapsed');
  }
}

// Remove live tool panel from message wrapper (used on error cleanup)
function _removeToolLive(mw) {
  if (!mw) return;
  const panel = mw.querySelector('.tool-live');
  if (panel) panel.remove();
}

// Render tool activity bar inside a message wrapper element
function _renderToolActivity(mw, rawCounts) {
  if (!mw || !rawCounts || !Object.keys(rawCounts).length) return;
  // Don't duplicate
  if (mw.querySelector('.tool-activity')) return;
  const merged = _mergeToolCounts(rawCounts);
  const total = Object.values(merged).reduce((a, b) => a + b, 0);
  const pills = Object.entries(merged).map(([name, cnt]) =>
    `<span class="ta-pill">${escH(name)}${cnt > 1 ? ' ×' + cnt : ''}</span>`
  ).join('');
  const bar = document.createElement('div');
  bar.className = 'tool-activity';
  bar.innerHTML = `<span class="ta-icon">⚙</span><span class="ta-summary">${total} ${t('ta.calls')}</span><span class="ta-pills">${pills}</span>`;
  // Insert before the footer (if present), otherwise append
  const footer = mw.querySelector('.msg-status-footer');
  if (footer) mw.insertBefore(bar, footer);
  else mw.appendChild(bar);
}

function markDone(el) {
  rmStatus();
  if (!el) return;
  _msfRemove(el);
  if (!_msfGet(el)) {
    const f = _msfCreate('done', t('msf.done'));
    el.appendChild(f);
  }
}

// Smart scroll: don't scroll if user scrolled up
// ─── Ask User Card ───────────────────────────────────────────────────────────

// Helper: extract label/description from option (string or {label,description} object)
function _askOptLabel(opt) { return typeof opt === 'string' ? opt : (opt?.label || ''); }
function _askOptDesc(opt) { return (opt != null && typeof opt === 'object') ? (opt.description || '') : ''; }

function renderAskUserCard(data) {
  const { requestId } = data;
  // Validate requestId is a UUID to prevent XSS injection
  if (!requestId || !/^[a-f0-9-]{36}$/.test(requestId)) return;
  // Deduplicate — don't render if card already exists
  if (document.querySelector(`.ask-user-card[data-rid="${requestId}"]`)) return;

  // Normalize into questions array (backward compat with old question/options/inputType format)
  let questions;
  if (Array.isArray(data.questions) && data.questions.length) {
    questions = data.questions;
  } else {
    const opts = data.options;
    const iType = data.inputType || (opts?.length ? 'single_choice' : 'free_text');
    questions = [{ question: data.question, options: opts || null, multiSelect: iType === 'multi_choice' }];
  }

  const card = document.createElement('div');
  card.className = 'ask-user-card';
  card.dataset.rid = requestId;
  card._askPageIndex = 0;
  card._askQuestions = questions;

  let html = '';

  // Pagination controls (only if multiple questions)
  if (questions.length > 1) {
    html += `<div class="ask-pagination">`;
    html += `<button class="ask-page-btn ask-prev" disabled>${t('ask.prev')}</button>`;
    html += `<span class="ask-page-indicator">1 / ${questions.length}</span>`;
    html += `<button class="ask-page-btn ask-next">${t('ask.next')}</button>`;
    html += `</div>`;
  }

  // Render each question as a page
  for (let qi = 0; qi < questions.length; qi++) {
    const q = questions[qi];
    const hasOpts = Array.isArray(q.options) && q.options.length > 0;
    const isMulti = !!q.multiSelect;
    const inputKind = isMulti ? 'checkbox' : 'radio';

    html += `<div class="ask-page${qi === 0 ? ' active' : ''}" data-page="${qi}">`;

    // Header badge
    if (q.header) {
      html += `<div class="ask-header">${escH(q.header)}</div>`;
    }

    // Question text
    html += `<div class="ask-q">${renderMd(q.question || '')}</div>`;

    if (hasOpts) {
      // Render option buttons
      html += '<div class="ask-options">';
      for (let oi = 0; oi < q.options.length; oi++) {
        const lbl = _askOptLabel(q.options[oi]);
        const desc = _askOptDesc(q.options[oi]);
        html += `<label class="ask-opt"><input type="${inputKind}" name="ask_${requestId}_${qi}" value="${escH(lbl)}">`;
        if (desc) {
          html += ` <span class="ask-opt-content"><span>${escH(lbl)}</span><span class="ask-opt-desc">${escH(desc)}</span></span>`;
        } else {
          html += ` <span>${escH(lbl)}</span>`;
        }
        html += `</label>`;
      }

      // "Other" free-text row
      html += `<div class="ask-other-row"><input type="${inputKind}" class="ask-other-radio" name="ask_${requestId}_${qi}" value="__other__"><input type="text" class="ask-other-input" placeholder="${escH(t('ask.other'))}"></div>`;

      html += '</div>';
    } else {
      // Pure free_text
      html += `<textarea class="ask-text" placeholder="..." rows="2"></textarea>`;
    }

    html += `</div>`; // .ask-page
  }

  // Buttons + timer
  html += `<div class="ask-btns">`;
  html += `<button class="ask-submit">${t('ask.submit')}</button>`;
  html += `<button class="ask-skip">${t('ask.skip')}</button>`;
  html += `<span class="ask-timer" data-end="${Date.now() + 5 * 60 * 1000}">5:00</span>`;
  html += `</div>`;
  html += `<div class="ask-answer-display"></div>`;

  card.innerHTML = html;

  // ── Event listeners ──

  // Submit / Skip
  card.querySelector('.ask-submit').addEventListener('click', () => askUserSubmit(requestId));
  card.querySelector('.ask-skip').addEventListener('click', () => askUserCancel(requestId));

  // Pagination
  if (questions.length > 1) {
    const prevBtn = card.querySelector('.ask-prev');
    const nextBtn = card.querySelector('.ask-next');
    const indicator = card.querySelector('.ask-page-indicator');
    const pages = card.querySelectorAll('.ask-page');

    const showPage = (idx) => {
      card._askPageIndex = idx;
      pages.forEach((p, i) => p.classList.toggle('active', i === idx));
      prevBtn.disabled = idx === 0;
      nextBtn.disabled = idx === questions.length - 1;
      indicator.textContent = `${idx + 1} / ${questions.length}`;
      // Focus textarea on the active page if it has one
      const activeTa = pages[idx]?.querySelector('.ask-text');
      if (activeTa) activeTa.focus();
    };
    prevBtn.addEventListener('click', () => showPage(Math.max(0, card._askPageIndex - 1)));
    nextBtn.addEventListener('click', () => showPage(Math.min(questions.length - 1, card._askPageIndex + 1)));
  }

  // Option toggle: visual selected class + handle "Other" row interaction
  card.querySelectorAll('.ask-page').forEach(page => {
    const opts = page.querySelectorAll('.ask-opt');
    const otherRow = page.querySelector('.ask-other-row');
    const otherRadio = otherRow?.querySelector('.ask-other-radio');
    const otherInput = otherRow?.querySelector('.ask-other-input');
    const isMulti = page.querySelector('input[type="checkbox"]') !== null;

    // Click on a predefined option
    opts.forEach(opt => {
      opt.addEventListener('click', () => {
        if (!isMulti) {
          // Single-select: deselect all including "Other"
          opts.forEach(o => o.classList.remove('selected'));
          if (otherRow) { otherRow.classList.remove('selected'); if (otherInput) otherInput.value = ''; }
          opt.classList.add('selected');
        } else {
          opt.classList.toggle('selected');
        }
      });
    });

    // "Other" row interaction
    if (otherRow && otherRadio && otherInput) {
      const selectOther = () => {
        if (!isMulti) {
          opts.forEach(o => { o.classList.remove('selected'); o.querySelector('input').checked = false; });
        }
        otherRadio.checked = true;
        otherRow.classList.add('selected');
      };
      otherRow.addEventListener('click', (e) => {
        if (e.target !== otherInput) { selectOther(); otherInput.focus(); }
      });
      otherInput.addEventListener('focus', selectOther);
      otherInput.addEventListener('input', () => { if (otherInput.value) selectOther(); });
      otherInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); askUserSubmit(requestId); }
      });
    }
  });

  msgsEl.appendChild(card);
  scrollBottom();

  // Attach Enter-to-submit on ALL textareas (not just first page)
  card.querySelectorAll('.ask-text').forEach(ta => {
    ta.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); askUserSubmit(requestId); }
    });
  });
  // Focus the first page's textarea
  const firstTa = card.querySelector('.ask-page.active .ask-text');
  if (firstTa) firstTa.focus();

  // Start countdown timer
  const timerEl = card.querySelector('.ask-timer');
  if (timerEl) {
    const endTime = parseInt(timerEl.dataset.end);
    const _askInterval = setInterval(() => {
      const left = Math.max(0, endTime - Date.now());
      const m = Math.floor(left / 60000);
      const s = Math.floor((left % 60000) / 1000);
      timerEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
      if (left <= 0) { clearInterval(_askInterval); timerEl.textContent = '0:00'; }
    }, 1000);
    card._askInterval = _askInterval;
  }
}

// Collect answer from a single .ask-page element
function _askCollectPageAnswer(page) {
  // Free-text page
  const ta = page.querySelector('.ask-text');
  if (ta) return ta.value.trim();

  // Choice page — check for "Other" selection first
  const otherRadio = page.querySelector('.ask-other-radio');
  const otherInput = page.querySelector('.ask-other-input');
  if (otherRadio?.checked && otherInput?.value.trim()) {
    // For multi-select, also collect checked predefined options
    const isMulti = page.querySelector('input[type="checkbox"]') !== null;
    if (isMulti) {
      const checked = [...page.querySelectorAll('.ask-opt input:checked')].map(c => c.value);
      checked.push(otherInput.value.trim());
      return checked.join(', ');
    }
    return otherInput.value.trim();
  }

  // Collect checked predefined options
  const checked = [...page.querySelectorAll('.ask-opt input:checked')].map(c => c.value);
  return checked.join(', ');
}

function askUserSubmit(requestId) {
  const card = document.querySelector(`.ask-user-card[data-rid="${requestId}"]`);
  if (!card || card.classList.contains('ask-answered')) return;

  const pages = card.querySelectorAll('.ask-page');
  let answer = '';

  if (pages.length <= 1) {
    // Single question — plain string answer (backward compat)
    answer = _askCollectPageAnswer(pages[0]);
  } else {
    // Multiple questions — collect all, format as structured JSON
    const parts = [];
    let allEmpty = true;
    pages.forEach((page, i) => {
      const q = card._askQuestions?.[i]?.question || '';
      const a = _askCollectPageAnswer(page);
      if (a) allEmpty = false;
      parts.push(`Q: ${q}\nA: ${a || '—'}`);
    });
    if (allEmpty) return;
    answer = parts.join('\n\n');
  }

  if (!answer) {
    // Visual feedback: highlight empty "Other" input or textarea on the active page
    const activePage = card.querySelector('.ask-page.active') || card.querySelector('.ask-page');
    const emptyOther = activePage?.querySelector('.ask-other-row.selected .ask-other-input');
    const emptyTa = activePage?.querySelector('.ask-text');
    const target = emptyOther || emptyTa;
    if (target) { target.style.borderColor = '#f85149'; target.focus(); setTimeout(() => { target.style.borderColor = ''; }, 2000); }
    return;
  }

  ws.send(JSON.stringify({ type: 'ask_user_response', requestId, answer }));

  // Mark as answered
  card.classList.add('ask-answered');
  // Show summary
  let displayText = '';
  if (pages.length <= 1) {
    displayText = `${t('ask.answered')}: ${answer}`;
  } else {
    // Extract just the A: lines for compact display
    const aLines = answer.split('\n').filter(l => l.startsWith('A: ')).map(l => l.slice(3));
    displayText = `${t('ask.answered')}: ${aLines.join(' · ')}`;
  }
  card.querySelector('.ask-answer-display').textContent = displayText;
  if (card._askInterval) clearInterval(card._askInterval);
}

function askUserCancel(requestId) {
  const card = document.querySelector(`.ask-user-card[data-rid="${requestId}"]`);
  if (!card || card.classList.contains('ask-answered')) return;

  ws.send(JSON.stringify({ type: 'ask_user_cancel', requestId }));

  card.classList.add('ask-answered');
  card.querySelector('.ask-answer-display').textContent = t('ask.skipped');
  card.style.borderColor = 'var(--muted)';
  if (card._askInterval) clearInterval(card._askInterval);
}

// ─── Ask Tool Card (CLI Ask tool) ────────────────────────────────────────────
function renderAskToolCard(data) {
  const { requestId, question, options } = data;
  // Validate requestId format (ask-{timestamp}-{random})
  if (!requestId || !/^ask-\d+-[a-z0-9]+$/.test(requestId)) return;
  // Deduplicate
  if (document.querySelector(`.ask-tool-card[data-rid="${requestId}"]`)) return;

  const card = document.createElement('div');
  card.className = 'ask-user-card ask-tool-card'; // reuse ask-user-card styles
  card.dataset.rid = requestId;

  const hasOptions = Array.isArray(options) && options.length > 0;

  let html = `<div class="ask-page active">`;
  html += `<div class="ask-q">${renderMd(question || '')}</div>`;

  if (hasOptions) {
    html += '<div class="ask-options">';
    for (const opt of options) {
      const lbl = typeof opt === 'string' ? opt : (opt?.label || opt);
      const desc = (opt != null && typeof opt === 'object') ? (opt.description || '') : '';
      html += `<label class="ask-opt"><input type="radio" name="ask_tool_${requestId}" value="${escH(lbl)}">`;
      if (desc) {
        html += ` <span class="ask-opt-content"><span>${escH(lbl)}</span><span class="ask-opt-desc">${escH(desc)}</span></span>`;
      } else {
        html += ` <span>${escH(lbl)}</span>`;
      }
      html += `</label>`;
    }
    // "Other" option
    html += `<div class="ask-other-row"><input type="radio" class="ask-other-radio" name="ask_tool_${requestId}" value="__other__"><input type="text" class="ask-other-input" placeholder="${escH(t('ask.other'))}"></div>`;
    html += '</div>';
  } else {
    html += `<textarea class="ask-text" placeholder="..." rows="2"></textarea>`;
  }

  html += `</div>`;

  // Buttons
  html += `<div class="ask-btns">`;
  html += `<button class="ask-submit">${t('ask.submit')}</button>`;
  html += `<button class="ask-skip">${t('ask.skip')}</button>`;
  html += `</div>`;
  html += `<div class="ask-answer-display"></div>`;

  card.innerHTML = html;

  // Event listeners for option selection
  const opts = card.querySelectorAll('.ask-opt');
  const otherRow = card.querySelector('.ask-other-row');
  const otherRadio = otherRow?.querySelector('.ask-other-radio');
  const otherInput = otherRow?.querySelector('.ask-other-input');

  opts.forEach(opt => {
    opt.addEventListener('click', () => {
      opts.forEach(o => o.classList.remove('selected'));
      if (otherRow) { otherRow.classList.remove('selected'); if (otherInput) otherInput.value = ''; }
      opt.classList.add('selected');
    });
  });

  if (otherRow && otherRadio && otherInput) {
    const selectOther = () => {
      opts.forEach(o => { o.classList.remove('selected'); o.querySelector('input').checked = false; });
      otherRadio.checked = true;
      otherRow.classList.add('selected');
    };
    otherRow.addEventListener('click', (e) => {
      if (e.target !== otherInput) { selectOther(); otherInput.focus(); }
    });
    otherInput.addEventListener('focus', selectOther);
    otherInput.addEventListener('input', () => { if (otherInput.value) selectOther(); });
    otherInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); submitAskTool(requestId); }
    });
  }

  // Submit / Skip handlers
  card.querySelector('.ask-submit').addEventListener('click', () => submitAskTool(requestId));
  card.querySelector('.ask-skip').addEventListener('click', () => skipAskTool(requestId));

  // Enter to submit on textarea
  const ta = card.querySelector('.ask-text');
  if (ta) {
    ta.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); submitAskTool(requestId); }
    });
  }

  msgsEl.appendChild(card);
  scrollBottom();

  // Focus input
  if (ta) ta.focus();
  else if (otherInput) otherInput.focus();
}

function submitAskTool(requestId) {
  const card = document.querySelector(`.ask-tool-card[data-rid="${requestId}"]`);
  if (!card || card.classList.contains('ask-answered')) return;

  let answer = '';

  // Check for textarea (free text mode)
  const ta = card.querySelector('.ask-text');
  if (ta) {
    answer = ta.value.trim();
  } else {
    // Check for "Other" selection
    const otherRadio = card.querySelector('.ask-other-radio');
    const otherInput = card.querySelector('.ask-other-input');
    if (otherRadio?.checked && otherInput?.value.trim()) {
      answer = otherInput.value.trim();
    } else {
      // Collect selected option
      const checked = card.querySelector('.ask-opt input:checked');
      answer = checked?.value || '';
    }
  }

  if (!answer) {
    // Visual feedback
    const emptyOther = card.querySelector('.ask-other-row.selected .ask-other-input');
    const emptyTa = card.querySelector('.ask-text');
    const target = emptyOther || emptyTa;
    if (target) { target.style.borderColor = '#f85149'; target.focus(); setTimeout(() => { target.style.borderColor = ''; }, 2000); }
    return;
  }

  // Send response to server
  ws.send(JSON.stringify({ type: 'ask_tool_response', requestId, answer }));

  // Mark as answered
  card.classList.add('ask-answered');
  card.querySelector('.ask-answer-display').textContent = `${t('ask.answered')}: ${answer}`;

  // Also send as user message so Claude sees the answer
  sendChat(answer);
}

function skipAskTool(requestId) {
  const card = document.querySelector(`.ask-tool-card[data-rid="${requestId}"]`);
  if (!card || card.classList.contains('ask-answered')) return;

  ws.send(JSON.stringify({ type: 'ask_tool_response', requestId, answer: '[Skipped]' }));

  card.classList.add('ask-answered');
  card.querySelector('.ask-answer-display').textContent = t('ask.skipped');
  card.style.borderColor = 'var(--muted)';
}

function scrollBottom() {
  if (!userScrolled) msgsEl.scrollTo({ top: msgsEl.scrollHeight, behavior: 'instant' });
}
function scrollToBottom() {
  userScrolled = false;
  msgsEl.scrollTo({ top: msgsEl.scrollHeight, behavior: 'instant' });
}

function setPrompt(el) {
  const txt = el.textContent.replace(/^[^\s]+\s/, ''); // strip emoji
  const inp = $i('input');
  if (inp) { inp.value = txt; inp.focus(); inp.style.height = 'auto'; inp.style.height = Math.min(inp.scrollHeight, 120) + 'px'; }
}

const _scrollBtn = document.getElementById('scrollBtn');
msgsEl.addEventListener('scroll', () => {
  const fromBottom = msgsEl.scrollHeight - msgsEl.scrollTop - msgsEl.clientHeight;
  userScrolled = fromBottom > 150;
  if (_scrollBtn) {
    if (fromBottom > 300) _scrollBtn.classList.add('visible');
    else _scrollBtn.classList.remove('visible');
  }
});

function cpMsg(b) {
  const t = b.parentElement.querySelector('.msg').textContent;
  navigator.clipboard.writeText(t).then(() => {
    b.innerHTML = '✓';
    b.classList.add('ok');
    setTimeout(() => { b.innerHTML = '<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>'; b.classList.remove('ok'); }, 1500);
  });
}

function setReply(btn) {
  const mw = btn.closest('.mw');
  const id = mw.dataset.msgId || null;
  const role = mw.classList.contains('user') ? 'user' : 'assistant';
  const content = mw.querySelector('.msg').textContent.trim().slice(0, 200);
  replyTo = { id, role, content };
  $i('replyPreviewRole').textContent = role === 'user' ? t('you.label') : 'Claude';
  $i('replyPreviewText').textContent = content.slice(0, 120) + (content.length > 120 ? '…' : '');
  $i('replyPreview').style.display = 'flex';
  inEl.focus();
}

function clearReply() {
  replyTo = null;
  $i('replyPreview').style.display = 'none';
}

// ─── Use message as input (copy to textarea) ───
function useAsInput(btn) {
  const mw = btn.closest('.mw');
  if (!mw) return;
  const msgEl = mw.querySelector('.msg');
  if (!msgEl) return;
  // Get text content and set to input
  inEl.value = msgEl.textContent.trim();
  inEl.focus();
  // Auto-resize textarea
  inEl.style.height = 'auto';
  inEl.style.height = Math.min(inEl.scrollHeight, 200) + 'px';
}

// ─── Fork conversation (continue in new chat with context) ───
function forkFromMsg(btn) {
  const mw = btn.closest('.mw.assistant');
  if (!mw) return;

  // Find the previous user message
  let userMsg = mw.previousElementSibling;
  while (userMsg && !userMsg.classList.contains('user')) {
    userMsg = userMsg.previousElementSibling;
  }

  const userText = userMsg ? userMsg.querySelector('.msg')?.textContent?.trim() || '' : '';
  const agentText = mw.querySelector('.msg')?.textContent?.trim() || '';

  // Build context summary
  const userPreview = userText.slice(0, 300);
  const agentPreview = agentText.slice(0, 500);
  const contextMsg = `[Context from previous conversation]
User asked: "${userPreview}${userText.length > 300 ? '…' : ''}"
Agent was working on: "${agentPreview}${agentText.length > 500 ? '…' : ''}"

Continue from here:`;

  // Create new tab and insert context
  newTab();

  // Small delay to ensure tab is ready
  setTimeout(() => {
    inEl.value = contextMsg;
    inEl.focus();
    // Move cursor to end
    inEl.setSelectionRange(contextMsg.length, contextMsg.length);
  }, 50);
}

// ─── Tabs ─────────────────────────────────────────────────────────────────
function renderTabs() {
  const bar = $i('tabsBar'); if (!bar) return;
  bar.innerHTML = '';
  // Header collapse toggle
  const hdrBtn = document.createElement('button');
  hdrBtn.className = 'hdr-toggle' + ($i('hdrZone')?.classList.contains('collapsed') ? ' collapsed' : '');
  hdrBtn.id = 'hdrToggleBtn';
  hdrBtn.title = t('hdr.toggle');
  hdrBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 15 12 9 18 15"/></svg>';
  hdrBtn.onclick = toggleHeader;
  bar.appendChild(hdrBtn);
  for (const tab of openTabs) {
    const el = document.createElement('div');
    el.className = 'tab' + (tab.id === activeTabId ? ' active' : '');
    el.onclick = () => switchTab(tab.id);
    let dot = '';
    if (tab.generating) dot = '<div class="tab-dot spinning"></div>';
    else if (tab.done) dot = '<div class="tab-dot done"></div>';
    const titleTip = escH(tab.title || t('tab.new'));
    el.innerHTML = `${dot}<span class="tab-title" data-tip="${titleTip}" ondblclick="event.stopPropagation();startRenameTab(event,'${tab.id}')">${escH(tab.title || t('tab.new'))}</span><button class="tab-close" onclick="event.stopPropagation();closeTab('${tab.id}')">✕</button>`;
    bar.appendChild(el);
  }
  const nb = document.createElement('button');
  nb.className = 'tab-new'; nb.title = t('tab.new'); nb.textContent = '+';
  nb.onclick = newTab;
  bar.appendChild(nb);
  // Font size slider
  const curFont = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--msg-font')) || 15.5;
  const fsWrap = document.createElement('div');
  fsWrap.className = 'font-slider-wrap';
  fsWrap.innerHTML = '<span class="fs-icon">A</span><input type="range" class="font-slider" id="fontSlider" min="12" max="22" step="0.5" value="' + curFont + '"><span class="fs-icon lg">A</span>';
  bar.appendChild(fsWrap);
  fsWrap.querySelector('.font-slider').addEventListener('input', function() { setFontSize(parseFloat(this.value)); });
  updateHistSpinners();
}

function updateHistSpinners() {
  const el = $i('histList');
  if (!el) return;
  el.querySelectorAll('.hist-item[data-sess]').forEach(item => {
    const tab = openTabs.find(t => t.id === item.dataset.sess);
    let spinner = item.querySelector('.hist-spin');
    if (tab?.generating) {
      if (!spinner) {
        spinner = document.createElement('span');
        spinner.className = 'hist-spin tab-dot spinning';
        item.insertBefore(spinner, item.firstChild);
      }
    } else {
      if (spinner) spinner.remove();
    }
  });
}

function startRenameTab(e, tabId) {
  const span = e.currentTarget;
  const tab = openTabs.find(t => t.id === tabId);
  if (!tab || tab.isNew) return;
  const origTitle = tab.title || '';
  const inp = document.createElement('input');
  inp.className = 'tab-rename-input';
  inp.value = origTitle;
  span.replaceWith(inp);
  inp.focus(); inp.select();
  let saved = false;
  const save = () => {
    if (saved) return; saved = true;
    const newTitle = inp.value.trim() || origTitle;
    saveTabRename(tabId, newTitle);
  };
  inp.addEventListener('keydown', ev => {
    if (ev.key === 'Enter') { ev.preventDefault(); save(); }
    if (ev.key === 'Escape') { saved = true; renderTabs(); }
  });
  inp.addEventListener('blur', save);
}

async function saveTabRename(tabId, newTitle) {
  const tab = openTabs.find(t => t.id === tabId);
  if (!tab) return;
  tab.title = newTitle;
  renderTabs(); loadHist();
  if (!tab.isNew) {
    try { await fetch(`/api/sessions/${tabId}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ title: newTitle }) }); } catch {}
  }
}

function openTab(id, title) {
  if (!openTabs.find(t => t.id === id))
    openTabs.push({ id, title: title || t('tab.new'), generating: false, done: false });
  switchTab(id);
}

// ─── Session info bar ─────────────────────────────────────────────────────
async function updateSessBar() {
  const bar = $i('sessBar');
  if (!bar) return;
  if (!currentSessionId) { bar.style.display = 'none'; return; }
  bar.style.display = 'flex';
  try {
    const r = await fetch(`/api/sessions/${currentSessionId}`);
    if (!r.ok) { bar.style.display = 'none'; return; }
    const sess = await r.json();
    const idEl = $i('sessBarClaudeId');
    const openBtn = $i('sessBarOpenBtn');
    if (idEl) {
      if (sess.claude_session_id) {
        idEl.style.display = '';
        idEl.textContent = sess.claude_session_id.slice(0, 8) + '…';
        idEl.title = t('session.copy_id') + ': ' + sess.claude_session_id;
        idEl.dataset.fullId = sess.claude_session_id;
      } else { idEl.style.display = 'none'; }
    }
    if (openBtn) { openBtn.style.display = sess.claude_session_id ? '' : 'none'; }
    updateSessBarSkills();
  } catch { bar.style.display = 'none'; }
}
function copySessId() {
  const id = $i('sessBarClaudeId')?.dataset?.fullId;
  if (!id) return;
  navigator.clipboard.writeText(id).then(() => toast('✓ ' + t('session.copy_id')));
}
async function openInClaude() {
  if (!currentSessionId) return;
  try {
    const r = await fetch(`/api/sessions/${currentSessionId}/open-terminal`, { method: 'POST' });
    const d = await r.json();
    if (!d.ok && d.command) {
      navigator.clipboard.writeText(d.command).then(() => toast(t('toast.cmd_copied')));
    }
  } catch {}
}


function switchTab(id) {
  if (activeTabId === id) return;
  // Save state for current tab before switching
  if (activeTabId) {
    const oldTS = getTS(activeTabId);
    oldTS.draft = inEl.value;
    oldTS.curTxt = streaming.txt; // Save via proxy (reads from old activeTabId)
    if (streaming.toolLog.length) oldTS._toolLog = streaming.toolLog.slice();
    oldTS.attachments = [..._attachments];
    oldTS.replyTo = replyTo;
  }
  // Clear only the DOM reference for the old tab — curTxt/_toolLog/_toolCounts are kept
  // so loadSess can restore them when the user switches back while Claude is still running.
  // The done/error WS handlers clear them when the session finishes in background.
  const oldTS = getTS(activeTabId);
  oldTS.curEl = null;
  // NOW switch to new tab
  activeTabId = id;
  const tab = openTabs.find(t => t.id === id);
  if (tab?.isNew) {
    currentSessionId = null;
    // Reset MCP and skills for new tab
    activeMcp = new Set();
    activeSkills = new Set();
    msgsEl.innerHTML = ''; showW(); renderProjects();
  } else {
    currentSessionId = null; // Clear stale ID immediately — updateSessBar() below will hide the bar
    loadSess(id);            // async — will set currentSessionId and refresh sessBar when done
  }
  // Restore textarea draft for new tab
  const draft = getTS(id).draft || '';
  inEl.value = draft;
  inEl.style.height = 'auto';
  inEl.style.height = Math.min(inEl.scrollHeight, 130) + 'px';
  // Restore attachments and reply-to for new tab
  _restoreAttachments(getTS(id).attachments);
  const savedReply = getTS(id).replyTo;
  if (savedReply) {
    replyTo = savedReply;
    $i('replyPreviewRole').textContent = savedReply.role === 'user' ? t('you.label') : 'Claude';
    const rc = savedReply.content || '';
    $i('replyPreviewText').textContent = rc.slice(0, 120) + (rc.length > 120 ? '…' : '');
    $i('replyPreview').style.display = 'flex';
  } else { clearReply(); }
  // Update stop button state and isGen for new tab
  const newTab = openTabs.find(t => t.id === id);
  if (newTab?.generating) {
    isGen = true;
    setSendStop(true);
    setStatus(t('status.processing'), 'warn');
  } else {
    isGen = false;
    setSendStop(false);
  }
  renderTabs(); saveUIState();
  updateSessBar();
}

function closeTab(id) {
  if (isGen && activeTabId === id) { isGen = false; setSendStop(false); generatingTabId = null; streaming.el = null; }
  const idx = openTabs.findIndex(t => t.id === id);
  if (idx === -1) return;
  openTabs.splice(idx, 1);
  delete tabState[id];
  if (activeTabId === id) {
    if (openTabs.length > 0) {
      const next = openTabs[Math.min(idx, openTabs.length - 1)];
      activeTabId = next.id;
      if (next.isNew) { currentSessionId = null; msgsEl.innerHTML = ''; showW(); renderProjects(); }
      else { currentSessionId = null; loadSess(next.id); }
    } else {
      activeTabId = null; currentSessionId = null;
      msgsEl.innerHTML = ''; showW(); renderProjects();
    }
  }
  renderTabs(); saveUIState(); updateSessBar();
}

function newTab() {
  const tempId = 'new-' + Date.now();
  if (!curProjectId) { _onProjectCreated = () => newTab(); openAddProject(); return; }
  // Save current tab's state before switching
  if (activeTabId) {
    getTS(activeTabId).draft = inEl.value;
    getTS(activeTabId).attachments = [..._attachments];
    getTS(activeTabId).replyTo = replyTo;
  }
  openTabs.push({ id: tempId, title: t('tab.new'), generating: false, done: false, isNew: true });
  activeTabId = tempId;
  currentSessionId = null;
  inEl.value = '';
  inEl.style.height = 'auto';
  _clearAttachments();
  clearReply();
  // Reset skills and mode settings for new tab — new chat = clean slate
  activeSkills = new Set();
  curAgent = 'single';
  curMode = 'auto';
  syncBtn('agent', 'single');
  syncBtn('mode', 'auto');
  msgsEl.innerHTML = ''; showW(); renderProjects(); loadHist();
  renderMcp(); renderSkills();
  userScrolled = false; renderTabs(); saveUIState(); updateSessBar();
  inEl.focus();
}

function toggle(id) {
  const el = $i(id);
  el.classList.toggle('collapsed');
  const btn = document.querySelector(`[onclick="toggle('${id}')"]`);
  if (btn) btn.classList.toggle('active', !el.classList.contains('collapsed'));
  // Mobile backdrop
  if (window.innerWidth <= 800) {
    const isOpen = !el.classList.contains('collapsed');
    let bd = $i('mobileBackdrop');
    if (!bd) {
      bd = document.createElement('div');
      bd.id = 'mobileBackdrop';
      document.body.appendChild(bd);
    }
    const anyOpen = !$i('leftPanel')?.classList.contains('collapsed') || !$i('rightPanel')?.classList.contains('collapsed');
    bd.style.display = anyOpen ? 'block' : 'none';
    bd.onclick = () => {
      if (!$i('leftPanel')?.classList.contains('collapsed')) toggle('leftPanel');
      if (!$i('rightPanel')?.classList.contains('collapsed')) toggle('rightPanel');
    };
  }
  saveUIState();
}
function toggleSec(id) {
  const body = $i(id + 'Body');
  body.classList.toggle('collapsed');
  const title = body.previousElementSibling;
  if (title) title.setAttribute('aria-expanded', String(!body.classList.contains('collapsed')));
  saveUIState();
}

function toggleHeader() {
  const zone = $i('hdrZone');
  if (!zone) return;
  zone.classList.toggle('collapsed');
  const btn = $i('hdrToggleBtn');
  if (btn) btn.classList.toggle('collapsed', zone.classList.contains('collapsed'));
  saveUIState();
}

function setFontSize(px) {
  document.documentElement.style.setProperty('--msg-font', px + 'px');
  saveUIState();
}

const MSG_CLAMP_THRESHOLD = 300;
function applyMsgClamp(mw) {
  if (!mw) return;
  const msgEl = mw.querySelector('.msg');
  if (!msgEl || msgEl.classList.contains('msg-clamp') || msgEl.dataset.clampChecked) return;
  msgEl.dataset.clampChecked = '1';
  if (msgEl.scrollHeight <= MSG_CLAMP_THRESHOLD) return;
  msgEl.classList.add('msg-clamp');
  const btn = document.createElement('button');
  btn.className = 'msg-expand-btn';
  btn.textContent = t('msg.show_more');
  btn.onclick = () => {
    const isExpanded = msgEl.classList.toggle('expanded');
    btn.textContent = isExpanded ? t('msg.show_less') : t('msg.show_more');
  };
  msgEl.after(btn);
}

// ─── Toolbar ─────────────────────────────────────────────────────────────
function setOpt(btn, group) {
  btn.closest('.tb-group').querySelectorAll('.tb-btn').forEach(b => b.classList.remove('on'));
  btn.classList.add('on');
  const v = btn.dataset.v;
  if (group === 'mode') curMode = v;
  else if (group === 'agent') curAgent = v;
  else if (group === 'model') curModel = v;
  updInd();
}

function updInd() { /* removed — mode indicator no longer in toolbar */ }

function updateSessBarSkills() {
  const el = $i('sessBarSkills');
  if (!el) return;
  el.innerHTML = '';
  // Auto-skills mode badge
  if (autoSkillsMode) {
    const auto = document.createElement('span');
    auto.className = 'sess-skill-chip sess-skill-auto';
    auto.textContent = '⚡ Auto';
    auto.title = t('auto.title.on') || 'Skills are auto-selected based on task';
    el.appendChild(auto);
  }
  // Show active skill chips (filter out 'auto-mode' meta-skill)
  if (activeSkills && activeSkills.size > 0) {
    for (const id of activeSkills) {
      if (id === 'auto-mode') continue;
      const s = config.skills?.[id];
      if (!s) continue;
      const chip = document.createElement('span');
      chip.className = 'sess-skill-chip';
      chip.textContent = s.label || id;
      chip.title = s.description || id;
      el.appendChild(chip);
    }
  }
}

function syncBtn(group, val) {
  const groups = { mode: ['auto','planning','task'], agent: ['single','multi'], model: ['haiku','sonnet','opus'] };
  if (!groups[group]?.includes(val)) return;
  document.querySelectorAll('.tb-group .tb-btn').forEach(b => {
    if (b.dataset.v === val) {
      b.closest('.tb-group').querySelectorAll('.tb-btn').forEach(x => x.classList.remove('on'));
      b.classList.add('on');
    }
  });
}

// ─── Attachments (@ files + clipboard screenshots) ───────────────────────
let _attachments = []; // [{id, type:'file'|'image', name, relPath, absPath, projectDir, base64, mimeType}]

function _getChips() { return $i('attChips'); }

function _addFileChip(file) {
  if (_attachments.find(a => a.type === 'file' && a.absPath === file.absPath)) return;
  const id = 'att-' + Date.now() + Math.random().toString(36).slice(2, 6);
  _attachments.push({ id, type: 'file', name: file.name, relPath: file.relPath, absPath: file.absPath, projectDir: curWorkdir });
  const chip = document.createElement('div');
  chip.className = 'att-chip'; chip.dataset.attId = id;
  chip.innerHTML = `<span class="chip-icon">📄</span><span class="chip-name" data-tip="${escH(file.relPath)}">${escH(file.name)}</span><button class="chip-rm" onclick="rmChip('${id}')" title="${t('chip.remove')}">✕</button>`;
  _getChips().appendChild(chip);
}

function _addImageChip(base64, mimeType, name) {
  const id = 'att-' + Date.now() + Math.random().toString(36).slice(2, 6);
  _attachments.push({ id, type: 'image', name: name || 'screenshot.png', base64, mimeType });
  const chip = document.createElement('div');
  chip.className = 'att-chip chip-img'; chip.dataset.attId = id;
  chip.innerHTML = `<img src="data:${mimeType};base64,${base64}" alt=""><span class="chip-name">${escH(name || 'screenshot.png')}</span><button class="chip-rm" onclick="rmChip('${id}')" title="${t('chip.remove')}">✕</button>`;
  _getChips().appendChild(chip);
}

function _addLocalFileChip(name, base64, mimeType) {
  const id = 'att-' + Date.now() + Math.random().toString(36).slice(2, 6);
  _attachments.push({ id, type: 'file', name, base64, mimeType: mimeType || 'application/octet-stream', local: true });
  const chip = document.createElement('div');
  chip.className = 'att-chip'; chip.dataset.attId = id;
  chip.innerHTML = `<span class="chip-icon">📎</span><span class="chip-name" title="${escH(name)}">${escH(name)}</span><button class="chip-rm" onclick="rmChip('${id}')" title="${t('chip.remove')}">✕</button>`;
  _getChips().appendChild(chip);
}

function onFilePicker(input) {
  const files = Array.from(input.files);
  input.value = ''; // reset so same file can be re-selected
  for (const file of files) {
    const reader = new FileReader();
    if (file.type.startsWith('image/')) {
      reader.onload = ev => {
        const base64 = ev.target.result.split(',')[1];
        _addImageChip(base64, file.type, file.name);
      };
      reader.readAsDataURL(file);
    } else {
      reader.onload = ev => {
        const base64 = ev.target.result.split(',')[1];
        _addLocalFileChip(file.name, base64, file.type || 'text/plain');
      };
      reader.readAsDataURL(file);
    }
  }
}

function rmChip(id) {
  _attachments = _attachments.filter(a => a.id !== id);
  const el = document.querySelector(`[data-att-id="${id}"]`);
  if (el) el.remove();
}

function _clearAttachments() {
  _attachments = [];
  _getChips().innerHTML = '';
}

// Restore saved attachments — rebuild chips from saved array
function _restoreAttachments(saved) {
  _clearAttachments();
  if (!saved?.length) return;
  for (const att of saved) {
    // Re-add each saved attachment — the _add* functions create new IDs and push to _attachments
    if (att.type === 'image') {
      _addImageChip(att.base64, att.mimeType, att.name);
    } else if (att.local) {
      _addLocalFileChip(att.name, att.base64, att.mimeType);
    } else {
      // Project file — pass the original object (has name, relPath, absPath)
      _addFileChip({ name: att.name, relPath: att.relPath, absPath: att.absPath });
    }
  }
}

// ─── @ File picker ────────────────────────────────────────────────────────
let _atTimer = null, _atFiles = [], _atActiveIdx = -1, _atMode = false;

function _openAtPopup(query) {
  const popup = $i('atPopup'), s = $i('atSearch');
  popup.classList.remove('hidden');
  s.value = query;
  _atActiveIdx = -1;
  _atMode = true;
  _fetchAtFiles(query);
}

function _closeAtPopup() {
  $i('atPopup').classList.add('hidden');
  _atMode = false; _atFiles = []; _atActiveIdx = -1;
}

async function _fetchAtFiles(query) {
  if (!curWorkdir) {
    $i('atList').innerHTML = `<div class="at-empty">${t('at.no_project')}</div>`;
    return;
  }
  $i('atList').innerHTML = `<div class="at-loading">${t('at.searching')}</div>`;
  try {
    const r = await fetch(`/api/project-files?dir=${encodeURIComponent(curWorkdir)}&q=${encodeURIComponent(query)}`);
    const d = await r.json();
    _atFiles = d.files || [];
    _renderAtList();
  } catch { $i('atList').innerHTML = `<div class="at-empty">${t('at.search_err')}</div>`; }
}

function _renderAtList() {
  const list = $i('atList');
  if (!_atFiles.length) { list.innerHTML = `<div class="at-empty">${t('at.no_files')}</div>`; return; }
  list.innerHTML = _atFiles.slice(0, 60).map((f, i) => {
    const slashIdx = f.relPath.lastIndexOf('/');
    const dir = slashIdx > 0 ? f.relPath.slice(0, slashIdx) : '.';
    return `
    <div class="at-item${i === _atActiveIdx ? ' active' : ''}" onclick="selectAtFile(${i})">
      <span class="at-icon">📄</span>
      <div class="at-info">
        <span class="at-name">${escH(f.name)}</span>
        <span class="at-dir">${escH(dir)}</span>
      </div>
    </div>`;
  }).join('');
}

function selectAtFile(idx) {
  const f = _atFiles[idx]; if (!f) return;
  _addFileChip(f);
  // Remove @query from textarea
  const val = inEl.value, cur = inEl.selectionStart;
  const before = val.slice(0, cur), atIdx = before.lastIndexOf('@');
  if (atIdx >= 0) {
    inEl.value = val.slice(0, atIdx) + val.slice(cur);
    inEl.selectionStart = inEl.selectionEnd = atIdx;
  }
  _closeAtPopup(); inEl.focus();
}

function onAtSearch(query) {
  clearTimeout(_atTimer);
  _atTimer = setTimeout(() => _fetchAtFiles(query), 180);
}

// Input: watch for @ trigger
inEl.addEventListener('input', () => {
  const val = inEl.value, cur = inEl.selectionStart;
  const before = val.slice(0, cur);
  const atIdx = before.lastIndexOf('@');
  if (atIdx >= 0) {
    const afterAt = before.slice(atIdx + 1);
    if (!afterAt.includes(' ') && !afterAt.includes('\n')) {
      _openAtPopup(afterAt); return;
    }
  }
  if (!$i('atPopup').classList.contains('hidden')) _closeAtPopup();
});

// Keyboard navigation inside @ popup
inEl.addEventListener('keydown', e => {
  if ($i('atPopup').classList.contains('hidden')) return;
  if (e.key === 'Escape') { _closeAtPopup(); e.preventDefault(); return; }
  if (e.key === 'ArrowDown') { e.preventDefault(); _atActiveIdx = Math.min(_atActiveIdx + 1, _atFiles.length - 1); _renderAtList(); $i('atList').querySelector('.active')?.scrollIntoView({ block: 'nearest' }); return; }
  if (e.key === 'ArrowUp') { e.preventDefault(); _atActiveIdx = Math.max(_atActiveIdx - 1, -1); _renderAtList(); return; }
  if ((e.key === 'Enter' || e.key === 'Tab') && _atActiveIdx >= 0) { e.preventDefault(); selectAtFile(_atActiveIdx); return; }
});

// Close popup on click outside
document.addEventListener('click', e => {
  const popup = $i('atPopup');
  if (popup && !popup.classList.contains('hidden') && !popup.contains(e.target) && e.target !== inEl) _closeAtPopup();
});

// ─── Clipboard paste (screenshots) ───────────────────────────────────────
inEl.addEventListener('paste', e => {
  const items = e.clipboardData?.items;
  if (!items) return;
  for (const item of items) {
    if (!item.type.startsWith('image/')) continue;
    e.preventDefault();
    const blob = item.getAsFile(); if (!blob) continue;
    const reader = new FileReader();
    reader.onload = ev => {
      const dataUrl = ev.target.result;
      const base64 = dataUrl.split(',')[1];
      const ts = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
      _addImageChip(base64, item.type, `screenshot-${ts}.png`);
    };
    reader.readAsDataURL(blob);
    break;
  }
});

// ─── Send / Stop ─────────────────────────────────────────────────────────
async function send() {
  if (!ws || ws.readyState !== 1) { toast(t('toast.no_connection'), true); return; }

  const txt = inEl.value.trim();
  if (!txt && !_attachments.length) return;

  // Require a project before sending the first message in a new session
  if (!curProjectId && !currentSessionId) {
    _onProjectCreated = () => send();
    openAddProject();
    return;
  }

  // Collect attachment payloads (fetch file contents for @ mentions)
  const attSnapshot = [..._attachments];
  _clearAttachments();
  _closeAtPopup();

  const msgAttachments = [];
  for (const att of attSnapshot) {
    if (att.type === 'image') {
      msgAttachments.push({ type: att.mimeType, base64: att.base64, name: att.name });
    } else if (att.type === 'file') {
      if (att.local && att.base64) {
        // Local file picked via file dialog — content already read client-side
        msgAttachments.push({ type: att.mimeType || 'text/plain', name: att.name, base64: att.base64 });
      } else {
        try {
          const r = await fetch(`/api/project-files/read?path=${encodeURIComponent(att.absPath)}&dir=${encodeURIComponent(att.projectDir)}`);
          const d = await r.json();
          if (d.content !== undefined) msgAttachments.push({ type: 'text/plain', name: att.relPath || att.name, base64: btoa(unescape(encodeURIComponent(d.content))) });
        } catch { toast(t('toast.read_err') + att.name, true); }
      }
    }
  }

  const msgEl = addMsg('user', replyTo ? { replyQuote: { quotedRole: replyTo.role, quotedContent: replyTo.content } } : {});
  // Show file/image chips in message bubble
  if (attSnapshot.length) {
    const chipsDiv = document.createElement('div');
    chipsDiv.className = 'att-chips';
    chipsDiv.style.cssText = 'padding:4px 0 2px';
    chipsDiv.innerHTML = attSnapshot.map(a => a.type === 'image'
      ? `<div class="att-chip chip-img"><img src="data:${a.mimeType};base64,${a.base64}" alt=""><span class="chip-name">${escH(a.name)}</span></div>`
      : `<div class="att-chip"><span class="chip-icon">📄</span><span class="chip-name">${escH(a.relPath || a.name)}</span></div>`
    ).join('');
    msgEl.querySelector('.msg').before(chipsDiv);
  }
  if (txt) msgEl.querySelector('.msg').textContent = txt;

  inEl.value = '';
  inEl.style.height = 'auto';
  userScrolled = false;

  const queueId = (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).slice(2));

  const activeTab = openTabs.find(t => t.id === activeTabId);
  const tabIsGenerating = activeTab?.generating || false;

  if (tabIsGenerating) {
    msgEl.dataset.queueId = queueId;
    const q = document.createElement('div');
    q.className = 'msg-queued';
    q.innerHTML = `<span class="mq-label">${t('queue.label')}</span><button class="qd-btn qd-edit" onclick="editQueuedMsg(this)" title="${t('queue.edit.title')}">✏</button><button class="qd-btn qd-del" onclick="deleteQueuedMsg(this)" title="${t('queue.del.title')}">✕</button>`;
    msgEl.appendChild(q);
  } else {
    // Auto-create a tab if project is active but no tab is open
    if (!activeTabId && curProjectId) {
      const tempId = 'new-' + Date.now();
      openTabs.push({ id: tempId, title: t('tab.new'), generating: false, done: false, isNew: true });
      activeTabId = tempId;
      currentSessionId = null;
      renderTabs();
    }
    isGen = true;
    generatingTabId = activeTabId;
    if (activeTabId) { const at = openTabs.find(x => x.id === activeTabId); if (at) { at.generating = true; renderTabs(); } }
    showStatus(t('status.processing'));
    setStatus(t('status.processing'), 'warn');
    setSendStop(true);
  }

  const currentReply = replyTo;
  clearReply();

  // Auto-skill selection
  if (autoSkillsMode && txt && txt.trim().length > 3) {
    const autoSelected = autoSelectSkills(txt);
    if (autoSelected.length > 0) {
      activeSkills = new Set(autoSelected);
      renderSkills(); updateSessBarSkills();
      // Filter out the meta-skill from the toast display (it's always included)
      const displaySkills = autoSelected.filter(id => id !== 'auto-mode');
      if (displaySkills.length > 0) {
        const names = displaySkills.map(id => (config.skills[id]?.label || id).replace(/^\S+\s/, '')).join(', ');
        toast('⚡ ' + names);
      }
    } else if (config.skills['auto-mode']) {
      // No specific skill matched — still apply auto-mode meta-skill for quality
      activeSkills = new Set(['auto-mode']);
      renderSkills(); updateSessBarSkills();
    }
  }

  if (curAgent === 'dispatch') {
    // Plan mode: decompose → dispatch to Kanban (not run in chat)
    ws.send(JSON.stringify({
      type: 'dispatch_plan', text: txt || ' ',
      tabId: activeTabId,
      sessionId: currentSessionId || undefined,
      model: curModel,
      workdir: curWorkdir || undefined,
    }));
  } else {
    ws.send(JSON.stringify({
      type: 'chat', text: txt || ' ',
      tabId: activeTabId,
      sessionId: currentSessionId || undefined,
      attachments: msgAttachments.length ? msgAttachments : undefined,
      queueId,
      reply_to: currentReply || undefined,
      skills: [...activeSkills],
      mcpServers: [...activeMcp],
      mode: curMode, agentMode: curAgent,
      model: curModel,
      maxTurns: parseInt($i('maxTurns').value) || 30,
      workdir: curWorkdir || undefined,
    }));
  }
}

function newSession() { newTab(); }

// ─── Queue edit / delete ──────────────────────────────────────────────────
function editQueuedMsg(btn) {
  const msgEl = btn.closest('.mw');
  if (!msgEl) return;
  const msgDiv = msgEl.querySelector('.msg');
  if (!msgDiv) return;
  const currentText = msgDiv.textContent;
  msgEl.dataset.originalText = currentText;

  const editor = document.createElement('div');
  editor.className = 'queue-editor';
  editor.innerHTML = `<textarea class="queue-edit-area" onkeydown="queueEditKey(event)">${escH(currentText)}</textarea><div class="queue-edit-btns"><button class="qe-cancel" onclick="cancelQueueEdit(this)">${t('queue.cancel')}</button><button class="qe-save" onclick="saveQueueEdit(this)">${t('queue.save')}</button></div>`;
  msgDiv.replaceWith(editor);

  const ta = editor.querySelector('.queue-edit-area');
  ta.style.height = 'auto';
  ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
  ta.focus();
  ta.setSelectionRange(ta.value.length, ta.value.length);
}

function queueEditKey(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    saveQueueEdit(e.target.closest('.queue-editor').querySelector('.qe-save'));
  }
  if (e.key === 'Escape') {
    cancelQueueEdit(e.target.closest('.queue-editor').querySelector('.qe-cancel'));
  }
}

function saveQueueEdit(btn) {
  const msgEl = btn.closest('.mw');
  if (!msgEl) return;
  const editor = btn.closest('.queue-editor');
  const newText = editor.querySelector('.queue-edit-area').value.trim();
  if (!newText) return;

  const queueId = msgEl.dataset.queueId;
  delete msgEl.dataset.originalText;

  const msgDiv = document.createElement('div');
  msgDiv.className = 'msg';
  msgDiv.textContent = newText;
  editor.replaceWith(msgDiv);

  if (ws && ws.readyState === 1) {
    ws.send(JSON.stringify({ type: 'queue_edit', queueId, text: newText }));
  }
}

function cancelQueueEdit(btn) {
  const msgEl = btn.closest('.mw');
  if (!msgEl) return;
  const editor = btn.closest('.queue-editor');
  const originalText = msgEl.dataset.originalText || editor.querySelector('.queue-edit-area').value;
  delete msgEl.dataset.originalText;

  const msgDiv = document.createElement('div');
  msgDiv.className = 'msg';
  msgDiv.textContent = originalText;
  editor.replaceWith(msgDiv);
}

function deleteQueuedMsg(btn) {
  const msgEl = btn.closest('.mw');
  if (!msgEl) return;
  const queueId = msgEl.dataset.queueId;

  // Optimistic UI: fade out and disable
  msgEl.style.opacity = '0.4';
  msgEl.style.pointerEvents = 'none';
  msgEl.style.transition = 'opacity .2s';

  if (ws && ws.readyState === 1) {
    ws.send(JSON.stringify({ type: 'queue_remove', queueId }));
  }
}

// Input auto-resize
inEl.addEventListener('input', () => {
  inEl.style.height = 'auto';
  inEl.style.height = Math.min(inEl.scrollHeight, 120) + 'px';
});
inEl.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey) {
    if (!$i('atPopup').classList.contains('hidden')) return; // let @ handler deal with it
    e.preventDefault(); send();
  }
});

// ─── (Stats panel removed) ────────────────────────────────────────────────

function loadStats() { /* removed */ }

// ─── Version check ────────────────────────────────────────────────────────
async function checkVersion() {
  try {
    const local = await fetch('/api/version').then(r => r.json());
    const el = $i('versionBadge');
    if (!el) return;
    const cur = local.version || '?';
    el.textContent = `v${cur}`;
    el.title = t('ver.current');
    try {
      const gh = await fetch('https://api.github.com/repos/Lexus2016/claude-code-studio/releases/latest',
        { headers: { Accept: 'application/vnd.github.v3+json' } }).then(r => r.json());
      const latest = (gh.tag_name || '').replace(/^v/, '');
      if (latest && latest !== cur) {
        el.textContent = `v${cur} → v${latest} ↑`;
        el.className = 'update';
        el.title = t('ver.update').replace('{tag}', gh.tag_name);
        el.onclick = () => window.open(gh.html_url, '_blank');
      } else if (latest) {
        el.title = `v${cur}${t('ver.latest')}`;
      }
    } catch { /* GitHub API unavailable, keep local version only */ }
  } catch { /* API not ready */ }
}

// ─── Session History ──────────────────────────────────────────────────────
let histSelectMode = false;
const histSelected = new Set();

async function loadHist() {
  try {
    const el = $i('histList');
    if (!curWorkdir) { el.innerHTML = ''; $i('histCount').textContent = ''; return; }
    const r = await fetch(`/api/sessions?workdir=${encodeURIComponent(curWorkdir)}`);
    const ss = await r.json();
    el.innerHTML = '';
    el.classList.toggle('hist-selmode', histSelectMode);
    $i('histCount').textContent = ss.length || '';
    for (const s of ss) {
      const d = document.createElement('div');
      const isSel = histSelected.has(String(s.id));
      d.className = `hist-item ${s.id === currentSessionId ? 'active' : ''} ${isSel ? 'selected' : ''}`;
      d.dataset.sess = s.id;
      d.setAttribute('role', 'button');
      d.setAttribute('tabindex', '0');
      const dt = new Date(s.updated_at).toLocaleDateString(localStorage.getItem('lang') || 'uk', { day: 'numeric', month: 'short' });
      d.innerHTML = `<input type="checkbox" class="hist-chk" ${isSel ? 'checked' : ''} onclick="event.stopPropagation();toggleSessCheck('${s.id}',this)"><span class="ht" data-tip="${escH(s.title)}">${escH(s.title)}</span><span class="hd">${dt}</span><button class="del" onclick="event.stopPropagation();delSess('${s.id}')" title="✕">✕</button>`;
      if (histSelectMode) {
        d.onclick = (e) => { const chk = d.querySelector('.hist-chk'); chk.checked = !chk.checked; toggleSessCheck(s.id, chk); };
      } else {
        d.onclick = () => openTab(s.id, s.title);
      }
      d.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); histSelectMode ? d.click() : openTab(s.id, s.title); } };
      el.appendChild(d);
    }
    updateHistSpinners();
  } catch (e) { console.error('loadHist:', e); }
}

// ─── Message pagination ───────────────────────────────────────────────────
const MSG_PAGE = 50;
let _allMsgs = [];   // all messages for current session (in memory)
let _shownFrom = 0;  // index in _allMsgs from which messages are rendered
const _retryingSessions = new Set(); // prevents duplicate retries from resume_task + subscribe_session

// Format message timestamp: "25.02 14:32" or "14:32" if today
function formatMsgTime(isoStr) {
  if (!isoStr) return '';
  const d = new Date(isoStr);
  const now = new Date();
  const isToday = d.getDate() === now.getDate() && d.getMonth() === now.getMonth() && d.getFullYear() === now.getFullYear();
  const time = d.toLocaleTimeString('uk-UA', { hour: '2-digit', minute: '2-digit' });
  if (isToday) return time;
  const date = d.toLocaleDateString('uk-UA', { day: '2-digit', month: '2-digit' });
  return `${date} ${time}`;
}

function _renderMsgAt(idx, prepend = false) {
  const m = _allMsgs[idx];
  // Render agent_plan messages as inline cards (not as regular messages)
  if (m._agentPlan) {
    const ap = m._agentPlan;
    const card = document.createElement('div');
    card.className = 'agent-team-card';
    if (m.id) card.dataset.msgId = String(m.id);
    const agents = ap.agents || [];
    card.innerHTML = `
      <div class="atc-header">
        <div class="atc-icon">${ap.dispatched ? '📋' : '🤖'}</div>
        <div>
          <div class="atc-title">${ap.dispatched ? 'Plan → Kanban' : escH(t('msf.team'))}</div>
          <div class="atc-plan" title="${escH(ap.plan || '')}">${escH(ap.plan || '')}</div>
        </div>
      </div>
      <div class="atc-agents">
        ${agents.map(a => `
          <div class="atc-row" data-agent-id="${escH(a.id)}">
            <span class="atc-dot"></span>
            <span class="atc-id">${escH(a.id)}</span>
            <span class="atc-role">${escH(a.role || '')}</span>
            <span class="atc-task">${escH(a.task || '')}</span>
          </div>
        `).join('')}
      </div>
      <div class="atc-footer">
        <span class="atc-count">${ap.dispatched ? '✅' : `0/${agents.length}`}</span>
        <div class="atc-progress"><div class="atc-progress-bar" style="width:${ap.dispatched ? '100%' : '0%'}"></div></div>
      </div>`;
    // Restore _atcPlanData for potential re-dispatch
    _atcPlanData = { plan: ap.plan, agents };
    if (prepend) {
      const firstMsg = msgsEl.querySelector('.mw, .agent-team-card');
      if (firstMsg) msgsEl.insertBefore(card, firstMsg);
      else msgsEl.prepend(card);
    } else {
      msgsEl.appendChild(card);
    }
    return card;
  }
  const hasReply = _allMsgs.slice(idx + 1).some(x => x.role === 'assistant');
  const w = document.createElement('div');
  w.className = `mw ${m.role}`;
  if (m.id) w.dataset.msgId = String(m.id);
  // Build reply quote from reply_to_id (history re-hydration)
  let histQuoteHtml = '';
  if (m.reply_to_id) {
    const refMsg = _allMsgs.find(x => x.id === m.reply_to_id);
    if (refMsg) {
      const roleName = refMsg.role === 'user' ? t('you.label') : 'Claude';
      const preview = escH((refMsg.content || '').slice(0, 120) + (refMsg.content?.length > 120 ? '…' : ''));
      histQuoteHtml = `<div class="msg-reply-quote"><span class="rq-role">${escH(roleName)}</span><span class="rq-text">${preview}</span></div>`;
    }
  }
  const forkBtn = m.role === 'assistant' ? `<button class="fork-btn" onclick="forkFromMsg(this)" title="${t('fork.title')}">↗</button>` : '';
  const useBtn = `<button class="use-btn" onclick="useAsInput(this)" title="${t('use.input')}">↓</button>`;
  // Format timestamp
  const timeHtml = m.created_at ? `<div class="msg-time">${formatMsgTime(m.created_at)}</div>` : '';
  w.innerHTML = `${histQuoteHtml}<div class="msg"></div>${timeHtml}<button class="cpb" onclick="cpMsg(this)" title="${t('copy.msg')}"><svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></button><button class="reply-btn" onclick="setReply(this)" title="${t('msg.reply')}">↩</button>${forkBtn}${useBtn}`;
  // Render saved attachments (images/files) as chips above message text
  if (m.attachments) {
    try {
      const atts = typeof m.attachments === 'string' ? JSON.parse(m.attachments) : m.attachments;
      if (Array.isArray(atts) && atts.length) {
        const chipsDiv = document.createElement('div');
        chipsDiv.className = 'att-chips';
        chipsDiv.style.cssText = 'padding:4px 0 2px';
        chipsDiv.innerHTML = atts.map(a =>
          a.type && a.type.startsWith('image/')
            ? `<div class="att-chip chip-img"><img src="data:${escH(a.type)};base64,${a.base64}" alt=""><span class="chip-name">${escH(a.name || 'image')}</span></div>`
            : `<div class="att-chip"><span class="chip-icon">📄</span><span class="chip-name">${escH(a.name || 'file')}</span></div>`
        ).join('');
        w.querySelector('.msg').before(chipsDiv);
      }
    } catch {}
  }
  if (m.role === 'assistant' && m.type === 'agent_plan') {
    // Render as interactive agent plan card (restored from DB)
    try {
      const pd = JSON.parse(m.content);
      if (pd.agents?.length) {
        const cardHtml = `
          <div class="agent-team-card" style="margin:0">
            <div class="atc-header">
              <div class="atc-icon">${pd.dispatched ? '📋' : '🤖'}</div>
              <div>
                <div class="atc-title">${pd.dispatched ? 'Plan → Kanban' : escH(t('msf.team'))}</div>
                <div class="atc-plan" title="${escH(pd.plan || '')}">${escH(pd.plan || '')}</div>
              </div>
            </div>
            <div class="atc-agents">
              ${pd.agents.map(a => `
                <div class="atc-row atc-done" data-agent-id="${escH(a.id)}">
                  <span class="atc-dot"></span>
                  <span class="atc-id">${escH(a.id)}</span>
                  <span class="atc-role">${escH(a.role)}</span>
                  <span class="atc-task">${escH(a.task || '')}</span>
                </div>
              `).join('')}
            </div>
            <div class="atc-footer">
              <span class="atc-count">${pd.agents.length}/${pd.agents.length}</span>
              <div class="atc-progress"><div class="atc-progress-bar" style="width:100%"></div></div>
            </div>
          </div>`;
        w.querySelector('.msg').innerHTML = cardHtml;
      } else {
        w.querySelector('.msg').innerHTML = renderMd(m.content);
      }
    } catch {
      w.querySelector('.msg').innerHTML = renderMd(m.content);
    }
  } else if (m.role === 'assistant') {
    w.querySelector('.msg').innerHTML = renderMd(m.content);
  } else {
    w.querySelector('.msg').textContent = m.content;
    if (hasReply) { const a = document.createElement('div'); a.className = 'msg-ack'; a.textContent = '✓'; w.appendChild(a); }
  }
  // Render tool activity summary for historical assistant messages
  if (m.role === 'assistant' && m._tools) {
    _renderToolActivity(w, m._tools);
  }
  // Add "Done" footer for completed assistant messages in history
  // Show on the last assistant msg before a user msg or end of conversation
  if (m.role === 'assistant' && m.type !== 'agent_plan') {
    const next = _allMsgs[idx + 1];
    if (!next || next.role === 'user') {
      w.appendChild(_msfCreate('done', t('msf.done')));
    }
  }
  if (m.agent_id) addAgentBadge(w, m.agent_id);
  if (prepend) {
    const firstMsg = msgsEl.querySelector('.mw');
    if (firstMsg) msgsEl.insertBefore(w, firstMsg);
    else msgsEl.prepend(w);
  } else {
    msgsEl.appendChild(w);
  }
  applyMsgClamp(w);
  return w;
}

function _updateLoadMoreBtn() {
  let btn = document.getElementById('loadMoreBtn');
  const remaining = _shownFrom; // messages before current visible range
  if (remaining <= 0) {
    if (btn) btn.remove();
    return;
  }
  if (!btn) {
    const wrap = document.createElement('div');
    wrap.id = 'loadMoreBtn';
    wrap.className = 'load-more-wrap';
    wrap.innerHTML = `<button class="load-more-btn" onclick="loadMoreMsgs()">${t('load.more')} (${remaining})</button>`;
    const firstMsg = msgsEl.querySelector('.mw');
    if (firstMsg) msgsEl.insertBefore(wrap, firstMsg);
    else msgsEl.prepend(wrap);
  } else {
    btn.querySelector('button').textContent = `${t('load.more')} (${remaining})`;
  }
}

function loadMoreMsgs() {
  if (_shownFrom <= 0) return;
  const prevHeight = msgsEl.scrollHeight;
  const prevScroll = msgsEl.scrollTop;
  const start = Math.max(0, _shownFrom - MSG_PAGE);
  const end = _shownFrom;
  // Prepend in reverse order so DOM order stays chronological
  for (let i = end - 1; i >= start; i--) {
    _renderMsgAt(i, true);
  }
  _shownFrom = start;
  _updateLoadMoreBtn();
  // Maintain scroll position after prepend
  requestAnimationFrame(() => {
    msgsEl.scrollTop = prevScroll + (msgsEl.scrollHeight - prevHeight);
  });
}

async function loadSess(id) {
  try {
    const r = await fetch(`/api/sessions/${id}`);
    if (id !== activeTabId) return; // tab was switched while fetching — discard stale load
    if (!r.ok) { closeTab(id); toast(t('toast.sess_not_found'), true); return; }
    const d = await r.json();
    if (id !== activeTabId) return; // tab was switched while parsing — discard stale load
    streaming.el = null; streaming.txt = ''; streaming.toolCounts = {}; streaming.toolLog = []; // Reset streaming state before clearing DOM — prevents stale references
    msgsEl.removeAttribute('aria-live'); // Suppress screen reader flood during batch history load
    msgsEl.innerHTML = '';
    currentSessionId = id;
    updateSessBar(); // Refresh session bar with correct data now that currentSessionId is set
    // Sync tab title
    { const t = openTabs.find(x => x.id === id); if (t && d.title) { t.title = d.title; renderTabs(); } }
    // Proactively show spinner if a task is currently running for this session
    // (avoids waiting for WS task_started roundtrip, especially after page refresh)
    if (d.hasRunningTask) {
      const tabObj = openTabs.find(x => x.id === id);
      if (tabObj) { tabObj.generating = true; renderTabs(); }
    }

    if (d.mode) { curMode = d.mode; syncBtn('mode', d.mode); }
    if (d.agent_mode) { curAgent = d.agent_mode; syncBtn('agent', d.agent_mode); }
    if (d.model) { curModel = d.model; syncBtn('model', d.model); }
    updInd();

    curWorkdir = d.workdir || null;
    curProjectId = curWorkdir ? (projects.find(p => p.workdir === curWorkdir)?.id || null) : null;
    renderProjects();

    try {
      const _smcp = JSON.parse(d.active_mcp || '[]');
      if (_smcp.length > 0) {
        // Filter out stale IDs that no longer exist in config (e.g. server was deleted)
        const valid = _smcp.filter(id => config.mcpServers[id]);
        if (valid.length > 0) activeMcp = new Set(valid);
      }
      // If session has no MCPs saved (or all were stale), keep current global activeMcp
    } catch { /* keep current activeMcp */ }
    try { activeSkills = new Set(JSON.parse(d.active_skills || '[]')); } catch { activeSkills = new Set(); }
    renderMcp(); renderSkills();

    // Build display messages, attaching tool activity counts to each assistant text message.
    // Multi-agent: tools grouped by agent_id (tools may arrive before/after text in any order).
    // Single mode: backward-scan for consecutive tool rows preceding the text message.
    // (Tools are saved to DB as they stream, text is saved last in onDone — so tools always
    //  have lower DB ids than their corresponding assistant text message.)
    {
      const raw = d.messages || [];
      _allMsgs = [];
      // Pre-compute tool counts per agent_id for multi-agent sessions
      const _agentTools = {};
      for (const m of raw) {
        if (m.type === 'tool' && m.agent_id) {
          if (!_agentTools[m.agent_id]) _agentTools[m.agent_id] = {};
          const tn = m.tool_name || 'tool';
          _agentTools[m.agent_id][tn] = (_agentTools[m.agent_id][tn] || 0) + 1;
        }
      }
      for (let i = 0; i < raw.length; i++) {
        const m = raw[i];
        if (m.type === 'tool') continue;
        // agent_plan messages: parse JSON content and mark for card rendering
        if (m.type === 'agent_plan') {
          try {
            const parsed = JSON.parse(m.content);
            m._agentPlan = parsed; // { plan, agents, dispatched }
          } catch {}
          _allMsgs.push(m);
          continue;
        }
        if (m.role === 'assistant' && m.type === 'text') {
          if (m.agent_id && _agentTools[m.agent_id]) {
            // Multi-agent: all tools for this agent (regardless of DB order)
            m._tools = _agentTools[m.agent_id];
          } else if (!m.agent_id) {
            // Single mode: scan backward for consecutive tool rows before this text message
            const tc = {};
            for (let j = i - 1; j >= 0; j--) {
              if (raw[j].type !== 'tool' || raw[j].agent_id) break;
              const tn = raw[j].tool_name || 'tool';
              tc[tn] = (tc[tn] || 0) + 1;
            }
            if (Object.keys(tc).length) m._tools = tc;
          }
        }
        _allMsgs.push(m);
      }
    }
    _shownFrom = Math.max(0, _allMsgs.length - MSG_PAGE);

    for (let i = _shownFrom; i < _allMsgs.length; i++) {
      _renderMsgAt(i, false);
    }
    _updateLoadMoreBtn();
    msgsEl.setAttribute('aria-live', 'polite'); // Re-enable after batch load is done

    // Restore done checkmark on last assistant message if tab finished generating
    const tabDone = openTabs.find(x => x.id === id);
    if (tabDone?.done && !d.hasRunningTask && !d.isChatRunning) {
      const lastAssist = [...msgsEl.querySelectorAll('.mw.assistant')].pop();
      if (lastAssist && !_msfGet(lastAssist)) {
        lastAssist.appendChild(_msfCreate('done', t('msf.done')));
      }
    }

    // Restore chain progress widget(s) from server-side task data
    if (d.chains) {
      for (const [chainId, tasks] of Object.entries(d.chains)) {
        _chainProgressRender(chainId, tasks);
      }
    }

    // Restore in-flight streaming content — priority order:
    // 1. tabState (in-memory, most recent — background tab that was generating)
    // 2. isChatRunning: session is actively running (page refresh) — show spinner,
    //    WS subscribe_session will replay the buffer and fill in content.
    // 3. partial_text from DB (persisted every 5 chunks) — shown only when interrupted
    //    (not running), so we don't conflict with live WS catch-up replay.
    const savedTxt = tabState[id]?.curTxt;
    const savedLog = tabState[id]?._toolLog;
    if (savedTxt || savedLog?.length) {
      // Tab-switch restore: recreate streaming element with accumulated text + tool log
      streaming.el = addMsg('assistant');
      streaming.txt = savedTxt || '';
      addSpinner(streaming.el);
      if (savedTxt) streaming.el.querySelector('.msg').innerHTML = renderStreaming(streaming.txt);
      // Restore live tool activity panel even if there's no text yet (tools-only phase)
      if (savedLog?.length) {
        streaming.toolLog = savedLog.slice();
        streaming.toolCounts = tabState[id]?._toolCounts || {};
        _renderToolLive(streaming.el, streaming.toolLog);
      }
    } else if (d.isChatRunning) {
      // Page refresh while Claude is running — pre-create streaming element so the
      // WS catch-up (subscribe_session) and any incoming tool/text messages have a target.
      // partial_text (if any) shown as streaming since session is still live.
      streaming.el = addMsg('assistant');
      streaming.txt = d.partial_text || '';
      addSpinner(streaming.el);
      if (streaming.txt) streaming.el.querySelector('.msg').innerHTML = renderStreaming(streaming.txt);
    } else if (d.partial_text && !d.hasRunningTask) {
      // Session was interrupted (server crash / killed) — show what was saved to DB
      const el = addMsg('assistant');
      el.querySelector('.msg').innerHTML = renderMd(d.partial_text);
      const badge = document.createElement('div');
      badge.className = 'msg-interrupted';
      badge.title = t('stream.interrupted');
      badge.textContent = '⚠ ' + t('stream.interrupted');
      el.appendChild(badge);
    }

    // Re-show agent status if this tab is still generating (was cleared by msgsEl.innerHTML = '')
    const _savedStatus = tabState[id]?.agentStatus;
    if (_savedStatus) showStatus(_savedStatus);

    // Render any pending ask_user cards that arrived while this tab was in the background
    const _askTs = tabState[id];
    if (_askTs?._pendingAskUser?.length) {
      for (const askData of _askTs._pendingAskUser) renderAskUserCard(askData);
      _askTs._pendingAskUser = [];
    }
    // Also render pending ask_tool cards
    if (_askTs?._pendingAskTool?.length) {
      for (const askData of _askTs._pendingAskTool) renderAskToolCard(askData);
      _askTs._pendingAskTool = [];
    }

    userScrolled = false;

    if (ws && ws.readyState === 1) {
      ws.send(JSON.stringify({ type: 'start_session', sessionId: id, mode: curMode, agentMode: curAgent, model: curModel}));
      ws.send(JSON.stringify({ type: 'subscribe_session', sessionId: id }));
      // If task was interrupted (server crash / tab reload), send resume_task so server
      // decides: re-attach proxy (task_resumed) or silent retry (task_interrupted).
      // Skip if a direct chat is already running (isChatRunning) — subscribe_session handles that.
      if (d.last_user_msg && !d.hasRunningTask && !d.isChatRunning) {
        ws.send(JSON.stringify({ type: 'resume_task', sessionId: id, tabId: id }));
        // Mark as generating immediately so the spinner shows before WS round-trip
        const tabObj = openTabs.find(x => x.id === id);
        if (tabObj && !tabObj.generating) { tabObj.generating = true; renderTabs(); saveUIState(); }
      }
    }
    loadHist();
    document.getElementById('input').focus();
    // Scroll to bottom after all layout and focus changes are complete
    setTimeout(() => {
      userScrolled = false;
      msgsEl.scrollTo({ top: msgsEl.scrollHeight, behavior: 'instant' });
    }, 100);
  } catch (e) { console.error('loadSess:', e); toast(t('sess.load.err'), true); }
}

async function delSess(id) {
  let msg = t('sess.delete.confirm');
  try {
    const r = await fetch(`/api/sessions/${id}/tasks-count`);
    if (r.ok) { const d = await r.json(); if (d.n > 0) msg = t('sess.delete.tasks').replace('{n}', d.n); }
  } catch {}
  if (!confirm(msg)) return;
  await fetch(`/api/sessions/${id}`, { method: 'DELETE' });
  try { const bc = new BroadcastChannel('kanban'); bc.postMessage({ type: 'session_deleted', sessionId: id }); bc.close(); } catch {}
  if (openTabs.find(t => t.id === id)) closeTab(id);
  else if (id === currentSessionId) { currentSessionId = null; msgsEl.innerHTML = ''; showW(); }
  loadHist();
}

// ─── History bulk selection ────────────────────────────────────────────────
function toggleHistSelect() {
  histSelectMode = !histSelectMode;
  histSelected.clear();
  const btn = $i('histSelBtn');
  const bar = $i('histBulkBar');
  if (btn) btn.classList.toggle('active', histSelectMode);
  if (bar) bar.classList.toggle('visible', histSelectMode);
  updateHistBulkBar();
  loadHist();
}

function toggleSessCheck(id, chk) {
  const sid = String(id);
  if (chk.checked) histSelected.add(sid); else histSelected.delete(sid);
  const item = $i('histList').querySelector(`[data-sess="${sid}"]`);
  if (item) item.classList.toggle('selected', chk.checked);
  updateHistBulkBar();
}

function updateHistBulkBar() {
  const n = histSelected.size;
  const info = $i('histBulkInfo');
  const del = $i('histBulkDel');
  const allBtn = document.querySelector('#histBulkBar .bulk-all');
  if (info) info.textContent = `${n} вибрано`;
  if (del) del.disabled = n === 0;
  if (allBtn) {
    const items = $i('histList') ? $i('histList').querySelectorAll('.hist-item[data-sess]') : [];
    const allSel = items.length > 0 && [...items].every(i => histSelected.has(String(i.dataset.sess)));
    allBtn.textContent = allSel ? 'Зняти всі' : 'Всі';
  }
}

function selectAllHist() {
  const items = $i('histList').querySelectorAll('.hist-item[data-sess]');
  const allSel = [...items].every(i => histSelected.has(String(i.dataset.sess)));
  items.forEach(item => {
    const sid = String(item.dataset.sess);
    const chk = item.querySelector('.hist-chk');
    if (allSel) { histSelected.delete(sid); item.classList.remove('selected'); if (chk) chk.checked = false; }
    else { histSelected.add(sid); item.classList.add('selected'); if (chk) chk.checked = true; }
  });
  updateHistBulkBar();
}

async function delSelectedHist() {
  const ids = [...histSelected];
  if (ids.length === 0) return;
  if (!confirm(`Видалити ${ids.length} чат${ids.length === 1 ? '' : ids.length < 5 ? 'и' : 'ів'}?`)) return;
  const btn = $i('histBulkDel');
  if (btn) { btn.disabled = true; btn.textContent = '…'; }
  try {
    await fetch('/api/sessions/bulk-delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ids }) });
    try { const bc = new BroadcastChannel('kanban'); ids.forEach(id => bc.postMessage({ type: 'session_deleted', sessionId: id })); bc.close(); } catch {}
    ids.forEach(id => {
      if (openTabs.find(t => t.id === id)) closeTab(id);
      else if (id === currentSessionId) { currentSessionId = null; msgsEl.innerHTML = ''; showW(); }
    });
    histSelected.clear();
    updateHistBulkBar();
    loadHist();
  } catch (e) {
    toast('Помилка видалення', true);
    if (btn) { btn.disabled = false; btn.textContent = 'Видалити'; }
  }
}

// ─── MCP & Skills ─────────────────────────────────────────────────────────
async function loadCfg() {
  try {
    const r = await fetch('/api/config');
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    config = await r.json();
    renderMcp();
    renderSkills();
  } catch (e) {
    console.error('loadCfg:', e);
    toast(t('toast.cfg_load_err'), true);
  }
}

function mkToggle(on) {
  return `<div class="sw" aria-hidden="true"><div class="sw-track"></div><div class="sw-thumb"></div></div>`;
}

function renderMcp() {
  const el = $i('mcpList'); el.innerHTML = '';
  const tipWarn = t('mcp.cfg.warn'), tipCfg = t('mcp.cfg.tip');
  let c = 0;
  for (const [id, m] of Object.entries(config.mcpServers || {})) {
    const on = activeMcp.has(id);
    if (on) c++;
    const missing = getMcpMissingFields(m);
    const div = document.createElement('div');
    div.className = `ci ${on ? 'on' : ''}`;
    div.title = on ? t('mcp.toggle.on') : t('mcp.toggle.off');
    div.setAttribute('role', 'switch');
    div.setAttribute('tabindex', '0');
    div.setAttribute('aria-checked', String(on));
    div.setAttribute('aria-label', m.label || id);
    div.onclick = () => tMcp(id);
    div.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); tMcp(id); } };
    div.innerHTML = `
      ${mkToggle(on)}
      <div class="inf">
        <div class="nm" data-tip="${escH(m.label || id)}">${escH(m.label || id)}</div>
        <div class="ds" data-tip="${escH(m.description || '')}">${escH(m.description || '')}</div>
        <div class="st">${on ? t('mcp.active') : t('mcp.inactive')}</div>
      </div>
      ${missing.length ? `<div class="warn-dot" title="${escH(tipWarn)}"></div>` : ''}
      <button class="cfg" onclick="event.stopPropagation();showMcpSettings('${id}')" title="${escH(tipCfg)}">⚙</button>
      ${m.custom ? `<button class="rm" onclick="event.stopPropagation();rMcp('${id}')" title="${t('mcp.del.title')}">✕</button>` : ''}`;
    el.appendChild(div);
  }
  $i('mcpCount').textContent = c || '';
}

// Returns unconfigured credential fields (placeholder values)
function getMcpMissingFields(m) {
  const PH=/YOUR_[A-Z_]+/;
  const SKIP_ENV=new Set(['ENABLE_TOOL_SEARCH','ENABLE_EXPERIMENTAL_MCP_CLI']);
  const fields=[];
  for(const[k,v]of Object.entries(m.env||{})){if(SKIP_ENV.has(k))continue;if(PH.test(v)||(v===''&&/KEY|TOKEN|SECRET|API/i.test(k)))fields.push({source:'env',key:k,val:v});}
  for(const[k,v]of Object.entries(m.headers||{})){if(PH.test(v))fields.push({source:'headers',key:k,val:v});}
  if(m.url&&PH.test(m.url))fields.push({source:'url',key:'url',val:m.url});
  if(m.args)m.args.forEach((a,i)=>{if(PH.test(a))fields.push({source:'args',key:i,val:a});});
  return fields;
}

function tMcp(id) {
  if (!activeMcp.has(id)) {
    const m=config.mcpServers[id];
    if (m&&getMcpMissingFields(m).length) { showMcpSettings(id,true); return; }
  }
  if (activeMcp.has(id)) activeMcp.delete(id); else activeMcp.add(id);
  renderMcp(); saveUIState();
  // Save MCP state to current session immediately (not just on message send)
  if (currentSessionId) {
    fetch(`/api/sessions/${currentSessionId}`, {
      method: 'PUT',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({active_mcp: [...activeMcp]})
    }).catch(e => console.warn('Failed to persist activeMcp to session:', e));
  }
}
async function rMcp(id) {
  const label = config.mcpServers[id]?.label || id;
  if (!confirm(`${t('mcp.del.confirm')} "${label}"?`)) return;
  activeMcp.delete(id);
  await fetch(`/api/mcp/${id}`, { method: 'DELETE' });
  delete config.mcpServers[id];
  renderMcp();
}
function showMcpForm() { $i('mcpForm').style.display = 'flex'; }
function hideMcpForm() { $i('mcpForm').style.display = 'none'; }
function updateMcpFormType() {
  const type=$i('mcpType').value, isUrl=type==='sse'||type==='http';
  $i('mcpStdioFields').style.display=isUrl?'none':'flex';
  $i('mcpUrlFields').style.display=isUrl?'flex':'none';
  $i('mcpHeadersArea').style.display=type==='http'?'block':'none';
}

async function addMcp() {
  const id=$i('mcpId').value.trim(), label=$i('mcpLabel').value.trim();
  const type=$i('mcpType').value;
  if (!id) { toast(t('mcp.add.id_req'),true); return; }
  let body={id, label:label||id, type};
  if (type==='sse'||type==='http') {
    const url=$i('mcpUrl').value.trim();
    if (!url) { toast(t('mcp.add.url_req'),true); return; }
    let headers={}; try{headers=JSON.parse($i('mcpHeadersArea').value||'{}')}catch{}
    let env={}; try{env=JSON.parse($i('mcpEnv').value||'{}')}catch{}
    body={...body,url,headers,env};
  } else {
    const command=$i('mcpCmd').value.trim();
    if (!command) { toast(t('mcp.add.cmd_req'),true); return; }
    const args=$i('mcpArgs').value.split(',').map(s=>s.trim()).filter(Boolean);
    let env={}; try{env=JSON.parse($i('mcpEnv').value||'{}')}catch{}
    body={...body,command,args,env};
  }
  await fetch('/api/mcp/add',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
  config.mcpServers[id]={...body,custom:true};
  activeMcp.add(id); renderMcp(); hideMcpForm();
  ['mcpId','mcpLabel','mcpCmd','mcpArgs','mcpEnv','mcpUrl','mcpHeadersArea'].forEach(x=>{const el=$i(x);if(el)el.value='';});
  $i('mcpType').value='stdio'; updateMcpFormType();
  toast(t('mcp.add.ok'));
}

// ─── MCP Settings Modal ─────────────────────────────────────────────────────
let _mcpCfgId=null, _mcpCfgEnable=false;
const SKIP_ENV_DISPLAY=new Set(); // no env vars are hidden from the settings form

function _mcpEnvRow(container, key='', val='') {
  const row = document.createElement('div');
  row.className = 'env-kv-row';
  const isSecret = /KEY|TOKEN|SECRET|PASS/i.test(key);
  row.innerHTML = `
    <input type="text" class="mcp-cfg-input env-kv-key" value="${escH(key)}" placeholder="KEY_NAME">
    <input type="${isSecret?'password':'text'}" class="mcp-cfg-input env-kv-val" value="${escH(val)}" placeholder="value">
    <button class="env-kv-del" title="Remove" onclick="this.closest('.env-kv-row').remove()">✕</button>`;
  container.appendChild(row);
  return row;
}

function showMcpSettings(id, enableAfter=false) {
  _mcpCfgId=id; _mcpCfgEnable=enableAfter;
  const m=config.mcpServers[id]; if(!m) return;
  $i('mcpSettingsTitle').textContent=`⚙ ${m.label||id}`;
  const body=$i('mcpSettingsBody'); body.innerHTML='';

  if (enableAfter) {
    const note=document.createElement('div');
    note.style.cssText='font-size:13px;color:var(--orange);padding:4px 0 10px;font-weight:600';
    note.textContent=t('mcp.cfg.api_warn');
    body.appendChild(note);
  }

  const rows=[];
  const PH=/YOUR_[A-Z_]+/;

  // URL for http/sse type
  if (m.type==='sse'||m.type==='http') rows.push({source:'url',key:'url',val:m.url||'',label:'URL',secret:false});
  // Headers
  for(const[k,v]of Object.entries(m.headers||{})) rows.push({source:'headers',key:k,val:v,label:`Header: ${k}`,secret:true});
  // Env vars that need attention (placeholder or empty secret key) — shown as individual labeled fields
  for(const[k,v]of Object.entries(m.env||{})){
    if(PH.test(v)||(v===''&&/KEY|TOKEN|SECRET|API/i.test(k))){
      rows.push({source:'env',key:k,val:v,label:k,secret:/KEY|TOKEN|SECRET|PASS/i.test(k)});
    }
  }
  // Args: extract URL query params containing placeholders
  if (m.args) {
    m.args.forEach((a,i)=>{
      if(!PH.test(a)) return;
      const paramRe=/[?&](\w+)=(YOUR_[A-Z_]+)/g;
      let pm;
      while((pm=paramRe.exec(a))!==null){
        const paramName=pm[1], placeholder=pm[2];
        const prefixEnd=a.indexOf(placeholder);
        const prefix=a.slice(0,prefixEnd);
        const suffix=a.slice(prefixEnd+placeholder.length);
        rows.push({source:'arg_param',key:`arg_${i}_${paramName}`,val:placeholder,label:paramName,secret:true,argIdx:i,placeholder,prefix,suffix});
      }
      if(!a.match(/[?&]\w+=YOUR_[A-Z_]+/)){
        rows.push({source:'arg',key:`arg_${i}`,val:a,label:`Arg[${i}]`,secret:false,argIdx:i});
      }
    });
  }

  // Render individual labeled fields (URL, headers, placeholder env, args)
  if (rows.length > 0) {
    rows.forEach(f=>{
      const need=PH.test(f.val)||(f.val===''&&/KEY|TOKEN|SECRET|API/i.test(f.key));
      const row=document.createElement('div');
      row.style.cssText='display:flex;flex-direction:column;gap:5px';
      const extraAttrs=f.source==='arg_param'
        ? ` data-arg-idx="${f.argIdx}" data-placeholder="${escH(f.placeholder)}" data-prefix="${escH(f.prefix)}" data-suffix="${escH(f.suffix)}"`
        : f.source==='arg' ? ` data-arg-idx="${f.argIdx}"` : '';
      row.innerHTML=`<label class="mcp-cfg-label">${escH(f.label)}${need?' <span style="color:var(--orange)">⚠</span>':''}</label>
        <input type="${f.secret?'password':'text'}" data-src="${f.source}" data-key="${escH(String(f.key))}" value="${escH(f.val)}"${extraAttrs}
          class="mcp-cfg-input" style="${need?'border-color:var(--orange)':''}">`;
      body.appendChild(row);
    });
  }

  // Env key-value editor section
  const envSection = document.createElement('div');
  if (rows.length > 0) envSection.style.cssText = 'border-top:1px solid var(--border);padding-top:14px;margin-top:4px';
  const envHeader = document.createElement('div');
  envHeader.className = 'mcp-cfg-label';
  envHeader.innerHTML = `<span>Environment</span><button class="env-add-btn" style="width:auto;padding:3px 10px;margin:0" onclick="this.closest('#mcpSettingsBody').querySelector('#mcpCfgEnvRows')&&_mcpEnvRow(this.closest('#mcpSettingsBody').querySelector('#mcpCfgEnvRows'))">＋ Add</button>`;
  envSection.appendChild(envHeader);

  const envContainer = document.createElement('div');
  envContainer.id = 'mcpCfgEnvRows';
  envContainer.style.cssText = 'display:flex;flex-direction:column;gap:8px';
  envSection.appendChild(envContainer);

  // Populate with existing env vars (exclude ones already shown as individual placeholder fields)
  const shownAsField = new Set(rows.filter(r=>r.source==='env').map(r=>r.key));
  for (const [k, v] of Object.entries(m.env || {})) {
    if (shownAsField.has(k)) continue;
    _mcpEnvRow(envContainer, k, v);
  }

  // "Add" button at bottom (for when list is empty)
  if (Object.keys(m.env||{}).length === 0 || (Object.keys(m.env||{}).length - shownAsField.size) === 0) {
    const emptyHint = document.createElement('div');
    emptyHint.style.cssText = 'font-size:12px;color:var(--muted);padding:4px 0;opacity:.7';
    emptyHint.textContent = 'No environment variables';
    emptyHint.id = 'mcpEnvEmpty';
    envContainer.appendChild(emptyHint);
    // Remove hint on first add
    const origAdd = _mcpEnvRow;
    const container = envContainer;
    const observer = new MutationObserver(() => {
      const hint = $i('mcpEnvEmpty');
      if (hint && container.querySelectorAll('.env-kv-row').length > 0) { hint.remove(); observer.disconnect(); }
    });
    observer.observe(container, { childList: true });
  }

  body.appendChild(envSection);
  $i('mcpSettingsModal').classList.remove('hidden');
}
function closeMcpSettings() {
  $i('mcpSettingsModal').classList.add('hidden');
  _mcpCfgId=null; _mcpCfgEnable=false;
}
async function saveMcpSettings() {
  const id=_mcpCfgId; if(!id) return;
  const inputs=$i('mcpSettingsBody').querySelectorAll('input[data-src]');
  const envU={}, headU={};
  let urlU=undefined;
  // Collect arg_param changes (need to rebuild args array)
  const argChanges=[]; // {argIdx, placeholder, prefix, suffix, newVal}
  const argDirectChanges=[]; // {argIdx, newVal}
  for(const inp of inputs){
    const src=inp.dataset.src, key=inp.dataset.key, val=inp.value.trim();
    if(src==='env') envU[key]=val;
    else if(src==='headers') headU[key]=val;
    else if(src==='url') urlU=val;
    else if(src==='arg_param') argChanges.push({argIdx:parseInt(inp.dataset.argIdx),placeholder:inp.dataset.placeholder,prefix:inp.dataset.prefix,suffix:inp.dataset.suffix,newVal:val});
    else if(src==='arg') argDirectChanges.push({argIdx:parseInt(inp.dataset.argIdx),newVal:val});
  }
  // Read env key-value rows
  const kvRows = $i('mcpCfgEnvRows')?.querySelectorAll('.env-kv-row') || [];
  for (const row of kvRows) {
    const k = row.querySelector('.env-kv-key')?.value?.trim();
    const v = row.querySelector('.env-kv-val')?.value ?? '';
    if (k) envU[k] = v;
  }
  const payload={};
  payload.env=envU; // always send env (even empty {}) so server can do full replacement
  if(Object.keys(headU).length) payload.headers=headU;
  if(urlU!==undefined) payload.url=urlU;
  // Rebuild args if needed
  const m=config.mcpServers[id];
  if((argChanges.length||argDirectChanges.length)&&m&&m.args){
    const newArgs=[...m.args];
    for(const ch of argChanges) newArgs[ch.argIdx]=ch.prefix+ch.newVal+ch.suffix;
    for(const ch of argDirectChanges) newArgs[ch.argIdx]=ch.newVal;
    payload.args=newArgs;
  }
  try{
    const r=await fetch(`/api/mcp/${id}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    if(!r.ok)throw new Error(`HTTP ${r.status}`);
    if(m){
      if(payload.env !== undefined) m.env=payload.env;
      if(payload.headers) m.headers={...(m.headers||{}),...payload.headers};
      if(payload.url!==undefined) m.url=payload.url;
      if(payload.args) m.args=payload.args;
    }
    if(_mcpCfgEnable){activeMcp.add(id);renderMcp();saveUIState();}
    closeMcpSettings(); toast(t('mcp.cfg.saved'));
  }catch(e){toast(t('mcp.cfg.save_err'),true);}
}

// ─── MCP Import / Export ─────────────────────────────────────────────────
let _mcpImportData = null;

function openMcpImport() {
  _mcpImportData = null;
  $i('mcpImportJson').value = '';
  $i('mcpImportPreview').style.display = 'none';
  $i('mcpImportError').style.display = 'none';
  $i('mcpImportBtn').disabled = true;
  $i('mcpImportReplace').checked = false;
  $i('mcpImportModal').classList.remove('hidden');
}
function closeMcpImport() {
  $i('mcpImportModal').classList.add('hidden');
  _mcpImportData = null;
}
function mcpImportPreviewClear() {
  _mcpImportData = null;
  $i('mcpImportPreview').style.display = 'none';
  $i('mcpImportError').style.display = 'none';
  $i('mcpImportBtn').disabled = true;
}
function handleMcpImportFile(input) {
  const file = input.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = e => { $i('mcpImportJson').value = e.target.result; previewMcpImport(); };
  reader.readAsText(file);
  input.value = '';
}
function handleMcpImportDrop(e) {
  const file = e.dataTransfer.files[0];
  if (!file || !file.name.toLowerCase().endsWith('.json')) { toast(t('toast.json_req'), true); return; }
  const reader = new FileReader();
  reader.onload = ev => { $i('mcpImportJson').value = ev.target.result; previewMcpImport(); };
  reader.readAsText(file);
}
function parseMcpImportJson(raw) {
  const parsed = JSON.parse(raw);
  // Format 1: { mcpServers: { id: {...} } } — Claude Desktop & our export format
  if (parsed.mcpServers && typeof parsed.mcpServers === 'object') return parsed.mcpServers;
  // Format 2: flat object where values look like server entries
  const vals = Object.values(parsed);
  if (vals.length && vals.every(v => v && typeof v === 'object' && (v.command !== undefined || v.url !== undefined || v.type !== undefined))) return parsed;
  // Format 3: nested — some apps wrap config in another object
  for (const v of vals) {
    if (v && typeof v === 'object' && v.mcpServers) return v.mcpServers;
  }
  throw new Error(t('mcp.parse.no_servers'));
}
function previewMcpImport() {
  const raw = $i('mcpImportJson').value.trim();
  const errEl = $i('mcpImportError'), prevEl = $i('mcpImportPreview');
  errEl.style.display = 'none';
  if (!raw) { toast(t('toast.json_enter'), true); return; }
  try {
    const servers = parseMcpImportJson(raw);
    const ids = Object.keys(servers);
    if (!ids.length) throw new Error(t('mcp.parse.empty'));
    _mcpImportData = servers;
    $i('mcpImportCount').textContent = ids.length;
    const listEl = $i('mcpImportList'); listEl.innerHTML = '';
    for (const [id, m] of Object.entries(servers)) {
      const div = document.createElement('div');
      div.style.cssText = 'display:flex;align-items:center;gap:8px;padding:6px 9px;background:var(--s2);border-radius:6px;font-size:12px';
      const isHttp = m.url || m.type === 'http' || m.type === 'sse';
      const icon = isHttp
        ? `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"/></svg>`
        : `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>`;
      const desc = m.command ? `${m.command}${m.args?.length ? ' ' + m.args.join(' ') : ''}` : (m.url || '');
      div.innerHTML = `<span style="display:flex;align-items:center;color:var(--muted)">${icon}</span><div style="flex:1;min-width:0"><div style="font-weight:600">${escH(m.label||id)}</div><div style="color:var(--muted);font-size:11px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${escH(desc)}">${escH(desc||'—')}</div></div>${config.mcpServers[id]?`<span style="font-size:10px;color:var(--orange)" title="${escH(t('mcp.replace.title'))}">↺</span>`:''}` ;
      listEl.appendChild(div);
    }
    prevEl.style.display = 'flex';
    $i('mcpImportBtn').disabled = false;
  } catch(e) {
    errEl.textContent = e.message; errEl.style.display = 'block';
    prevEl.style.display = 'none'; _mcpImportData = null; $i('mcpImportBtn').disabled = true;
  }
}
async function doMcpImport() {
  if (!_mcpImportData) return;
  const btn = $i('mcpImportBtn');
  btn.disabled = true;
  const replace = $i('mcpImportReplace').checked;
  try {
    const r = await fetch('/api/mcp/import', {
      method: 'POST', headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ servers: _mcpImportData, replace })
    });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const d = await r.json();
    if (!d.ok) throw new Error(d.error || 'Server error');
    // Reload full config from server to stay in sync with what was actually saved
    await loadCfg();
    closeMcpImport();
    toast(t('toast.mcp_imported').replace('{n}', d.imported));
  } catch(e) {
    btn.disabled = false;
    toast(t('toast.mcp_import_err') + e.message, true);
  }
}
async function exportMcp() {
  try {
    const r = await fetch('/api/mcp/export');
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const data = await r.json();
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob); a.download = 'mcp-config.json'; a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 1000);
  } catch(e) { toast(t('toast.mcp_export_err'), true); }
}

const SKILL_CATS = {
  engineering: { en: '⚙️ Engineering', uk: '⚙️ Розробка', ru: '⚙️ Разработка' },
  ai:          { en: '🧠 AI & Prompts', uk: '🧠 AI та промпти', ru: '🧠 AI и промпты' },
  quality:     { en: '💎 Code Quality', uk: '💎 Якість коду', ru: '💎 Качество кода' },
  security:    { en: '🔒 Security', uk: '🔒 Безпека', ru: '🔒 Безопасность' },
  design:      { en: '🎨 Design', uk: '🎨 Дизайн', ru: '🎨 Дизайн' },
  product:     { en: '📋 Product', uk: '📋 Продукт', ru: '📋 Продукт' },
  finance:     { en: '💼 Finance', uk: '💼 Фінанси', ru: '💼 Финансы' },
  research:    { en: '🔬 Research', uk: '🔬 Дослідження', ru: '🔬 Исследования' },
  system:      { en: '⚙️ System', uk: '⚙️ Система', ru: '⚙️ Система' },
};

const SKILL_TRIGGERS = {
  'backend': [
    'backend', 'api endpoint', 'server', 'node.js', 'express', 'fastify', 'endpoint', 'rest api', 'crud', 'migration', 'transaction', 'queue', 'http server',
    'бекенд', 'сервер', 'ендпоінт', 'апі', 'міграці', 'транзакці', 'черга',
    'бэкенд', 'эндпоинт', 'миграци', 'транзакци', 'очередь'
  ],
  'api-designer': [
    'graphql', 'grpc', 'swagger', 'openapi', 'api versioning', 'api design', 'api contract', 'rest design', 'api spec',
    'графкл', 'апі дизайн', 'версіонування апі', 'контракт апі', 'специфікаці',
    'графкл', 'дизайн апи', 'версиони', 'контракт', 'спецификаци'
  ],
  'frontend': [
    'react', 'vue', 'angular', 'component', 'jsx', 'tsx', 'css', 'html', 'browser', 'dom', 'state management', 'hook', 'redux', 'tailwind', 'responsive',
    'фронтенд', 'компонент', 'браузер', 'стан', 'хук', 'адаптив',
    'фронтенд', 'состояние', 'адаптив'
  ],
  'fullstack': [
    'full stack', 'fullstack', 'entire feature', 'end to end', 'build a page', 'build a form', 'build an app', 'build a screen', 'full feature',
    'фулстек', 'повний стек', 'всю функці', 'від початку до кінця', 'зроби сторінк', 'зроби форм', 'ціла функці',
    'фулстек', 'полный стек', 'всю функци', 'от начала до конца', 'сделай страниц', 'целая функци'
  ],
  'devops': [
    'docker', 'kubernetes', 'k8s', 'deploy', 'aws', 'gcp', 'azure', 'terraform', 'ci/cd', 'pipeline', 'container', 'nginx', 'helm', 'infrastructure', 'monitoring',
    'депло', 'контейнер', 'інфраструктур', 'моніторинг', 'пайплайн',
    'деплой', 'инфраструктур', 'мониторинг', 'пайплайн'
  ],
  'postgres-wizard': [
    'postgres', 'postgresql', 'index', 'query optimization', 'explain analyze', 'partitioning', 'vacuum', 'slow query',
    'постгрес', 'індекс', 'оптимізаці запит', 'повільн запит', 'партиціонуванн', 'вакуум',
    'постгрес', 'индекс', 'оптимизац запрос', 'медлен запрос', 'партици'
  ],
  'data-engineer': [
    'data pipeline', 'etl', 'spark', 'airflow', 'dbt', 'data warehouse', 'data lake', 'kafka', 'transform data', 'data quality', 'cdc', 'batch processing',
    'пайплайн дан', 'сховищ дан', 'озеро дан', 'якість дан', 'трансформ',
    'пайплайн данн', 'хранилище данн', 'озеро данн', 'качество данн', 'трансформ'
  ],
  'llm-architect': [
    'llm', 'chatgpt', 'claude api', 'openai', 'anthropic', 'agent', 'langchain', 'chatbot', 'ai product', 'ai application', 'ai system',
    'ллам', 'чажпт', 'агент', 'чатбот', 'штучний інтелект', 'продукт штучного інтелекту', 'застосунок зі штучним інтелектом',
    'ллам', 'агент', 'чатбот', 'искусствен интелект', 'продукт искусс'
  ],
  'prompt-engineer': [
    'prompt', 'system prompt', 'few-shot', 'chain of thought', 'instruction tuning', 'jailbreak', 'context window', 'token limit',
    'промпт', 'системний промпт', 'ланцюжок думок', 'інструкці', 'контекстне вікно', 'ліміт токен',
    'промпт', 'системный промпт', 'цепочк мысл', 'инструкци', 'контекстное окно', 'лимит токен'
  ],
  'rag-engineer': [
    'rag', 'vector', 'embedding', 'retrieval', 'semantic search', 'pinecone', 'chroma', 'weaviate', 'chunk', 'knowledge base', 'vector db',
    'раг', 'вектор', 'ембединг', 'ретривал', 'семантичний пошук', 'база знань', 'база знан',
    'раг', 'вектор', 'эмбединг', 'ретривал', 'семантический поиск', 'база знаний'
  ],
  'security': [
    'security', 'vulnerability', 'xss', 'sql injection', 'csrf', 'owasp', 'exploit', 'pentest', 'attack', 'breach', 'sanitize', 'threat model',
    'безпек', 'вразливіст', 'ін\'єкці', 'експлоіт', 'пентест', 'атака', 'загроз', 'санітайз', 'вразлив',
    'безопасност', 'уязвимост', 'инъекци', 'эксплоит', 'пентест', 'атака', 'угроз', 'уязвим'
  ],
  'auth-specialist': [
    'auth', 'login', 'oauth', 'jwt', 'token', 'session', 'password', 'sso', 'saml', 'mfa', 'permission', 'rbac', 'roles',
    'авторизаці', 'логін', 'аутентифікаці', 'токен', 'сесі', 'пароль', 'дозвіл', 'рол', 'мфа', 'двохфакторн',
    'авторизац', 'логин', 'аутентификац', 'токен', 'сесси', 'пароль', 'разрешен', 'рол', 'двухфакторн'
  ],
  'debugging-master': [
    'debug', 'bug', 'error', 'fix', 'issue', 'problem', 'crash', 'exception', 'stacktrace', 'not working', 'broken', 'fails', 'investigate error',
    'дебаг', 'баг', 'помилк', 'проблем', 'краш', 'екзепшн', 'стектрейс', 'не працює', 'полам', 'злама', 'виправ', 'дослідж помилк',
    'дебаг', 'баг', 'ошибк', 'проблем', 'краш', 'эксепшн', 'стектрейс', 'не работает', 'слома', 'исправ', 'исследу ошибк'
  ],
  'code-quality': [
    'refactor', 'clean code', 'solid', 'technical debt', 'maintainable', 'readable', 'code smell', 'coupling', 'cohesion',
    'рефакторинг', 'чистий код', 'технічний борг', 'читабельн', 'зв\'язніст', 'когезі', 'код смелл', 'якість код',
    'рефакторинг', 'чистый код', 'технический долг', 'читаемост', 'связност', 'когези', 'качество код'
  ],
  'code-review': [
    'review', 'pull request', ' pr ', 'code review', 'feedback on code', 'review this',
    'рев\'ю', 'ревю', 'пул реквест', 'перевір код', 'перевірити код', 'подивись код', 'подивитись код', 'огляд код',
    'ревью', 'пул реквест', 'проверь код', 'проверить код', 'посмотри код', 'обзор код'
  ],
  'system-designer': [
    'architecture', 'system design', 'scalable', 'distributed', 'microservices', 'high availability', 'design pattern', 'cap theorem', 'event driven',
    'архітектур', 'дизайн систем', 'масштабов', 'розподілен', 'мікросервіс', 'відмовостійкіст', 'паттерн', 'евент дривен', 'поді',
    'архитектур', 'дизайн систем', 'масштабиру', 'распредел', 'микросервис', 'отказоустойчив', 'паттерн', 'событийно-ориентиров'
  ],
  'ui-design': [
    'ui design', 'visual design', 'color palette', 'typography', 'layout', 'figma', 'design system', 'component library', 'style guide', 'pixel',
    'юі дизайн', 'візуальн дизай', 'кольоров палітр', 'типографі', 'лейаут', 'фігма', 'дизайн систем', 'компонент бібліотек', 'стайл гайд', 'піксел',
    'юи дизайн', 'визуальн дизай', 'цветов палитр', 'типографи', 'дизайн систем', 'библиотек компонент', 'стайл гайд', 'пиксел'
  ],
  'ux-design': [
    'ux', 'user experience', 'usability', 'wireframe', 'prototype', 'user flow', 'journey map', 'onboarding', 'user research', 'usability test',
    'юкз', 'користувацьк досвід', 'юзабіліт', 'вайрфрейм', 'прототип', 'юзер флоу', 'джорні меп', 'онбординг', 'дослідж користувач', 'юзабіліт тест',
    'юкс', 'пользовательск опыт', 'юзабилит', 'вайрфрейм', 'прототип', 'юзер флоу', 'джорни меп', 'онбординг', 'исследован пользоват'
  ],
  'product-management': [
    'product', 'roadmap', 'prioritize', 'user story', 'requirements', 'sprint', 'backlog', 'product manager', 'feature request', 'rice',
    'продукт', 'роадмеп', 'пріоритиз', 'юзер сторі', 'вимог', 'спринт', 'беклог', 'продакт менеджер', 'пр', 'запит на функці',
    'роадмап', 'приоритиз', 'юзер стори', 'требован', 'продакт менеджер', 'запрос на функци'
  ],
  'docs-engineer': [
    'documentation', 'readme', 'tutorial', 'guide', 'api docs', 'onboarding doc', 'wiki', 'write docs',
    'документаці', 'рідмі', 'туторіал', 'гайд', 'посібник', 'інструкці', 'вікі', 'напиш докум', 'написат докум',
    'документаци', 'ридми', 'туториал', 'гайд', 'пособие', 'инструкци', 'вики', 'напиш документ'
  ],
  'technical-writer': [
    'technical writing', 'blog post', 'article', 'write about', 'explain how', 'technical article',
    'технічн пис', 'блог пост', 'статт', 'напиш про', 'поясн як', 'технічн статт',
    'техническ пис', 'блог пост', 'стать', 'напиш про', 'объясн как', 'техническ стать'
  ],
  'investment-banking': [
    'dcf', 'lbo', 'valuation', 'financial model', 'investment', 'equity research', 'merger', 'acquisition', 'm&a', 'ebitda', 'wacc', 'comps', 'ipo', 'private equity', 'ic memo', 'investment committee',
    'дисконтованих грошових поток', 'фінансов модел', 'інвестиці', 'злитт', 'поглинанн', 'ебітда', 'вацц', 'приватн еквіт', 'оцінк', 'комп',
    'дисконтированн денежн поток', 'финансов модел', 'инвестици', 'слиян', 'поглощен', 'ебитда', 'вацц', 'частн эквити', 'оценк'
  ],
  'researcher': [
    'research', 'investigate', 'find information', 'competitive analysis', 'market research', 'analyze market', 'due diligence', 'landscape analysis', 'find and analyze',
    'дослід', 'розслід', 'знайд інформаці', 'конкурентн аналіз', 'ринк', 'аналіз ринк', 'дью ділайдженс', 'ландшафтн аналіз', 'пошук інформаці', 'пошукай',
    'исслед', 'расслед', 'найди информац', 'конкурентн анализ', 'рын', 'анализ рынка', 'дью дилайдженс', 'ландшафтн анализ', 'поиск информац'
  ],
  'docker': [
    'dockerfile', 'docker compose', 'docker-compose', 'multi-stage build', 'docker build', 'docker run', 'docker image', 'docker volume', 'docker network', 'docker hub', 'docker registry', 'containerize', '.dockerignore', 'image size', 'image optimization', 'base image', 'container image', 'docker layer', 'docker tag', 'docker push', 'docker pull',
    'докерфайл', 'докер компоуз', 'мультистейдж', 'образ докер', 'контейнериз', 'оптимізаці образ', 'реєстр докер', 'докер образ', 'докер том', 'докер мережа',
    'докерфайл', 'докер компоуз', 'мультистейдж', 'образ докер', 'контейнеризац', 'оптимизац образ', 'реестр докер', 'докер образ', 'докер том', 'докер сеть'
  ],
  'sysadmin': [
    'systemd', 'systemctl', 'journalctl', 'server admin', 'linux server', 'manage server', 'remote server', 'administer server', 'ssh key', 'firewall', 'ufw', 'iptables', 'certbot', 'letsencrypt', 'cron job', 'disk usage', 'disk space', 'service management', 'server hardening', 'fail2ban', 'nginx config', 'reverse proxy', 'service restart', 'server setup', 'vps', 'droplet', 'bare metal', 'server monitoring', 'log rotation', 'logrotate', 'server security',
    'адмін сервер', 'серверн адмін', 'linux сервер', 'керуванн сервер', 'віддален сервер', 'зворотн проксі', 'брандмауер', 'файрвол', 'систем адмін', 'налаштуванн сервер', 'місц на диск', 'розклад задач', 'управлінн служб', 'захист сервер', 'сертифікат',
    'администр сервер', 'серверн администр', 'linux сервер', 'удален сервер', 'обратн прокси', 'брандмауэр', 'файрвол', 'систем администр', 'настройк сервер', 'место на диск', 'расписан задач', 'управлен служб', 'защит сервер', 'сертификат'
  ],
  'kubernetes': [
    'kubectl', 'kubernetes', 'k8s pod', 'kubernetes deployment', 'helm chart', 'kustomize', 'kubernetes cluster', 'kubeconfig', 'ingress controller', 'horizontal pod autoscal', 'persistent volume', 'kubernetes manifest', 'kubernetes secret', 'kubernetes service', 'kubernetes namespace', 'crashloopbackoff', 'imagepullbackoff', 'pod scheduling', 'node affinity', 'kubernetes operator', 'argocd', 'flux cd',
    'кубернетес', 'кластер кубернетес', 'хелм чарт', 'маніфест k8s', 'неймспейс k8s', 'деплоймент k8s', 'кубернет поди', 'кубернет сервіс',
    'кубернетес', 'кластер кубернетес', 'хелм чарт', 'манифест k8s', 'неймспейс k8s', 'деплоймент k8s', 'кубернет поды', 'кубернет сервис'
  ],
};

function autoSelectSkills(text) {
  const t = text.toLowerCase();
  const scores = {};
  for (const [id] of Object.entries(config.skills || {})) {
    if (id === 'auto-mode') continue; // always included separately
    let score = 0;
    const triggers = SKILL_TRIGGERS[id] || [];
    for (const kw of triggers) { if (t.includes(kw)) score += 2; }
    const descWords = (config.skills[id].description || '').toLowerCase().split(/\W+/).filter(w => w.length > 5);
    for (const w of descWords) { if (t.includes(w)) score += 1; }
    if (score > 0) scores[id] = score;
  }
  const selected = Object.entries(scores).sort((a, b) => b[1] - a[1]).slice(0, 4).map(([id]) => id);
  // Always prepend auto-mode meta-skill so Claude knows to embrace specialist roles
  if (selected.length > 0 && config.skills['auto-mode']) {
    return ['auto-mode', ...selected];
  }
  return selected;
}

function toggleAutoSkills() {
  autoSkillsMode = !autoSkillsMode;
  const btn = $i('autoSkillsBtn');
  if (btn) {
    btn.classList.toggle('active', autoSkillsMode);
    btn.title = autoSkillsMode ? t('auto.title.on') : t('auto.title.off');
  }
  const hint = $i('autoSkillsHint');
  if (hint) hint.style.display = autoSkillsMode ? 'block' : 'none';
  saveUIState(); updateSessBarSkills();
}

function renderSkills() {
  const el = $i('skillsList'); el.innerHTML = '';
  let c = 0;
  const lang = localStorage.getItem('lang') || 'uk';

  // Group skills by category
  const grouped = {};
  const uncategorized = [];
  for (const [id, s] of Object.entries(config.skills || {})) {
    if (id === 'auto-mode') continue; // controlled by the ⚡ Auto button, not shown in list
    const cat = s.category || '__custom__';
    if (!grouped[cat]) grouped[cat] = [];
    grouped[cat].push([id, s]);
  }

  // Render in defined category order, then custom
  const catOrder = Object.keys(SKILL_CATS);
  const toRender = [
    ...catOrder.filter(k => grouped[k]),
    ...(grouped['__custom__'] ? ['__custom__'] : [])
  ];

  for (const catId of toRender) {
    const items = grouped[catId];
    if (!items?.length) continue;

    // Category header
    const catMeta = SKILL_CATS[catId];
    const catLabel = catMeta ? (catMeta[lang] || catMeta.en) : '🔧 Custom';
    const catDiv = document.createElement('div');
    catDiv.className = 'sk-cat';
    catDiv.textContent = catLabel;
    el.appendChild(catDiv);

    for (const [id, s] of items) {
      const on = activeSkills.has(id);
      if (on) c++;
      const div = document.createElement('div');
      div.className = `ci ${on ? 'on' : ''}`;
      div.title = on ? t('skill.toggle.on') : t('skill.toggle.off');
      div.setAttribute('role', 'switch');
      div.setAttribute('tabindex', '0');
      div.setAttribute('aria-checked', String(on));
      div.setAttribute('aria-label', s.label || id);
      div.onclick = () => tSkill(id);
      div.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); tSkill(id); } };
      div.innerHTML = `
        ${mkToggle(on)}
        <div class="inf">
          <div class="nm" data-tip="${escH(s.label || id)}">${escH(s.label || id)}</div>
          <div class="ds" data-tip="${escH(s.description || '')}">${escH(s.description || '')}</div>
          <div class="st">${on ? t('skill.active') : t('skill.inactive')}</div>
        </div>
        ${s.custom ? `<button class="rm" onclick="event.stopPropagation();rSkill('${id}')" title="${t('skill.del.title')}">✕</button>` : ''}`;
      el.appendChild(div);
    }
  }
  $i('skillsCount').textContent = c || '';
}

function tSkill(id) {
  const wasActive = activeSkills.has(id);
  if (wasActive) activeSkills.delete(id); else activeSkills.add(id);
  // Manually activating a skill turns off Auto mode
  if (!wasActive && autoSkillsMode) {
    autoSkillsMode = false;
    const btn = $i('autoSkillsBtn');
    if (btn) { btn.classList.remove('active'); btn.title = t('auto.title.off'); }
    const hint = $i('autoSkillsHint');
    if (hint) hint.style.display = 'none';
  }
  renderSkills(); saveUIState(); updateSessBarSkills();
  // Save skills state to current session immediately (mirrors tMcp behaviour)
  if (currentSessionId) {
    fetch(`/api/sessions/${currentSessionId}`, {
      method: 'PUT',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({active_skills: [...activeSkills]})
    }).catch(e => console.warn('Failed to persist activeSkills to session:', e));
  }
}
async function rSkill(id) {
  activeSkills.delete(id);
  await fetch(`/api/skills/${id}`, { method: 'DELETE' });
  delete config.skills[id];
  renderSkills();
}
async function uploadSkill(input) {
  const file = input.files[0];
  if (!file) return;
  const name = prompt(t('skill.name_prompt'), file.name.replace(/\.md$/, ''));
  if (!name) return;
  const fd = new FormData();
  fd.append('file', file); fd.append('name', name);
  fd.append('label', name); fd.append('description', 'Custom skill');
  const r = await fetch('/api/skills/upload', { method: 'POST', body: fd });
  const d = await r.json();
  if (d.ok) { toast(t('toast.skill_uploaded')); input.value = ''; await loadCfg(); }
  else toast(t('toast.err_prefix') + (d.error || '?'), true);
}

// ─── Config Editor ────────────────────────────────────────────────────────
const CFG_TABS_BASE = [
  { id: 'config.json', label: 'config.json' },
  { id: '.claude/settings.json', label: 'settings.json' },
  { id: '.env', label: '.env' },
  { id: 'global-claude-md', label: '🌐 Global CLAUDE.md' },
];

async function openCfgEditor() {
  const mdUrl = curWorkdir ? `/api/claude-md?dir=${encodeURIComponent(curWorkdir)}` : '/api/claude-md';
  const [r1, r2] = await Promise.all([fetch('/api/config-files'), fetch(mdUrl)]);
  cfgFiles = await r1.json();
  const cm = await r2.json();
  cfgFiles['global-claude-md'] = cm.global || '';
  cfgFiles['__globalPath']     = cm.globalPath || '~/.claude/CLAUDE.md';

  const tabs = [...CFG_TABS_BASE];
  if (curWorkdir) {
    cfgFiles['local-claude-md'] = cm.local || '';
    cfgFiles['__localPath']     = cm.localPath || curWorkdir + '/CLAUDE.md';
    const projName = projects.find(p => p.workdir === curWorkdir)?.name || curWorkdir.split('/').pop();
    tabs.push({ id: 'local-claude-md', label: `📁 ${projName}` });
  }

  const t = $i('cfgTabs');
  t.innerHTML = '';
  tabs.forEach((c, i) => {
    const d = document.createElement('div');
    d.className = `modal-tab ${i === 0 ? 'active' : ''}`;
    d.dataset.tabId = c.id;
    d.textContent = c.label;
    d.onclick = () => switchCfgTab(c.id);
    t.appendChild(d);
  });
  activeCfgTab = tabs[0].id;
  $i('cfgEditor').value = cfgFiles[activeCfgTab] || '';
  $i('saveNotice').className = 'save-notice hidden';
  updateCfgPathInfo(activeCfgTab);
  $i('cfgModal').classList.remove('hidden');
}

function updateCfgPathInfo(id) {
  const el = $i('cfgPathInfo');
  if (!el) return;
  let path = '';
  if (id === 'global-claude-md') path = cfgFiles['__globalPath'] || '~/.claude/CLAUDE.md';
  else if (id === 'local-claude-md') path = cfgFiles['__localPath'] || 'WORKDIR/CLAUDE.md';
  if (path) { el.textContent = path; el.classList.remove('hidden'); }
  else { el.textContent = ''; el.classList.add('hidden'); }
}

function switchCfgTab(id) {
  cfgFiles[activeCfgTab] = $i('cfgEditor').value;
  activeCfgTab = id;
  $i('cfgEditor').value = cfgFiles[id] || '';
  $i('saveNotice').className = 'save-notice hidden';
  document.querySelectorAll('.modal-tab').forEach(t => t.classList.toggle('active', t.dataset.tabId === id));
  updateCfgPathInfo(id);
}

async function saveCfg() {
  cfgFiles[activeCfgTab] = $i('cfgEditor').value;
  try {
    let r;
    if (activeCfgTab === 'global-claude-md') {
      r = await fetch('/api/claude-md', { method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type: 'global', content: cfgFiles[activeCfgTab] }) });
    } else if (activeCfgTab === 'local-claude-md') {
      r = await fetch('/api/claude-md', { method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type: 'local', content: cfgFiles[activeCfgTab], dir: curWorkdir }) });
    } else {
      r = await fetch('/api/config-files', { method: 'PUT', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filename: activeCfgTab, content: cfgFiles[activeCfgTab] }) });
    }
    const d = await r.json();
    if (d.ok) {
      $i('saveNotice').className = 'save-notice';
      setTimeout(() => $i('saveNotice').className = 'save-notice hidden', 2000);
      if (activeCfgTab === 'config.json') loadCfg();
      toast(t('cfg.saved'));
    } else toast(t('toast.err_prefix') + (d.error || '?'), true);
  } catch (e) { toast(e.message, true); }
}

function closeCfg() { $i('cfgModal').classList.add('hidden'); }
document.addEventListener('keydown', e => { if (e.key === 'Escape') { closeFpv(); closeCfg(); closeDirModal(); cancelStop(); closeSshHostModal(); } });

// ─── File Browser ─────────────────────────────────────────────────────────
function _filesQS(relPath) {
  const wd = curWorkdir;
  return `path=${encodeURIComponent(relPath)}${wd ? '&workdir=' + encodeURIComponent(wd) : ''}`;
}

async function loadFiles(dir = '') {
  try {
    const r = await fetch(`/api/files?${_filesQS(dir)}`);
    const d = await r.json();
    if (d.type === 'remote') {
      const treeEl = $i('filesTree');
      if (treeEl) treeEl.innerHTML = '<div style="font-size:12px;color:var(--muted);padding:8px 4px;line-height:1.6">🌐 Remote project —<br>file browser not available</div>';
      return;
    }
    if (d.type !== 'dir') return;
    const treeEl = $i('filesTree');
    treeEl.innerHTML = '';

    if (dir) {
      const b = document.createElement('div');
      b.className = 'fii';
      b.innerHTML = '<span class="fi" style="color:var(--muted)">↑</span><span class="fn">..</span>';
      b.onclick = () => loadFiles(dir.split('/').slice(0, -1).join('/'));
      treeEl.appendChild(b);
    }

    const items = d.items.sort((a, b) => a.type !== b.type ? (a.type === 'dir' ? -1 : 1) : a.name.localeCompare(b.name));
    for (const it of items) {
      const el = document.createElement('div');
      el.className = 'fii';
      const fileBtns = it.type === 'file' ? `<button class="fpe" onclick="event.stopPropagation();openFilePreview('${escH(it.path)}','${escH(it.name)}')" title="${t('files.view')}">👁</button><button class="fdl" onclick="event.stopPropagation();downloadFile('${escH(it.path)}')" title="${t('fpv.download')}">⬇</button>` : '';
      el.innerHTML = `<span class="fi">${it.type === 'dir' ? '<span style="color:var(--accent2);font-size:13px">▸</span>' : fileIcon(it.name)}</span><span class="fn">${escH(it.name)}</span><span class="fs">${it.size ? fmtSize(it.size) : ''}</span>${fileBtns}`;
      el.onclick = it.type === 'dir' ? () => loadFiles(it.path) : () => openFilePreview(it.path, it.name);
      treeEl.appendChild(el);
    }

    if (!items.length) treeEl.innerHTML = `<div style="padding:14px;color:var(--muted);text-align:center;font-size:11px">${t('files.empty')}</div>`;
  } catch {}
}

let _fpvPath = '', _fpvName = '';

function closeFpv() {
  $i('filePreviewModal').classList.add('hidden');
  $i('fpvBody').innerHTML = '';
  _fpvPath = ''; _fpvName = '';
}

async function openFilePreview(relPath, name) {
  _fpvPath = relPath;
  _fpvName = name || relPath.split('/').pop();
  const ext = (_fpvName.lastIndexOf('.') > 0 ? _fpvName.slice(_fpvName.lastIndexOf('.')).toLowerCase() : '');
  $i('fpvTitle').textContent = _fpvName;
  $i('fpvExt').textContent = ext || 'file';
  const body = $i('fpvBody');
  body.innerHTML = `<div class="fpv-text" style="color:var(--muted)">${t('toast.loading')}</div>`;
  $i('filePreviewModal').classList.remove('hidden');

  const rawUrl = `/api/files/raw?${_filesQS(relPath)}`;
  const imgExts = ['.png','.jpg','.jpeg','.gif','.webp','.svg','.bmp','.ico','.tiff'];
  const pdfExts = ['.pdf'];
  const mdExts  = ['.md','.mdx'];
  const textExts= ['.js','.ts','.jsx','.tsx','.mjs','.cjs','.py','.rb','.go','.rs','.php',
                   '.java','.kt','.swift','.cs','.cpp','.c','.h','.html','.css','.scss',
                   '.json','.yaml','.yml','.toml','.ini','.cfg','.env','.txt','.sh','.bash',
                   '.zsh','.sql','.graphql','.xml','.vue','.svelte','.log','.pine','.lock'];

  if (imgExts.includes(ext)) {
    body.innerHTML = `<img src="${escH(rawUrl)}" alt="${escH(_fpvName)}" onerror="this.alt=t('fpv.img_error')">`;
    return;
  }
  if (pdfExts.includes(ext)) {
    body.innerHTML = `<iframe src="${escH(rawUrl)}" title="${escH(_fpvName)}"></iframe>`;
    return;
  }
  // md and text: fetch content
  try {
    const r = await fetch(`/api/files?${_filesQS(relPath)}`);
    const d = await r.json();
    if (d.content === '[Binary]' || (!d.content && !textExts.includes(ext) && !mdExts.includes(ext))) {
      body.innerHTML = `<div class="fpv-binary"><div style="font-size:40px">📦</div><div>${t('fpv.binary')}</div><button class="fpv-btn" onclick="fpvDownload()"><svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> ${t('fpv.download')}</button></div>`;
      return;
    }
    if (mdExts.includes(ext)) {
      body.innerHTML = `<div class="fpv-md msg">${renderMd(d.content || '')}</div>`;
    } else {
      body.innerHTML = `<div class="fpv-text">${escH(d.content || '')}</div>`;
    }
  } catch {
    body.innerHTML = `<div class="fpv-binary">${t('fpv.load_error')}</div>`;
  }
}

function fpvDownload() {
  if (_fpvPath) downloadFile(_fpvPath);
}

async function fpvShare() {
  if (!_fpvPath) return;
  const url = location.origin + `/api/files/raw?${_filesQS(_fpvPath)}`;
  if (navigator.share) {
    try {
      await navigator.share({ title: _fpvName, url });
      return;
    } catch {}
  }
  try {
    await navigator.clipboard.writeText(url);
    toast(t('toast.link_copied'));
  } catch {
    prompt(t('toast.link_prompt'), url);
  }
}

function downloadFile(relPath) {
  window.open(`/api/files/download?${_filesQS(relPath)}`, '_blank');
}

function fileIcon(name) {
  const ext = name.split('.').pop().toLowerCase();
  const colors = { js: '#f7df1e', ts: '#3178c6', py: '#3572a5', html: '#e34c26', css: '#264de4', json: '#cbcb41', md: '#083fa1', sh: '#89e051', go: '#00add8', rs: '#dea584', rb: '#701516', sql: '#336791' };
  const color = colors[ext];
  if (color) return `<span style="font-size:10px;font-weight:700;color:${color};font-family:monospace">${ext.toUpperCase()}</span>`;
  return `<span style="font-size:10px;color:var(--muted);font-family:monospace">${ext ? ext.toUpperCase() : 'FILE'}</span>`;
}

function fmtSize(b) {
  return b < 1024 ? b + 'B' : b < 1048576 ? (b / 1024).toFixed(1) + 'K' : (b / 1048576).toFixed(1) + 'M';
}

// ─── Projects ──────────────────────────────────────────────────────────────
async function loadProjectsList() {
  try {
    const r = await fetch('/api/projects');
    projects = await r.json();
    renderProjects();
  } catch(e) { console.error('loadProjectsList:', e); }
}

function renderProjects() {
  const el = $i('projList');
  if (!el) return;
  el.innerHTML = '';
  $i('projCount').textContent = projects.length || '';

  // Update header dropdown
  const activeProj = curProjectId ? projects.find(p => p.id === curProjectId) : null;
  document.title = activeProj ? activeProj.name : 'Claude Code Studio';

  // Update header dropdown
  const ddWrap = $i('projDdWrap');
  const ddName = $i('projDdName');
  if (ddWrap && ddName) {
    if (activeProj) {
      ddName.textContent = activeProj.name;
      ddWrap.classList.add('visible');
    } else {
      ddWrap.classList.remove('visible');
    }
  }
  renderProjDropdownList();

  if (!projects.length) {
    el.innerHTML = `<div style="font-size:11px;color:var(--muted);padding:2px 2px 8px;line-height:1.5">${t('proj.empty')}</div>`;
    return;
  }

  for (const p of projects) {
    const active = p.id === curProjectId;
    // Check if any tab in this project is generating (works for both current and background)
    const tabs = active ? openTabs : (projectTabs[p.id] || []);
    const busy = tabs.some(tab => tab.generating);
    const div = document.createElement('div');
    div.className = `ci${active ? ' on' : ''}`;
    div.title = active ? t('proj.active.title') : t('proj.click.title');
    div.onclick = () => switchProject(p.id);
    const shortPath = p.workdir.length > 38 ? '…' + p.workdir.slice(-36) : p.workdir;
    const busyDot = busy ? `<span class="proj-busy-dot tab-dot spinning" title="${t('proj.generating')}"></span>` : '';
    const remoteBadge = p.isRemote ? `<span class="remote-badge" title="${escH(p.remoteHost||'')}">🌐 SSH</span>` : '';
    div.innerHTML = `
      <div class="inf">
        <div class="nm" data-tip="${escH(p.name)}">${escH(p.name)}${busyDot}${remoteBadge}</div>
        <div class="ds" data-tip="${escH(p.isRemote ? (p.remoteHost||'') + ':' + p.workdir : p.workdir)}">${escH(shortPath)}</div>
        <div class="st">${active ? t('proj.active') : t('proj.inactive')}</div>
      </div>
      <button class="ren" onclick="event.stopPropagation();renameProject('${p.id}',this)" title="${t('proj.rename.title')}">✏</button>
      <button class="rm" onclick="event.stopPropagation();delProject('${p.id}')" title="${t('proj.del.title')}">✕</button>`;
    el.appendChild(div);
  }
}

// ─── Project dropdown in header ────────────────────────────────────────────
let _projDdOpen = false;

function toggleProjDropdown() {
  _projDdOpen = !_projDdOpen;
  const btn = $i('projDdBtn');
  const menu = $i('projDdMenu');
  btn?.classList.toggle('open', _projDdOpen);
  menu?.classList.toggle('open', _projDdOpen);
  if (_projDdOpen) {
    $i('projDdSearch')?.focus();
    renderProjDropdownList();
  }
}

function closeProjDropdown() {
  _projDdOpen = false;
  $i('projDdBtn')?.classList.remove('open');
  $i('projDdMenu')?.classList.remove('open');
}

function renderProjDropdownList(filter = '') {
  const list = $i('projDdList');
  if (!list) return;

  const filtered = filter
    ? projects.filter(p => p.name.toLowerCase().includes(filter.toLowerCase()) || p.workdir.toLowerCase().includes(filter.toLowerCase()))
    : projects;

  if (!filtered.length) {
    list.innerHTML = `<div class="proj-dd-empty">${filter ? t('search.empty') || 'Не знайдено' : t('proj.empty')}</div>`;
    return;
  }

  list.innerHTML = filtered.map(p => {
    const active = p.id === curProjectId;
    const shortPath = p.workdir.length > 45 ? '…' + p.workdir.slice(-43) : p.workdir;
    const rhLabel = p.isRemote ? `<span style="font-size:10px;color:var(--accent2);margin-left:4px">🌐 ${escH(p.remoteHost||'SSH')}</span>` : '';
    return `
      <div class="proj-dd-item${active ? ' active' : ''}" onclick="selectProjFromDropdown('${p.id}')">
        <div class="proj-dd-item-name">${active ? '● ' : ''}${escH(p.name)}${rhLabel}</div>
        <div class="proj-dd-item-path">${escH(shortPath)}</div>
      </div>
    `;
  }).join('');
}

function filterProjDropdown(value) {
  renderProjDropdownList(value);
}

function selectProjFromDropdown(id) {
  closeProjDropdown();
  if (id !== curProjectId) {
    switchProject(id);
  }
}

// Close dropdown on click outside
document.addEventListener('click', e => {
  if (_projDdOpen && !e.target.closest('.proj-dd-wrap')) {
    closeProjDropdown();
  }
});

// Keyboard navigation for dropdown
document.addEventListener('keydown', e => {
  if (!_projDdOpen) return;
  if (e.key === 'Escape') { closeProjDropdown(); e.preventDefault(); }
});

// ─── Per-project tab save/restore ────────────────────────────────────────
const PROJ_TABS_KEY = pid => `cc_ptabs_${pid || '__none'}`;

// loadProjTabs: read from localStorage for initial restore only
function loadProjTabs(pid) {
  try { return JSON.parse(localStorage.getItem(PROJ_TABS_KEY(pid)) || 'null'); } catch { return null; }
}

function switchProject(id) {
  // No isGen block — background generation continues uninterrupted
  const p = projects.find(x => x.id === id);
  if (!p) return;

  // Persist current project's live tab state to memory before switching away
  if (curProjectId) {
    // Save current tab's input draft, attachments & reply-to so they aren't lost
    if (activeTabId) {
      getTS(activeTabId).draft = inEl.value;
      getTS(activeTabId).attachments = [..._attachments];
      getTS(activeTabId).replyTo = replyTo;
    }
    projectTabs[curProjectId] = openTabs;
    projectActiveTab[curProjectId] = activeTabId;
  }

  // Toggle off if clicking the already-active project
  if (curProjectId === id) {
    curProjectId = null; curWorkdir = null;
    openTabs = []; activeTabId = null; currentSessionId = null;
    msgsEl.innerHTML = ''; showW(); renderTabs();
    inEl.value = ''; inEl.style.height = 'auto';
    _clearAttachments(); clearReply();
    renderProjects(); saveUIState(); loadHist(); updateSessBar();
    toast(t('proj.deactivated'));
    return;
  }

  curProjectId = id;
  curWorkdir = p.workdir;

  // Restore from in-memory state (if project was visited before), else from localStorage
  if (projectTabs[id]) {
    openTabs = projectTabs[id];
    activeTabId = projectActiveTab[id] ?? openTabs[0]?.id ?? null;
  } else {
    const saved = loadProjTabs(id);
    if (saved?.tabs?.length) {
      openTabs = saved.tabs.map(t => ({ id: t.id, title: t.title, generating: false, done: false }));
      activeTabId = saved.activeTabId || openTabs[0]?.id || null;
    } else {
      openTabs = []; activeTabId = null;
    }
    projectTabs[id] = openTabs;
    projectActiveTab[id] = activeTabId;
  }

  // Update UI for the newly active project
  // CRITICAL: Always clear currentSessionId immediately when switching projects.
  // loadSess is async — without this, a stale sessionId from the old project
  // could leak into a chat message sent before loadSess completes.
  currentSessionId = null;
  streaming.el = null; streaming.txt = ''; streaming.toolCounts = {}; streaming.toolLog = [];
  renderTabs();
  if (activeTabId) {
    const tab = openTabs.find(t => t.id === activeTabId);
    if (tab?.isNew) { msgsEl.innerHTML = ''; showW(); }
    else loadSess(activeTabId);
    // Sync send/stop button to this tab's generating state
    if (tab?.generating) { isGen = true; generatingTabId = activeTabId; setSendStop(true); }
    else { isGen = false; generatingTabId = null; setSendStop(false); }
  } else {
    msgsEl.innerHTML = ''; showW();
    isGen = false; generatingTabId = null; setSendStop(false);
  }

  // Restore input draft, attachments & reply-to for the target tab (or clear if no tab)
  if (activeTabId) {
    const draft = getTS(activeTabId).draft || '';
    inEl.value = draft;
    inEl.style.height = 'auto';
    inEl.style.height = Math.min(inEl.scrollHeight, 130) + 'px';
    _restoreAttachments(getTS(activeTabId).attachments);
    const savedReply = getTS(activeTabId).replyTo;
    if (savedReply) {
      replyTo = savedReply;
      $i('replyPreviewRole').textContent = savedReply.role === 'user' ? t('you.label') : 'Claude';
      const rc = savedReply.content || '';
      $i('replyPreviewText').textContent = rc.slice(0, 120) + (rc.length > 120 ? '…' : '');
      $i('replyPreview').style.display = 'flex';
    } else { clearReply(); }
  } else {
    inEl.value = '';
    inEl.style.height = 'auto';
    _clearAttachments();
    clearReply();
  }

  renderProjects(); saveUIState(); loadHist(); loadFiles(''); updateSessBar();
  toast(`✓ ${p.name}`);
}

async function delProject(id) {
  const p = projects.find(x => x.id === id);
  if (!confirm(t('proj.delete.confirm').replace('{{name}}', p?.name || id))) return;
  await fetch(`/api/projects/${id}`, { method: 'DELETE' });
  if (curProjectId === id) {
    curProjectId = null; curWorkdir = null;
    openTabs = []; activeTabId = null; currentSessionId = null;
    msgsEl.innerHTML = ''; showW(); renderTabs();
    loadHist();
  }
  // Clean up in-memory state for deleted project
  delete projectTabs[id];
  delete projectActiveTab[id];
  projects = projects.filter(x => x.id !== id);
  try { localStorage.removeItem(PROJ_TABS_KEY(id)); } catch {}
  renderProjects(); saveUIState();
}

async function renameProject(id, btnEl) {
  const p = projects.find(pr => pr.id === id);
  if (!p) return;
  const item = btnEl.closest('.ci');
  const nmEl = item?.querySelector('.nm');
  if (!nmEl) return;
  const oldName = p.name;
  let committed = false;

  // Replace name div with inline input
  const input = document.createElement('input');
  input.className = 'proj-rename-input';
  input.value = oldName;
  input.onclick = e => e.stopPropagation();
  nmEl.replaceWith(input);
  input.focus();
  input.select();

  const commit = async () => {
    if (committed) return;
    committed = true;
    const newName = input.value.trim();
    if (!newName || newName === oldName) { renderProjects(); return; }
    const r = await fetch(`/api/projects/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: newName })
    });
    if (r.ok) {
      p.name = newName;
      // Sync dropdown header if this is the active project
      if (id === curProjectId) {
        const ddName = $i('projDdName');
        if (ddName) ddName.textContent = newName;
      }
    }
    renderProjects();
  };

  const cancel = () => {
    if (committed) return;
    committed = true;
    renderProjects();
  };

  input.addEventListener('keydown', e => {
    if (e.key === 'Enter')  { e.preventDefault(); commit(); }
    if (e.key === 'Escape') { e.preventDefault(); cancel(); }
  });
  // blur fires after keydown — setTimeout lets Escape cancel before commit runs
  input.addEventListener('blur', () => setTimeout(commit, 150));
}

// ─── Directory browser ───────────────────────────────────────────────────
function openAddProject() {
  $i('dirModal').classList.remove('hidden');
  $i('gitInitChk').checked = false;
  $i('projNameInput').value = '';
  dirBrowsePath = null;
  // Reset to local mode
  setProjType('local');
  // Load remote hosts in background for if user switches to remote
  loadRemoteHosts();
  browseDirs(null);
}

async function browseDirs(dirPath) {
  const url = dirPath ? `/api/browse-dirs?path=${encodeURIComponent(dirPath)}` : '/api/browse-dirs';
  try {
    const r = await fetch(url);
    const d = await r.json();
    if (d.error) { toast(d.error, true); return; }

    dirBrowsePath = d.path;
    $i('dirCurrentPath').textContent = d.path;
    // Auto-fill name if empty
    const nameEl = $i('projNameInput');
    if (!nameEl.value) nameEl.value = d.path.split('/').filter(Boolean).pop() || '';

    const list = $i('dirList');
    list.innerHTML = '';

    // Up button
    if (d.parent) {
      const b = document.createElement('div');
      b.className = 'dii';
      b.innerHTML = '<span class="di" style="color:var(--muted)">↑</span><span class="dn" style="color:var(--muted)">..</span>';
      b.onclick = () => browseDirs(d.parent);
      list.appendChild(b);
    }

    // Current dir as selectable row
    const self = document.createElement('div');
    self.className = 'dii selected';
    self.innerHTML = `<span class="di" style="color:var(--accent2)">▸</span><span class="dn"><strong>${t('dir.this_dir')}</strong></span>`;
    self.onclick = () => { dirBrowsePath = d.path; $i('dirCurrentPath').textContent = d.path; highlightSelected(self); };
    list.appendChild(self);

    // Subdirectories — single click selects, double click navigates
    for (const it of d.items) {
      const el = document.createElement('div');
      el.className = `dii${it.hidden ? ' hidden-dir' : ''}`;
      el.innerHTML = `<span class="di" style="color:var(--muted)">▸</span><span class="dn">${escH(it.name)}</span>`;
      el.onclick = () => {
        if (el._t) { clearTimeout(el._t); el._t = null; browseDirs(it.path); }
        else { el._t = setTimeout(() => {
          el._t = null;
          dirBrowsePath = it.path;
          $i('dirCurrentPath').textContent = it.path;
          $i('projNameInput').value = it.name;
          highlightSelected(el);
        }, 220); }
      };
      list.appendChild(el);
    }

    if (!d.items.length) {
      const e = document.createElement('div');
      e.style.cssText = 'padding:12px;color:var(--muted);text-align:center;font-size:12px';
      e.textContent = t('dir.no_subdirs');
      list.appendChild(e);
    }
  } catch(e) { toast(t('toast.err_prefix') + e.message, true); }
}

function highlightSelected(el) {
  $i('dirList').querySelectorAll('.dii').forEach(d => d.classList.remove('selected'));
  el.classList.add('selected');
}

async function selectDir() {
  // Remote project
  if (curProjType === 'remote') {
    const rhId = $i('remoteHostSelect')?.value;
    const remoteWorkdir = ($i('remoteWorkdirInput')?.value || '').trim();
    if (!rhId) { toast('Оберіть SSH хост', true); return; }
    if (!remoteWorkdir) { toast('Вкажіть шлях на сервері', true); return; }
    const name = ($i('projNameInput').value.trim()) || remoteWorkdir.split('/').filter(Boolean).pop() || remoteWorkdir;
    const r = await fetch('/api/projects', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, workdir: remoteWorkdir, isRemote: true, remoteHostId: rhId, remoteWorkdir }),
    });
    const d = await r.json();
    if (!d.ok) { toast((d.error || 'Помилка'), true); return; }
    await loadProjectsList();
    if (d.id) switchProject(d.id);
    closeDirModal();
    if (_onProjectCreated) { const cb = _onProjectCreated; _onProjectCreated = null; cb(); }
    return;
  }
  // Local project
  if (!dirBrowsePath) { toast(t('toast.select_dir'), true); return; }
  const name = ($i('projNameInput').value.trim()) || dirBrowsePath.split('/').filter(Boolean).pop() || dirBrowsePath;
  const gitInit = $i('gitInitChk').checked;

  const r = await fetch('/api/projects', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, workdir: dirBrowsePath, gitInit }),
  });
  const d = await r.json();
  if (!d.ok) { toast(t('toast.err_prefix') + (d.error || '?'), true); return; }
  if (d.gitError) toast('git init: ' + d.gitError, true, 4000);
  else if (d.actions?.length) toast('✓ ' + d.actions.join(', '));

  await loadProjectsList();
  if (d.id) switchProject(d.id);
  closeDirModal();
  if (_onProjectCreated) { const cb = _onProjectCreated; _onProjectCreated = null; cb(); }
}

function closeDirModal() {
  $i('dirModal').classList.add('hidden');
}

// ─── Remote SSH Project Type Toggle ──────────────────────────────────────
let curProjType = 'local';

function setProjType(type) {
  curProjType = type;
  $i('projTypeLocal').classList.toggle('active', type === 'local');
  $i('projTypeRemote').classList.toggle('active', type === 'remote');
  $i('projLocalSection').style.display = type === 'local' ? '' : 'none';
  $i('projRemoteSection').style.display = type === 'remote' ? 'block' : 'none';
  const gitLbl = $i('gitInitLabel');
  if (gitLbl) gitLbl.style.display = type === 'local' ? '' : 'none';
  if (type === 'remote') renderRemoteHostSelect();
}

// ─── Remote SSH Hosts ─────────────────────────────────────────────────────
let remoteHosts = [];
let _editingHostId = null;

async function loadRemoteHosts() {
  try {
    const r = await fetch('/api/remote-hosts');
    if (!r.ok) return;
    remoteHosts = await r.json();
    renderRemoteHostsList();
    renderRemoteHostSelect();
    const cnt = $i('sshHostCount');
    if (cnt) cnt.textContent = remoteHosts.length || '';
  } catch(e) { console.error('loadRemoteHosts:', e); }
}

function renderRemoteHostsList() {
  const el = $i('sshHostList');
  if (!el) return;
  if (!remoteHosts.length) {
    el.innerHTML = `<div style="font-size:11px;color:var(--muted);padding:4px 2px;line-height:1.5">Немає налаштованих SSH хостів</div>`;
    return;
  }
  el.innerHTML = remoteHosts.map(h => {
    const hostInfo = h.host + (h.port && h.port != 22 ? ':' + h.port : '');
    return `
    <div class="rh-item">
      <span class="rh-dot" id="rh-dot-${h.id}"></span>
      <div class="inf">
        <div class="nm" data-tip="${escH(h.label)}">${escH(h.label)}</div>
        <div class="ds" data-tip="${escH(hostInfo)}">${escH(hostInfo)}</div>
      </div>
      <button class="cfg" onclick="testRemoteHost('${h.id}')" title="Тест з'єднання">⚡</button>
      <button class="cfg" onclick="editRemoteHost('${h.id}')" title="Редагувати">✏</button>
      <button class="rm"  onclick="deleteRemoteHost('${h.id}')" title="Видалити">✕</button>
    </div>`;
  }).join('');
}

function renderRemoteHostSelect() {
  const sel = $i('remoteHostSelect');
  if (!sel) return;
  const cur = sel.value;
  sel.innerHTML = `<option value="">— оберіть хост —</option>` +
    remoteHosts.map(h => `<option value="${h.id}"${h.id === cur ? ' selected' : ''}>${escH(h.label)} (${escH(h.host)})</option>`).join('');
}

async function testRemoteHost(id) {
  const dot = $i(`rh-dot-${id}`);
  if (dot) { dot.className = 'rh-dot'; dot.title = 'Перевірка...'; }
  try {
    const r = await fetch(`/api/remote-hosts/${id}/test`, { method: 'POST' });
    const d = await r.json();
    if (dot) { dot.className = 'rh-dot ' + (d.ok ? 'ok' : 'err'); dot.title = d.ok ? `OK (${d.latencyMs}ms)` : (d.error || 'Помилка'); }
    toast(d.ok ? `✓ ${d.message} (${d.latencyMs}ms)` : `✗ ${d.error}`, !d.ok);
  } catch(e) {
    if (dot) { dot.className = 'rh-dot err'; dot.title = 'Помилка'; }
  }
}

async function deleteRemoteHost(id) {
  const h = remoteHosts.find(x => x.id === id);
  if (!confirm(`Видалити хост "${h?.label || id}"?`)) return;
  await fetch(`/api/remote-hosts/${id}`, { method: 'DELETE' });
  await loadRemoteHosts();
  toast('✓ Хост видалено');
}

async function testSelectedHost() {
  const id = $i('remoteHostSelect')?.value;
  if (!id) { toast('Оберіть хост', true); return; }
  const res = $i('remoteTestResult');
  if (res) { res.textContent = '⏳ Перевірка...'; res.className = 'rh-test-result'; }
  try {
    const r = await fetch(`/api/remote-hosts/${id}/test`, { method: 'POST' });
    const d = await r.json();
    if (res) { res.textContent = d.ok ? `✓ ${d.message} (${d.latencyMs}ms)` : `✗ ${d.error}`; res.className = 'rh-test-result ' + (d.ok ? 'ok' : 'err'); }
  } catch(e) {
    if (res) { res.textContent = '✗ Помилка підключення'; res.className = 'rh-test-result err'; }
  }
}

// ─── Add SSH Host Modal ───────────────────────────────────────────────────
function openAddHostModal() {
  _editingHostId = null;
  $i('sshHostModalTitle').textContent = '🌐 Додати SSH хост';
  $i('sshHostSaveBtn').textContent = '＋ Зберегти хост';
  $i('sshHostLabel').value = '';
  $i('sshHostHost').value = '';
  $i('sshHostPort').value = '22';
  $i('sshHostKey').value = '';
  $i('sshHostPassword').value = '';
  $i('sshHostTestResult').textContent = '';
  $i('sshHostTestResult').className = 'rh-test-result';
  setAuthType('key');
  $i('sshHostModal').classList.remove('hidden');
  setTimeout(() => $i('sshHostLabel')?.focus(), 80);
}

function closeSshHostModal() {
  $i('sshHostModal').classList.add('hidden');
}

function setAuthType(type) {
  const isKey = type === 'key';
  $i('sshAuthBtnKey').classList.toggle('active', isKey);
  $i('sshAuthBtnPwd').classList.toggle('active', !isKey);
  $i('sshHostKeyRow').classList.toggle('hidden', !isKey);
  $i('sshHostPasswordRow').classList.toggle('hidden', isKey);
}

async function editRemoteHost(id) {
  const h = remoteHosts.find(x => x.id === id);
  if (!h) return;
  _editingHostId = id;
  $i('sshHostModalTitle').textContent = '✏️ Редагувати SSH хост';
  $i('sshHostSaveBtn').textContent = '💾 Оновити хост';
  $i('sshHostLabel').value = h.label || '';
  $i('sshHostHost').value = h.host || '';
  $i('sshHostPort').value = h.port || 22;
  $i('sshHostTestResult').textContent = '';
  $i('sshHostTestResult').className = 'rh-test-result';
  // Determine auth type: if host has password marker use pwd mode, otherwise key mode
  const hasPwd = h.password && h.password !== '***' && h.password !== '';
  setAuthType(hasPwd ? 'pwd' : 'key');
  $i('sshHostKey').value = hasPwd ? '' : (h.sshKeyPath || '');
  $i('sshHostPassword').value = hasPwd ? '' : '';  // never pre-fill password for security
  $i('sshHostModal').classList.remove('hidden');
  setTimeout(() => $i('sshHostLabel')?.focus(), 80);
}

async function testNewSshHost() {
  const host = $i('sshHostHost').value.trim();
  const port = $i('sshHostPort').value || 22;
  const usePwd = $i('sshAuthBtnPwd').classList.contains('active');
  const sshKeyPath = usePwd ? '' : $i('sshHostKey').value.trim();
  const password = usePwd ? $i('sshHostPassword').value : '';
  if (!host) { toast('Вкажіть хост', true); return; }
  const res = $i('sshHostTestResult');
  res.textContent = '⏳ Підключення...'; res.className = 'rh-test-result';
  try {
    const r = await fetch('/api/remote-hosts/test-new', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ host, port: Number(port), sshKeyPath, password }),
    });
    const d = await r.json();
    res.textContent = d.ok ? `✓ ${d.message} (${d.latencyMs}ms)` : `✗ ${d.error}`;
    res.className = 'rh-test-result ' + (d.ok ? 'ok' : 'err');
  } catch(e) {
    res.textContent = '✗ Помилка підключення'; res.className = 'rh-test-result err';
  }
}

async function saveNewSshHost() {
  const label = $i('sshHostLabel').value.trim();
  const host = $i('sshHostHost').value.trim();
  const port = Number($i('sshHostPort').value) || 22;
  const usePwd = $i('sshAuthBtnPwd').classList.contains('active');
  const sshKeyPath = usePwd ? '' : $i('sshHostKey').value.trim();
  const password = usePwd ? $i('sshHostPassword').value : '';
  if (!label) { toast('Вкажіть назву', true); return; }
  if (!host) { toast('Вкажіть хост', true); return; }
  const isEdit = !!_editingHostId;
  const url = isEdit ? `/api/remote-hosts/${_editingHostId}` : '/api/remote-hosts';
  const r = await fetch(url, {
    method: isEdit ? 'PUT' : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ label, host, port, sshKeyPath, password }),
  });
  const d = await r.json();
  if (!d.ok) { toast(d.error || 'Помилка', true); return; }
  await loadRemoteHosts();
  closeSshHostModal();
  toast(`✓ Хост "${label}" ${isEdit ? 'оновлено' : 'збережено'}`);
  // If project dialog is open and on remote tab, update the select
  if (curProjType === 'remote') renderRemoteHostSelect();
}

// ─── Persist UI state across page refreshes ──────────────────────────────
const LS_KEY = 'cc_ui_state';
function saveUIState() {
  try {
    const c = id => $i(id)?.classList.contains('collapsed');
    // Collect all project tab states (current + background)
    const allProjTabs = {};
    for (const [pid, tabs] of Object.entries(projectTabs)) {
      allProjTabs[pid] = {
        tabs: tabs.filter(t => !t.isNew).map(t => ({ id: t.id, title: t.title })),
        activeTabId: pid === curProjectId ? activeTabId : (projectActiveTab[pid] || tabs[0]?.id || null),
      };
    }
    // Ensure current project is always included
    if (curProjectId) {
      allProjTabs[curProjectId] = {
        tabs: openTabs.filter(t => !t.isNew).map(t => ({ id: t.id, title: t.title })),
        activeTabId: openTabs.find(t => t.id === activeTabId && !t.isNew) ? activeTabId : null,
      };
    }
    localStorage.setItem(LS_KEY, JSON.stringify({
      activeMcp: [...activeMcp],
      activeSkills: [...activeSkills],
      autoSkillsMode,
      curWorkdir, curProjectId,
      panels: { left: c('leftPanel'), right: c('rightPanel') },
      sections: { hist: c('histBody'), mcp: c('mcpBody'), skills: c('skillsBody'), proj: c('projBody'), sshHosts: c('sshHostsBody') },
      openTabs: openTabs.filter(t => !t.isNew).map(t => ({ id: t.id, title: t.title })),
      activeTabId: openTabs.find(t => t.id === activeTabId && !t.isNew) ? activeTabId : null,
      allProjTabs,
      headerCollapsed: c('hdrZone') || false,
      fontSize: parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--msg-font')) || 15.5,
    }));
  } catch {}
}
function restoreUIState() {
  try {
    const s = JSON.parse(localStorage.getItem(LS_KEY) || 'null');
    if (!s) return;
    if (s.activeMcp) activeMcp = new Set(s.activeMcp);
    if (s.activeSkills) activeSkills = new Set(s.activeSkills);
    if (s.autoSkillsMode !== undefined) { autoSkillsMode = !!s.autoSkillsMode; }
    if (s.curWorkdir) curWorkdir = s.curWorkdir;
    if (s.curProjectId) curProjectId = s.curProjectId;
    if (s.panels) {
      const setPanel = (id, collapsed) => {
        const el = $i(id); if (!el) return;
        el.classList.toggle('collapsed', !!collapsed);
        const btn = document.querySelector(`[onclick="toggle('${id}')"]`);
        if (btn) btn.classList.toggle('active', !collapsed);
      };
      setPanel('leftPanel', s.panels.left);
      setPanel('rightPanel', s.panels.right);
    }
    if (s.sections) {
      const secs = { hist: 'histBody', mcp: 'mcpBody', skills: 'skillsBody', proj: 'projBody', sshHosts: 'sshHostsBody' };
      for (const [k, elId] of Object.entries(secs)) {
        const el = $i(elId);
        if (!el) continue;
        el.classList.toggle('collapsed', !!s.sections[k]);
        const title = el.previousElementSibling;
        if (title) title.setAttribute('aria-expanded', String(!s.sections[k]));
      }
    }
    // Restore current project's tabs
    if (s.openTabs?.length) {
      openTabs = s.openTabs.map(t => ({ id: t.id, title: t.title, generating: false, done: false }));
      activeTabId = s.activeTabId || null;
    }
    // Pre-populate background project tab arrays from saved state
    if (s.allProjTabs) {
      for (const [pid, saved] of Object.entries(s.allProjTabs)) {
        if (pid === curProjectId) continue; // current project already restored above
        if (saved?.tabs?.length) {
          projectTabs[pid] = saved.tabs.map(t => ({ id: t.id, title: t.title, generating: false, done: false }));
          projectActiveTab[pid] = saved.activeTabId || projectTabs[pid][0]?.id || null;
        }
      }
    }
    // Sync projectTabs for current project
    if (curProjectId && openTabs.length) {
      projectTabs[curProjectId] = openTabs;
      projectActiveTab[curProjectId] = activeTabId;
    }
    // Restore header collapsed state
    if (s.headerCollapsed) {
      const zone = $i('hdrZone');
      if (zone) zone.classList.add('collapsed');
    }
    // Restore font size
    if (s.fontSize) {
      document.documentElement.style.setProperty('--msg-font', s.fontSize + 'px');
    }
  } catch {}
}

// ─── Global tooltip system ────────────────────────────────────────────────
const _tipEl = (() => {
  const d = document.createElement('div');
  d.id = 'globalTip';
  document.body.appendChild(d);
  return d;
})();
let _tipTimer = null;
document.addEventListener('mouseover', e => {
  const el = e.target.closest('[data-tip]');
  clearTimeout(_tipTimer);
  if (!el) { _tipEl.style.opacity = '0'; return; }
  const txt = el.getAttribute('data-tip');
  if (!txt) { _tipEl.style.opacity = '0'; return; }
  _tipTimer = setTimeout(() => {
    _tipEl.textContent = txt;
    const r = el.getBoundingClientRect();
    const tw = _tipEl.offsetWidth || 200;
    const th = _tipEl.offsetHeight || 30;
    let x = Math.round(r.left + r.width / 2 - tw / 2);
    let y = Math.round(r.top - th - 8);
    if (y < 8) y = Math.round(r.bottom + 8);
    x = Math.max(8, Math.min(x, window.innerWidth - tw - 8));
    _tipEl.style.left = x + 'px';
    _tipEl.style.top = y + 'px';
    _tipEl.style.opacity = '1';
  }, 420);
});
document.addEventListener('mouseout', () => {
  clearTimeout(_tipTimer);
  _tipEl.style.opacity = '0';
});

// ─── Init ─────────────────────────────────────────────────────────────────
setLang(localStorage.getItem('lang') || 'uk');
restoreUIState();
_rlRestore(); // Restore rate limit badge from localStorage if still active
{
  const btn = $i('autoSkillsBtn');
  if (btn) {
    btn.classList.toggle('active', autoSkillsMode);
    btn.title = autoSkillsMode ? t('auto.title.on') : t('auto.title.off');
  }
  const hint = $i('autoSkillsHint');
  if (hint) hint.style.display = autoSkillsMode ? 'block' : 'none';
}
renderTabs();
loadCfg();
loadProjectsList();
loadRemoteHosts();
connect();
checkVersion();
// Handle ?open_session=<id> from Kanban board links
{
  const qs = new URLSearchParams(location.search);
  const sessId = qs.get('open_session');
  if (sessId) {
    history.replaceState(null, '', '/');
    // Wait for WS connect, then open the session tab
    const tryOpen = () => {
      if (!openTabs.find(t => t.id === sessId)) openTab(sessId, '…');
      else switchTab(sessId);
    };
    if (ws && ws.readyState === 1) tryOpen();
    else setTimeout(tryOpen, 800);
  }
}
</script>
</body>
</html>
